From: jingi_jeong <jingi_jeong@tmax.co.kr>
Date: Thu, 1 Apr 2021 17:03:37 +0900
Subject: [feat] desktop-icons-ng : apply ESLint rule

- apply ESLint rule

[IMS] N/A
---
 extensions/desktop-icons-ng/desktopGrid.js    | 215 ++++----
 extensions/desktop-icons-ng/desktopManager.js | 750 +++++++++++++-------------
 extensions/desktop-icons-ng/ding.js           |  31 +-
 extensions/desktop-icons-ng/extension.js      | 184 ++++---
 extensions/desktop-icons-ng/fileItem.js       | 592 ++++++++++----------
 5 files changed, 896 insertions(+), 876 deletions(-)

diff --git a/extensions/desktop-icons-ng/desktopGrid.js b/extensions/desktop-icons-ng/desktopGrid.js
index 91357fd..a0ca2d8 100644
--- a/extensions/desktop-icons-ng/desktopGrid.js
+++ b/extensions/desktop-icons-ng/desktopGrid.js
@@ -1,3 +1,4 @@
+/* exported DesktopGrid */
 /* DING: Desktop Icons New Generation for GNOME Shell
  *
  * Copyright (C) 2019 Sergio Costas (rastersoft@gmail.com)
@@ -18,14 +19,10 @@
 
 const Gtk = imports.gi.Gtk;
 const Gdk = imports.gi.Gdk;
-const Gio = imports.gi.Gio;
-const GLib = imports.gi.GLib;
 
 const Prefs = imports.preferences;
 const Enums = imports.enums;
 const DesktopIconsUtil = imports.desktopIconsUtil;
-const Signals = imports.signals;
-
 const Gettext = imports.gettext.domain('ding');
 
 const _ = Gettext.gettext;
@@ -44,30 +41,28 @@ var DesktopGrid = class {
         this._zoom = desktopDescription.zoom;
         this._x = desktopDescription.x;
         this._y = desktopDescription.y;
-        let size_divisor = this._zoom;
-        let using_X11 = Gdk.Display.get_default().constructor.$gtype.name === 'GdkX11Display';
+        let sizeDivisor = this._zoom;
+        let usingX11 = Gdk.Display.get_default().constructor.$gtype.name === 'GdkX11Display';
         if (asDesktop) {
-            if (using_X11) {
-                size_divisor = Math.ceil(this._zoom);
-            } else {
-                if (premultiplied) {
-                    size_divisor = 1;
-                }
-            }
+            if (usingX11)
+                sizeDivisor = Math.ceil(this._zoom);
+            else if (premultiplied)
+                sizeDivisor = 1;
+
         }
-        this._width = Math.floor(desktopDescription.width / size_divisor);
-        this._height = Math.floor(desktopDescription.height / size_divisor);
+        this._width = Math.floor(desktopDescription.width / sizeDivisor);
+        this._height = Math.floor(desktopDescription.height / sizeDivisor);
         this._maxColumns = Math.floor(this._width / (Prefs.get_desired_width() + 4 * elementSpacing));
         this._maxRows =  Math.floor(this._height / (Prefs.get_desired_height() + 4 * elementSpacing));
         this._elementWidth = Math.floor(this._width / this._maxColumns);
         this._elementHeight = Math.floor(this._height / this._maxRows);
 
-        this._window = new Gtk.Window({"title": desktopName});
+        this._window = new Gtk.Window({ 'title': desktopName });
         if (asDesktop) {
             this._window.set_decorated(false);
             this._window.set_deletable(false);
             // If we are under X11, manage everything from here
-            if (using_X11) {
+            if (usingX11) {
                 this._window.set_type_hint(Gdk.WindowTypeHint.DESKTOP);
                 this._window.stick();
                 this._window.move(this._x / this._zoom, this._y / this._zoom);
@@ -75,9 +70,9 @@ var DesktopGrid = class {
         }
         this._window.set_resizable(false);
         this._window.connect('delete-event', () => {
-            if (this._destroying) {
+            if (this._destroying)
                 return false;
-            }
+
             if (this._asDesktop) {
                 // Do not destroy window when closing if the instance is working as desktop
                 return true;
@@ -102,7 +97,7 @@ var DesktopGrid = class {
             if (visual && screen.is_composited() && this._asDesktop) {
                 this._window.set_visual(visual);
                 this._window.connect('draw', (widget, cr) => {
-                    Gdk.cairo_set_source_rgba(cr, new Gdk.RGBA({red: 0.0, green: 0.0, blue: 0.0, alpha: 0.0}));
+                    Gdk.cairo_set_source_rgba(cr, new Gdk.RGBA({ red: 0.0, green: 0.0, blue: 0.0, alpha: 0.0 }));
                     cr.paint();
                     cr.$dispose();
                     return false;
@@ -119,10 +114,10 @@ var DesktopGrid = class {
         this._fileItems = {};
 
         this._gridStatus = {};
-        for (let y=0; y<this._maxRows; y++) {
-            for (let x=0; x<this._maxColumns; x++) {
+        for (let y = 0; y < this._maxRows; y++) {
+            for (let x = 0; x < this._maxColumns; x++)
                 this._setGridUse(x, y, false);
-            }
+
         }
         this._window.show_all();
         this._window.set_size_request(this._width, this._height);
@@ -132,17 +127,17 @@ var DesktopGrid = class {
                                   Gdk.EventMask.BUTTON_RELEASE_MASK |
                                   Gdk.EventMask.KEY_RELEASE_MASK);
         this._eventBox.connect('button-press-event', (actor, event) => {
-            let [a, x, y] = event.get_coords();
+            let [unused, x, y] = event.get_coords();
             [x, y] = this._coordinatesLocalToGlobal(x, y);
             this._desktopManager.onPressButton(x, y, event, this);
             return false;
         });
         this._eventBox.connect('motion-notify-event', (actor, event) => {
-            let [a, x, y] = event.get_coords();
+            let [unused, x, y] = event.get_coords();
             [x, y] = this._coordinatesLocalToGlobal(x, y);
             this._desktopManager.onMotion(x, y);
         });
-        this._eventBox.connect('button-release-event', (actor, event) => {
+        this._eventBox.connect('button-release-event', (unusedActor, unusedEvent) => {
             this._desktopManager.onReleaseButton(this);
         });
         this._window.connect('key-press-event', (actor, event) => {
@@ -163,16 +158,16 @@ var DesktopGrid = class {
         targets.add(Gdk.atom_intern('text/uri-list', false), 0, 2);
         targets.add(Gdk.atom_intern('text/plain', false), 0, 3);
         dropDestination.drag_dest_set_target_list(targets);
-        dropDestination.connect('drag-motion', (widget, context, x, y, time) => {
+        dropDestination.connect('drag-motion', (widget, context, x, y, unused) => {
             x = this._elementWidth * Math.floor(x / this._elementWidth);
             y = this._elementHeight * Math.floor(y / this._elementHeight);
             [x, y] = this._coordinatesLocalToGlobal(x, y);
             this._desktopManager.onDragMotion(x, y);
         });
-        this._eventBox.connect('drag-leave', (widget, context, time) => {
+        this._eventBox.connect('drag-leave', (unusedWidget, unused1, unused2) => {
             this._desktopManager.onDragLeave();
         });
-        dropDestination.connect('drag-data-received', (widget, context, x, y, selection, info, time) => {
+        dropDestination.connect('drag-data-received', (widget, context, x, y, selection, info, unused) => {
             x = this._elementWidth * Math.floor(x / this._elementWidth);
             y = this._elementHeight * Math.floor(y / this._elementHeight);
             [x, y] = this._coordinatesLocalToGlobal(x, y);
@@ -192,11 +187,11 @@ var DesktopGrid = class {
             x += ox;
             y += oy;
             let r = this.getGridAt(x, y, false);
-            if (r !== null) {
+            if (r !== null)
                 newSelectedList.push(r);
-            }
+
         }
-        if (newSelectedList.length == 0) {
+        if (newSelectedList.length === 0) {
             if (this._selectedList !== null) {
                 this._selectedList = null;
                 this._window.queue_draw();
@@ -204,15 +199,15 @@ var DesktopGrid = class {
             return;
         }
         if (this._selectedList !== null) {
-            if ((newSelectedList[0][0] == this._selectedList[0][0]) && (newSelectedList[0][1] == this._selectedList[0][1])) {
+            if (newSelectedList[0][0] === this._selectedList[0][0] && newSelectedList[0][1] === this._selectedList[0][1])
                 return;
-            }
+
         }
         this._selectedList = newSelectedList;
         this._window.queue_draw();
     }
 
-    queue_draw() {
+    queueDraw() {
         this._window.queue_draw();
     }
 
@@ -223,44 +218,44 @@ var DesktopGrid = class {
             let minY = Math.min(this._desktopManager.rubberBandInitY, this._desktopManager.mouseY);
             let maxY = Math.max(this._desktopManager.rubberBandInitY, this._desktopManager.mouseY);
 
-            if ((minX >= (this._x + this._width )) || (minY >= (this._y + this._height)) || (maxX < this._x) || (maxY < this._y)) {
+            if (minX >= this._x + this._width  || minY >= this._y + this._height || maxX < this._x || maxY < this._y)
                 return;
-            }
+
 
             let [xInit, yInit] = this._coordinatesGlobalToLocal(minX, minY);
             let [xFin, yFin] = this._coordinatesGlobalToLocal(maxX, maxY);
 
             cr.rectangle(xInit + 0.5, yInit + 0.5, xFin - xInit, yFin - yInit);
-            Gdk.cairo_set_source_rgba(cr, new Gdk.RGBA({red: this._desktopManager.selectColor.red,
-                                                        green: this._desktopManager.selectColor.green,
-                                                        blue: this._desktopManager.selectColor.blue,
-                                                        alpha: 0.6})
+            Gdk.cairo_set_source_rgba(cr, new Gdk.RGBA({ red: this._desktopManager.selectColor.red,
+                green: this._desktopManager.selectColor.green,
+                blue: this._desktopManager.selectColor.blue,
+                alpha: 0.6 })
             );
             cr.fill();
             cr.setLineWidth(1);
             cr.rectangle(xInit + 0.5, yInit + 0.5, xFin - xInit, yFin - yInit);
-            Gdk.cairo_set_source_rgba(cr, new Gdk.RGBA({red: this._desktopManager.selectColor.red,
-                                                        green: this._desktopManager.selectColor.green,
-                                                        blue: this._desktopManager.selectColor.blue,
-                                                        alpha: 1.0})
+            Gdk.cairo_set_source_rgba(cr, new Gdk.RGBA({ red: this._desktopManager.selectColor.red,
+                green: this._desktopManager.selectColor.green,
+                blue: this._desktopManager.selectColor.blue,
+                alpha: 1.0 })
             );
             cr.stroke();
         }
-        if (this._desktopManager.showDropPlace && (this._selectedList !== null)) {
-            for(let [x, y] of this._selectedList) {
+        if (this._desktopManager.showDropPlace && this._selectedList !== null) {
+            for (let [x, y] of this._selectedList) {
                 cr.rectangle(x + 0.5, y + 0.5, this._elementWidth, this._elementHeight);
-                Gdk.cairo_set_source_rgba(cr, new Gdk.RGBA({red: 1.0 - this._desktopManager.selectColor.red,
-                                                            green: 1.0 - this._desktopManager.selectColor.green,
-                                                            blue: 1.0 - this._desktopManager.selectColor.blue,
-                                                            alpha: 0.4})
+                Gdk.cairo_set_source_rgba(cr, new Gdk.RGBA({ red: 1.0 - this._desktopManager.selectColor.red,
+                    green: 1.0 - this._desktopManager.selectColor.green,
+                    blue: 1.0 - this._desktopManager.selectColor.blue,
+                    alpha: 0.4 })
                 );
                 cr.fill();
                 cr.setLineWidth(0.5);
                 cr.rectangle(x + 0.5, y + 0.5, this._elementWidth, this._elementHeight);
-                Gdk.cairo_set_source_rgba(cr, new Gdk.RGBA({red: 1.0 - this._desktopManager.selectColor.red,
-                                                            green: 1.0 - this._desktopManager.selectColor.green,
-                                                            blue: 1.0 - this._desktopManager.selectColor.blue,
-                                                            alpha: 1.0})
+                Gdk.cairo_set_source_rgba(cr, new Gdk.RGBA({ red: 1.0 - this._desktopManager.selectColor.red,
+                    green: 1.0 - this._desktopManager.selectColor.green,
+                    blue: 1.0 - this._desktopManager.selectColor.blue,
+                    alpha: 1.0 })
                 );
                 cr.stroke();
             }
@@ -276,20 +271,20 @@ var DesktopGrid = class {
          *            or the distance to the middle point, if none of the previous
          */
 
-         let isFree = false;
-         for (let element in this._gridStatus) {
-             if (!this._gridStatus[element]) {
-                 isFree = true;
-                 break;
-             }
-         }
-         if (!isFree) {
-             return -1;
-         }
-         if (this._coordinatesBelongToThisGrid(x, y)) {
-             return 0;
-         }
-         return Math.pow(x - (this._x + this._width * this._zoom / 2), 2) + Math.pow(x - (this._y + this._height * this._zoom / 2), 2);
+        let isFree = false;
+        for (let element in this._gridStatus) {
+            if (!this._gridStatus[element]) {
+                isFree = true;
+                break;
+            }
+        }
+        if (!isFree)
+            return -1;
+
+        if (this._coordinatesBelongToThisGrid(x, y))
+            return 0;
+
+        return Math.pow(x - (this._x + this._width * this._zoom / 2), 2) + Math.pow(x - (this._y + this._height * this._zoom / 2), 2);
     }
 
     _coordinatesGlobalToLocal(x, y) {
@@ -311,26 +306,26 @@ var DesktopGrid = class {
         this._fileItems[fileItem.uri] = [column, row, fileItem];
         let [x, y] = this._coordinatesLocalToGlobal(localX + elementSpacing, localY + elementSpacing);
         fileItem.setCoordinates(x,
-                                y,
-                                this._elementWidth - 2 * elementSpacing,
-                                this._elementHeight - 2 * elementSpacing,
-                                elementSpacing,
-                                this._zoom,
-                                this);
+            y,
+            this._elementWidth - 2 * elementSpacing,
+            this._elementHeight - 2 * elementSpacing,
+            elementSpacing,
+            this._zoom,
+            this);
         /* If this file is new in the Desktop and hasn't yet
          * fixed coordinates, store the new possition to ensure
          * that the next time it will be shown in the same possition.
          * Also store the new possition if it has been moved by the user,
          * and not triggered by a screen change.
          */
-        if ((fileItem.savedCoordinates == null) || (coordinatesAction == Enums.StoredCoordinates.OVERWRITE)) {
+        if (fileItem.savedCoordinates === null || coordinatesAction === Enums.StoredCoordinates.OVERWRITE)
             fileItem.savedCoordinates = [x, y];
-        }
+
     }
 
     removeItem(fileItem) {
         if (fileItem.uri in this._fileItems) {
-            let [column, row, tmp] = this._fileItems[fileItem.uri];
+            let [column, row, unused] = this._fileItems[fileItem.uri];
             this._setGridUse(column, row, false);
             this._container.remove(fileItem.actor);
             delete this._fileItems[fileItem.uri];
@@ -338,15 +333,15 @@ var DesktopGrid = class {
     }
 
     addFileItemCloseTo(fileItem, x, y, coordinatesAction) {
-        let add_volumes_opposite = Prefs.desktopSettings.get_boolean('add-volumes-opposite');
+        let addVolumesOpposite = Prefs.desktopSettings.get_boolean('add-volumes-opposite');
         let [column, row] = this._getEmptyPlaceClosestTo(x,
-                                                         y,
-                                                         coordinatesAction,
-                                                         fileItem.isDrive && add_volumes_opposite);
+            y,
+            coordinatesAction,
+            fileItem.isDrive && addVolumesOpposite);
         this._addFileItemTo(fileItem, column, row, coordinatesAction);
     }
 
-    _isEmptyAt(x,y) {
+    _isEmptyAt(x, y) {
         return !this._gridStatus[y * this._maxColumns + x];
     }
 
@@ -357,11 +352,11 @@ var DesktopGrid = class {
     getGridAt(x, y, globalCoordinates) {
         if (this._coordinatesBelongToThisGrid(x, y)) {
             [x, y] = this._coordinatesGlobalToLocal(x, y);
-            x = this._elementWidth * Math.floor((x / this._elementWidth) + 0.5);
-            y = this._elementHeight * Math.floor((y / this._elementHeight) + 0.5);
-            if (globalCoordinates) {
+            x = this._elementWidth * Math.floor(x / this._elementWidth + 0.5);
+            y = this._elementHeight * Math.floor(y / this._elementHeight + 0.5);
+            if (globalCoordinates)
                 [x, y] = this._coordinatesLocalToGlobal(x, y);
-            }
+
             return [x, y];
         } else {
             return null;
@@ -369,7 +364,7 @@ var DesktopGrid = class {
     }
 
     _coordinatesBelongToThisGrid(x, y) {
-        return ((x >= this._x) && (x < (this._x + this._width * this._zoom)) && (y >= this._y) && (y < (this._y + this._height * this._zoom)));
+        return x >= this._x && x < this._x + this._width * this._zoom && y >= this._y && y < this._y + this._height * this._zoom;
     }
 
     _getEmptyPlaceClosestTo(x, y, coordinatesAction, reverseHorizontal) {
@@ -379,39 +374,39 @@ var DesktopGrid = class {
         let placeY = Math.floor(y / this._elementHeight);
 
         let cornerInversion = Prefs.get_start_corner();
-        if (reverseHorizontal) {
+        if (reverseHorizontal)
             cornerInversion[0] = !cornerInversion[0];
-        }
+
 
         placeX = DesktopIconsUtil.clamp(placeX, 0, this._maxColumns - 1);
         placeY = DesktopIconsUtil.clamp(placeY, 0, this._maxRows - 1);
-        if (this._isEmptyAt(placeX, placeY) && (coordinatesAction != Enums.StoredCoordinates.ASSIGN)) {
+        if (this._isEmptyAt(placeX, placeY) && coordinatesAction !== Enums.StoredCoordinates.ASSIGN)
             return [placeX, placeY];
-        }
+
         let found = false;
         let resColumn = null;
         let resRow = null;
         let minDistance = Infinity;
         let column, row;
-        for (let tmp_column = 0; tmp_column < this._maxColumns; tmp_column++) {
-            if (cornerInversion[0]) {
-                column = this._maxColumns - tmp_column - 1;
-            } else {
-                column = tmp_column;
-            }
-            for (let tmp_row = 0; tmp_row < this._maxRows; tmp_row++) {
-                if (cornerInversion[1]) {
-                    row = this._maxRows - tmp_row - 1;
-                } else {
-                    row = tmp_row;
-                }
-                if (!this._isEmptyAt(column, row)) {
+        for (let tmpColumn = 0; tmpColumn < this._maxColumns; tmpColumn++) {
+            if (cornerInversion[0])
+                column = this._maxColumns - tmpColumn - 1;
+            else
+                column = tmpColumn;
+
+            for (let tmpRow = 0; tmpRow < this._maxRows; tmpRow++) {
+                if (cornerInversion[1])
+                    row = this._maxRows - tmpRow - 1;
+                else
+                    row = tmpRow;
+
+                if (!this._isEmptyAt(column, row))
                     continue;
-                }
+
 
                 let proposedX = column * this._elementWidth;
                 let proposedY = row * this._elementHeight;
-                if (coordinatesAction == Enums.StoredCoordinates.ASSIGN)
+                if (coordinatesAction === Enums.StoredCoordinates.ASSIGN)
                     return [column, row];
                 let distance = DesktopIconsUtil.distanceBetweenPoints(proposedX, proposedY, x, y);
                 if (distance < minDistance) {
@@ -423,9 +418,9 @@ var DesktopGrid = class {
             }
         }
 
-        if (!found) {
-            throw new Error(`Not enough place at monitor`);
-        }
+        if (!found)
+            throw new Error('Not enough place at monitor');
+
 
         return [resColumn, resRow];
     }
diff --git a/extensions/desktop-icons-ng/desktopManager.js b/extensions/desktop-icons-ng/desktopManager.js
index 2541fde..47b8b83 100644
--- a/extensions/desktop-icons-ng/desktopManager.js
+++ b/extensions/desktop-icons-ng/desktopManager.js
@@ -1,3 +1,4 @@
+/* exported DesktopManager */
 /* DING: Desktop Icons New Generation for GNOME Shell
  *
  * Copyright (C) 2019 Sergio Costas (rastersoft@gmail.com)
@@ -17,7 +18,6 @@
  */
 
 const GLib = imports.gi.GLib;
-const GObject = imports.gi.GObject;
 const Gtk = imports.gi.Gtk;
 const Gdk = imports.gi.Gdk;
 const Gio = imports.gi.Gio;
@@ -40,17 +40,16 @@ const _ = Gettext.gettext;
 
 var DesktopManager = class {
     constructor(desktopList, codePath, asDesktop, primaryIndex) {
-
         DBusUtils.init();
         this._premultiplied = false;
         try {
             for (let f of Prefs.mutterSettings.get_strv('experimental-features')) {
-                if (f == 'scale-monitor-framebuffer') {
+                if (f === 'scale-monitor-framebuffer') {
                     this._premultiplied = true;
                     break;
                 }
             }
-        } catch(e) {
+        } catch (e) {
         }
         this._primaryIndex = primaryIndex;
         this._primaryScreen = desktopList[primaryIndex];
@@ -77,11 +76,11 @@ var DesktopManager = class {
         this._monitorDesktopDir.connect('changed', (obj, file, otherFile, eventType) => this._updateDesktopIfChanged(file, otherFile, eventType));
         this._monitorScriptDir = this._scriptsDir.monitor_directory(Gio.FileMonitorFlags.WATCH_MOVES, null);
         this._monitorScriptDir.set_rate_limit(1000);
-        this._monitorScriptDir.connect('changed', (obj, file, otherFile, eventType) => this._updateScriptFileList());
+        this._monitorScriptDir.connect('changed', (unusedObj, unusedFile, unusedOtherFile, unusedEventType) => this._updateScriptFileList());
         this._showHidden = Prefs.gtkSettings.get_boolean('show-hidden');
         this.showDropPlace = Prefs.desktopSettings.get_boolean('show-drop-place');
         this._settingsId = Prefs.desktopSettings.connect('changed', (obj, key) => {
-            if (key == 'icon-size') {
+            if (key === 'icon-size') {
                 this._removeAllFilesFromGrids();
                 this._createGrids();
             }
@@ -89,28 +88,32 @@ var DesktopManager = class {
             this._updateDesktop();
         });
         Prefs.gtkSettings.connect('changed', (obj, key) => {
-            if (key == 'show-hidden') {
+            if (key === 'show-hidden') {
                 this._showHidden = Prefs.gtkSettings.get_boolean('show-hidden');
                 this._updateDesktop();
             }
         });
         Prefs.nautilusSettings.connect('changed', (obj, key) => {
-            if (key == 'show-image-thumbnails') {
+            if (key === 'show-image-thumbnails')
                 this._updateDesktop();
-            }
+
         });
-        this._gtkIconTheme = Gtk.IconTheme.get_default()
+        this._gtkIconTheme = Gtk.IconTheme.get_default();
         this._gtkIconTheme.connect('changed', () => {
             this._updateDesktop();
         });
         this._volumeMonitor = Gio.VolumeMonitor.get();
-        this._volumeMonitor.connect('mount-added', () => { this._updateDesktop() });
-        this._volumeMonitor.connect('mount-removed', () => { this._updateDesktop() });
+        this._volumeMonitor.connect('mount-added', () => {
+            this._updateDesktop();
+        });
+        this._volumeMonitor.connect('mount-removed', () => {
+            this._updateDesktop();
+        });
 
         this.rubberBand = false;
 
         let cssProvider = new Gtk.CssProvider();
-        cssProvider.load_from_file(Gio.File.new_for_path(GLib.build_filenamev([codePath, "stylesheet.css"])));
+        cssProvider.load_from_file(Gio.File.new_for_path(GLib.build_filenamev([codePath, 'stylesheet.css'])));
         Gtk.StyleContext.add_provider_for_screen(Gdk.Screen.get_default(), cssProvider, 600);
 
         this._configureSelectionColor();
@@ -126,20 +129,20 @@ var DesktopManager = class {
 
         // Check if Nautilus is available
         try {
-            DesktopIconsUtil.trySpawn(null, ["nautilus", "--version"]);
-        } catch(e) {
-            this._errorWindow = new ShowErrorPopup.ShowErrorPopup(_("Nautilus File Manager not found"),
-                                                                  _("The Nautilus File Manager is mandatory to work with Desktop Icons NG."),
-                                                                  null,
-                                                                  true);
+            DesktopIconsUtil.trySpawn(null, ['nautilus', '--version']);
+        } catch (e) {
+            this._errorWindow = new ShowErrorPopup.ShowErrorPopup(_('Nautilus File Manager not found'),
+                _('The Nautilus File Manager is mandatory to work with Desktop Icons NG.'),
+                null,
+                true);
         }
         this._pendingDropFiles = {};
         if (this._asDesktop) {
             this._sigtermID = GLib.unix_signal_add(GLib.PRIORITY_DEFAULT, 15, () => {
                 GLib.source_remove(this._sigtermID);
-                for(let desktop of this._desktops) {
+                for (let desktop of this._desktops)
                     desktop.destroy();
-                }
+
                 Gtk.main_quit();
                 return false;
             });
@@ -147,17 +150,18 @@ var DesktopManager = class {
     }
 
     _createGrids() {
-        for(let desktop of this._desktops) {
+        for (let desktop of this._desktops)
             desktop.destroy();
-        }
+
         this._desktops = [];
-        for(let desktopIndex in this._desktopList) {
+        for (let desktopIndex in this._desktopList) {
             let desktop = this._desktopList[desktopIndex];
-            if (this._asDesktop) {
-                var desktopName = `@!${desktop.x},${desktop.y};BDH`;
-            } else {
-                var desktopName = `DING ${desktopIndex}`;
-            }
+            var desktopName;
+            if (this._asDesktop)
+                desktopName = `@!${desktop.x},${desktop.y};BDH`;
+            else
+                desktopName = `DING ${desktopIndex}`;
+
             this._desktops.push(new DesktopGrid.DesktopGrid(this, desktopName, desktop, this._asDesktop, this._premultiplied));
         }
     }
@@ -187,28 +191,28 @@ var DesktopManager = class {
     }
 
     clearFileCoordinates(fileList, dropCoordinates) {
-        for(let element of fileList) {
+        for (let element of fileList) {
             let file = Gio.File.new_for_uri(element);
             if (!file.is_native() || !file.query_exists(null)) {
-                if (dropCoordinates != null) {
+                if (dropCoordinates !== null)
                     this._pendingDropFiles[file.get_basename()] = dropCoordinates;
-                }
+
                 continue;
             }
             let info = new Gio.FileInfo();
             info.set_attribute_string('metadata::nautilus-icon-position', '');
-            if (dropCoordinates != null) {
+            if (dropCoordinates !== null)
                 info.set_attribute_string('metadata::nautilus-drop-position', `${dropCoordinates[0]},${dropCoordinates[1]}`);
-            }
+
             try {
                 file.set_attributes_from_info(info, Gio.FileQueryInfoFlags.NONE, null);
-            } catch(e) {}
+            } catch (e) {}
         }
     }
 
     doMoveWithDragAndDrop(xOrigin, yOrigin, xDestination, yDestination) {
         // Find the grid where the destination lies
-        for(let desktop of this._desktops) {
+        for (let desktop of this._desktops) {
             let grid = desktop.getGridAt(xDestination, yDestination, true);
             if (grid !== null) {
                 xDestination = grid[0];
@@ -219,11 +223,11 @@ var DesktopManager = class {
         let deltaX = xDestination - xOrigin;
         let deltaY = yDestination - yOrigin;
         let fileItems = [];
-        for(let item of this._fileList) {
+        for (let item of this._fileList) {
             if (item.isSelected) {
                 fileItems.push(item);
                 item.removeFromGrid();
-                let [x, y, a, b, c] = item.getCoordinates();
+                let [x, y, unusedA, unusedB, unusedC] = item.getCoordinates();
                 item.savedCoordinates = [x + deltaX, y + deltaY];
             }
         }
@@ -237,35 +241,35 @@ var DesktopManager = class {
 
     onDragMotion(x, y) {
         if (this.dragItem === null) {
-            for(let desktop of this._desktops) {
+            for (let desktop of this._desktops)
                 desktop.refreshDrag([[0, 0]], x, y);
-            }
+
             return;
         }
         if (this._dragList === null) {
             let itemList = this.getCurrentSelection(false);
-            if (!itemList) {
+            if (!itemList)
                 return;
-            }
-            let [x1, y1, x2, y2, c] = this.dragItem.getCoordinates();
+
+            let [x1, y1, unusedX2, unusedY2, unusedC] = this.dragItem.getCoordinates();
             let oX = x1;
             let oY = y1;
             this._dragList = [];
             for (let item of itemList) {
-                [x1, y1, x2, y2, c] = item.getCoordinates();
+                [x1, y1, unusedX2, unusedY2, unusedC] = item.getCoordinates();
                 this._dragList.push([x1 - oX, y1 - oY]);
             }
         }
-        for(let desktop of this._desktops) {
+        for (let desktop of this._desktops)
             desktop.refreshDrag(this._dragList, x, y);
-        }
+
     }
 
     onDragLeave() {
         this._dragList = null;
-        for(let desktop of this._desktops) {
+        for (let desktop of this._desktops)
             desktop.refreshDrag(null, 0, 0);
-        }
+
     }
 
     onDragEnd() {
@@ -275,43 +279,43 @@ var DesktopManager = class {
     onDragDataReceived(xDestination, yDestination, selection, info) {
         this.onDragLeave();
         let fileList = DesktopIconsUtil.getFilesFromNautilusDnD(selection, info);
-        switch(info) {
+        switch (info) {
         case 0:
-            if (fileList.length != 0) {
-                let [xOrigin, yOrigin, a, b, c] = this.dragItem.getCoordinates();
+            if (fileList.length !== 0) {
+                let [xOrigin, yOrigin, unusedA, unusedB, unusedC] = this.dragItem.getCoordinates();
                 this.doMoveWithDragAndDrop(xOrigin, yOrigin, xDestination, yDestination);
             }
             break;
         case 1:
         case 2:
-            if (fileList.length != 0) {
+            if (fileList.length !== 0) {
                 this.clearFileCoordinates(fileList, [xDestination, yDestination]);
                 let data = Gio.File.new_for_uri(fileList[0]).query_info('id::filesystem', Gio.FileQueryInfoFlags.NONE, null);
-                let id_fs = data.get_attribute_string('id::filesystem');
-                if (this.desktopFsId == id_fs) {
+                let idFs = data.get_attribute_string('id::filesystem');
+                if (this.desktopFsId === idFs) {
                     DBusUtils.NautilusFileOperationsProxy.MoveURIsRemote(
                         fileList,
-                        "file://" + GLib.get_user_special_dir(GLib.UserDirectory.DIRECTORY_DESKTOP),
+                        `file://${GLib.get_user_special_dir(GLib.UserDirectory.DIRECTORY_DESKTOP)}`,
                         (result, error) => {
                             if (error)
-                                throw new Error('Error moving files: ' + error.message);
-                            }
+                                throw new Error(`Error moving files: ${error.message}`);
+                        }
                     );
                 } else {
                     DBusUtils.NautilusFileOperationsProxy.CopyURIsRemote(
                         fileList,
-                        "file://" + GLib.get_user_special_dir(GLib.UserDirectory.DIRECTORY_DESKTOP),
+                        `file://${GLib.get_user_special_dir(GLib.UserDirectory.DIRECTORY_DESKTOP)}`,
                         (result, error) => {
                             if (error)
-                                throw new Error('Error moving files: ' + error.message);
-                            }
+                                throw new Error(`Error moving files: ${error.message}`);
+                        }
                     );
                 }
             }
             break;
         case 3:
-            if (fileList.length != 0 ) {
-                let dropCoordinates = [ xDestination, yDestination ];
+            if (fileList.length !== 0) {
+                let dropCoordinates = [xDestination, yDestination];
                 this.detectURLorText(fileList, dropCoordinates);
             }
             break;
@@ -320,109 +324,109 @@ var DesktopManager = class {
 
     detectURLorText(fileList, dropCoordinates) {
         function isValidURL(str) {
-            var pattern = new RegExp('^(https|http|ftp|rtsp|mms)?:\\/\\/?'+
-            '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|'+
-            '((\\d{1,3}\\.){3}\\d{1,3}))'+
-            '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*'+
-            '(\\?[;&a-z\\d%_.~+=-]*)?'+
-            '(\\#[-a-z\\d_]*)?$','i');
+            var pattern = new RegExp('^(https|http|ftp|rtsp|mms)?:\\/\\/?' +
+            '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' +
+            '((\\d{1,3}\\.){3}\\d{1,3}))' +
+            '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*' +
+            '(\\?[;&a-z\\d%_.~+=-]*)?' +
+            '(\\#[-a-z\\d_]*)?$', 'i');
             return !!pattern.test(str);
         }
         let text = fileList.toString();
         if (isValidURL(text)) {
             this.writeURLlinktoDesktop(text, dropCoordinates);
         } else {
-            let filename = "Dragged Text";
-            let now = Date().valueOf().split(" ").join("").replace( /:/g , '-');
-            filename = filename + "-" + now;
+            let filename = 'Dragged Text';
+            let now = Date().valueOf().split(' ').join('').replace(/:/g, '-');
+            filename = `${filename}-${now}`;
             DesktopIconsUtil.writeTextFileToDesktop(text, filename, dropCoordinates);
         }
     }
 
     writeURLlinktoDesktop(link, dropCoordinates) {
-        let filename = link.split("?")[0];
-        filename = filename.split("//")[1];
-        filename = filename.split("/")[0] ;
-        let now = Date().valueOf().split(" ").join("").replace( /:/g , '-' );
-        filename = filename + "-" + now ;
+        let filename = link.split('?')[0];
+        filename = filename.split('//')[1];
+        filename = filename.split('/')[0];
+        let now = Date().valueOf().split(' ').join('').replace(/:/g, '-');
+        filename = `${filename}-${now}`;
         this.writeHTMLTypeLink(filename, link, dropCoordinates);
     }
 
 
     writeHTMLTypeLink(filename, link, dropCoordinates) {
-        filename = filename + ".html";
-        let body = [ '<html>', '<head>', '<meta http-equiv="refresh" content="0; url=' + link + '" />', '</head>', '<body>', '</body>', '</html>' ];
+        filename += '.html';
+        let body = ['<html>', '<head>', `<meta http-equiv="refresh" content="0; url=${link}" />`, '</head>', '<body>', '</body>', '</html>'];
         body = body.join('\n');
         DesktopIconsUtil.writeTextFileToDesktop(body, filename, dropCoordinates);
     }
 
     fillDragDataGet(info) {
         let fileList = this.getCurrentSelection(false);
-        if (fileList == null) {
+        if (fileList === null)
             return null;
-        }
+
         let atom;
-        switch(info) {
-            case 0:
-                atom = Gdk.atom_intern('x-special/ding-icon-list', false);
-                break;
-            case 1:
-                atom = Gdk.atom_intern('x-special/gnome-icon-list', false);
-                break;
-            case 2:
-                atom = Gdk.atom_intern('text/uri-list', false);
-                break;
-            default:
-                return null;
+        switch (info) {
+        case 0:
+            atom = Gdk.atom_intern('x-special/ding-icon-list', false);
+            break;
+        case 1:
+            atom = Gdk.atom_intern('x-special/gnome-icon-list', false);
+            break;
+        case 2:
+            atom = Gdk.atom_intern('text/uri-list', false);
+            break;
+        default:
+            return null;
         }
-        let data = "";
+        let data = '';
         for (let fileItem of fileList) {
             data += fileItem.uri;
-            if (info == 1) {
+            if (info === 1) {
                 let coordinates = fileItem.getCoordinates();
-                if (coordinates != null) {
-                    data += `\r${coordinates[0]}:${coordinates[1]}:${coordinates[2] - coordinates[0] + 1}:${coordinates[3] - coordinates[1] + 1}`
-                }
+                if (coordinates !== null)
+                    data += `\r${coordinates[0]}:${coordinates[1]}:${coordinates[2] - coordinates[0] + 1}:${coordinates[3] - coordinates[1] + 1}`;
+
             }
             data += '\r\n';
         }
         return [atom, data];
     }
 
-    onPressButton(x, y, event, grid) {
+    onPressButton(x, y, event, unusedGrid) {
 
         this._clickX = Math.floor(x);
         this._clickY = Math.floor(y);
         let button = event.get_button()[1];
         let state = event.get_state()[1];
-        if (button == 1) {
+        if (button === 1) {
             let shiftPressed = !!(state & Gdk.ModifierType.SHIFT_MASK);
             let controlPressed = !!(state & Gdk.ModifierType.CONTROL_MASK);
             if (!shiftPressed && !controlPressed) {
                 // clear selection
-                for(let item of this._fileList) {
+                for (let item of this._fileList)
                     item.unsetSelected();
-                }
+
             }
             this._startRubberband(x, y);
         }
-        if (button == 3) {
+        if (button === 3) {
             let templates = this._templateManager.getTemplates();
-            if (templates.length == 0) {
+            if (templates.length === 0) {
                 this._newDocumentItem.hide();
             } else {
                 let templateMenu = new Gtk.Menu();
                 this._newDocumentItem.set_submenu(templateMenu);
-                for(let template of templates) {
-                    let box = new Gtk.Box({"orientation":Gtk.Orientation.HORIZONTAL, "spacing": 6});
-                    let icon = Gtk.Image.new_from_gicon(template["icon"], Gtk.IconSize.MENU);
-                    let text = new Gtk.Label({"label": template["name"]});
+                for (let template of templates) {
+                    let box = new Gtk.Box({ 'orientation': Gtk.Orientation.HORIZONTAL, 'spacing': 6 });
+                    let icon = Gtk.Image.new_from_gicon(template['icon'], Gtk.IconSize.MENU);
+                    let text = new Gtk.Label({ 'label': template['name'] });
                     box.add(icon);
                     box.add(text);
-                    let entry = new Gtk.MenuItem({"label": template["name"]});
-                    //entry.add(box);
+                    let entry = new Gtk.MenuItem({ 'label': template['name'] });
+                    // entry.add(box);
                     templateMenu.add(entry);
-                    entry.connect("activate", ()=>{
+                    entry.connect('activate', () => {
                         this._newDocument(template);
                     });
                 }
@@ -431,8 +435,8 @@ var DesktopManager = class {
             this._syncUndoRedo();
             let atom = Gdk.Atom.intern('CLIPBOARD', false);
             let clipboard = Gtk.Clipboard.get(atom);
-            clipboard.request_text((clipboard, text) => {
-                let [valid, is_cut, files] = this._parseClipboardText(text);
+            clipboard.request_text((clipboardIn, text) => {
+                let [valid, unusedIsCut, unusedFiles] = this._parseClipboardText(text);
                 this._pasteMenuItem.set_sensitive(valid);
             });
             this._menu.popup_at_pointer(event);
@@ -441,22 +445,22 @@ var DesktopManager = class {
 
     _syncUndoRedo() {
         switch (DBusUtils.NautilusFileOperationsProxy.UndoStatus) {
-            case Enums.UndoStatus.UNDO:
-                this._undoMenuItem.show();
-                this._redoMenuItem.hide();
-                break;
-            case Enums.UndoStatus.REDO:
-                this._undoMenuItem.hide();
-                this._redoMenuItem.show();
-                break;
-            default:
-                this._undoMenuItem.hide();
-                this._redoMenuItem.hide();
-                break;
+        case Enums.UndoStatus.UNDO:
+            this._undoMenuItem.show();
+            this._redoMenuItem.hide();
+            break;
+        case Enums.UndoStatus.REDO:
+            this._undoMenuItem.hide();
+            this._redoMenuItem.show();
+            break;
+        default:
+            this._undoMenuItem.hide();
+            this._redoMenuItem.hide();
+            break;
         }
     }
 
-    _undoStatusChanged(proxy, properties, test) {
+    _undoStatusChanged(proxy, properties, unusedTest) {
         if ('UndoStatus' in properties.deep_unpack())
             this._syncUndoRedo();
     }
@@ -465,7 +469,7 @@ var DesktopManager = class {
         DBusUtils.NautilusFileOperationsProxy.UndoRemote(
             (result, error) => {
                 if (error)
-                    throw new Error('Error performing undo: ' + error.message);
+                    throw new Error(`Error performing undo: ${error.message}`);
             }
         );
     }
@@ -474,64 +478,64 @@ var DesktopManager = class {
         DBusUtils.NautilusFileOperationsProxy.RedoRemote(
             (result, error) => {
                 if (error)
-                    throw new Error('Error performing redo: ' + error.message);
+                    throw new Error(`Error performing redo: ${error.message}`);
             }
         );
     }
 
-    onKeyPress(event, grid) {
+    onKeyPress(event, unusedGrid) {
         let symbol = event.get_keyval()[1];
-        let isCtrl = (event.get_state()[1] & Gdk.ModifierType.CONTROL_MASK) != 0;
-        let isShift = (event.get_state()[1] & Gdk.ModifierType.SHIFT_MASK) != 0;
-        if (isCtrl && isShift && ((symbol == Gdk.KEY_Z) || (symbol == Gdk.KEY_z))) {
+        let isCtrl = (event.get_state()[1] & Gdk.ModifierType.CONTROL_MASK) !== 0;
+        let isShift = (event.get_state()[1] & Gdk.ModifierType.SHIFT_MASK) !== 0;
+        if (isCtrl && isShift && (symbol === Gdk.KEY_Z || symbol === Gdk.KEY_z)) {
             this._doRedo();
             return true;
-        } else if (isCtrl && ((symbol == Gdk.KEY_Z) || (symbol == Gdk.KEY_z))) {
+        } else if (isCtrl && (symbol === Gdk.KEY_Z || symbol === Gdk.KEY_z)) {
             this._doUndo();
             return true;
-        } else if (isCtrl && ((symbol == Gdk.KEY_C) || (symbol == Gdk.KEY_c))) {
+        } else if (isCtrl && (symbol === Gdk.KEY_C || symbol === Gdk.KEY_c)) {
             this.doCopy();
             return true;
-        } else if (isCtrl && ((symbol == Gdk.KEY_X) || (symbol == Gdk.KEY_x))) {
+        } else if (isCtrl && (symbol === Gdk.KEY_X || symbol === Gdk.KEY_x)) {
             this.doCut();
             return true;
-        } else if (isCtrl && ((symbol == Gdk.KEY_V) || (symbol == Gdk.KEY_v))) {
+        } else if (isCtrl && (symbol === Gdk.KEY_V || symbol === Gdk.KEY_v)) {
             this._doPaste();
             return true;
-        } else if (symbol == Gdk.KEY_Return) {
+        } else if (symbol === Gdk.KEY_Return) {
             let selection = this.getCurrentSelection(false);
-            if (selection && (selection.length == 1)) {
+            if (selection && selection.length === 1) {
                 selection[0].doOpen();
                 return true;
             }
-        } else if (symbol == Gdk.KEY_Delete) {
-            if (isShift) {
+        } else if (symbol === Gdk.KEY_Delete) {
+            if (isShift)
                 this.doDeletePermanently();
-            } else {
+            else
                 this.doTrash();
-            }
+
             return true;
-        } else if (symbol == Gdk.KEY_F2) {
+        } else if (symbol === Gdk.KEY_F2) {
             let selection = this.getCurrentSelection(false);
-            if (selection && (selection.length == 1)) {
+            if (selection && selection.length === 1) {
                 // Support renaming other grids file items.
                 this.doRename(selection[0]);
                 return true;
             }
-        } else if (symbol == Gdk.KEY_space) {
+        } else if (symbol === Gdk.KEY_space) {
             let selection = this.getCurrentSelection(false);
             if (selection) {
                 // Support renaming other grids file items.
                 DBusUtils.GnomeNautilusPreviewProxy.ShowFileRemote(selection[0].uri, 0, true);
                 return true;
             }
-        } else if (isCtrl && ((symbol == Gdk.KEY_A) || (symbol == Gdk.KEY_a))) {
+        } else if (isCtrl && (symbol === Gdk.KEY_A || symbol === Gdk.KEY_a)) {
             this._selectAll();
             return true;
-        } else if (symbol == Gdk.KEY_F5) {
+        } else if (symbol === Gdk.KEY_F5) {
             this._updateDesktop();
             return true;
-        } else if (isCtrl && ((symbol == Gdk.KEY_H) || (symbol == Gdk.KEY_h))) {
+        } else if (isCtrl && (symbol === Gdk.KEY_H || symbol === Gdk.KEY_h)) {
             Prefs.gtkSettings.set_boolean('show-hidden', !this._showHidden);
             return true;
         }
@@ -540,47 +544,47 @@ var DesktopManager = class {
 
     _createDesktopBackgroundMenu() {
         this._menu = new Gtk.Menu();
-        let newFolder = new Gtk.MenuItem({label: _("New Folder")});
-        newFolder.connect("activate", () => this._newFolder());
+        let newFolder = new Gtk.MenuItem({ label: _('New Folder') });
+        newFolder.connect('activate', () => this._newFolder());
         this._menu.add(newFolder);
 
-        this._newDocumentItem = new Gtk.MenuItem({label: _("New Document")});
+        this._newDocumentItem = new Gtk.MenuItem({ label: _('New Document') });
         this._menu.add(this._newDocumentItem);
 
         this._menu.add(new Gtk.SeparatorMenuItem());
 
-        this._pasteMenuItem = new Gtk.MenuItem({label: _("Paste")});
-        this._pasteMenuItem.connect("activate", () => this._doPaste());
+        this._pasteMenuItem = new Gtk.MenuItem({ label: _('Paste') });
+        this._pasteMenuItem.connect('activate', () => this._doPaste());
         this._menu.add(this._pasteMenuItem);
 
-        this._undoMenuItem = new Gtk.MenuItem({label: _("Undo")});
-        this._undoMenuItem.connect("activate", () => this._doUndo());
+        this._undoMenuItem = new Gtk.MenuItem({ label: _('Undo') });
+        this._undoMenuItem.connect('activate', () => this._doUndo());
         this._menu.add(this._undoMenuItem);
 
-        this._redoMenuItem = new Gtk.MenuItem({label: _("Redo")});
-        this._redoMenuItem.connect("activate", () => this._doRedo());
+        this._redoMenuItem = new Gtk.MenuItem({ label: _('Redo') });
+        this._redoMenuItem.connect('activate', () => this._doRedo());
         this._menu.add(this._redoMenuItem);
 
         this._menu.add(new Gtk.SeparatorMenuItem());
 
-        let selectAll = new Gtk.MenuItem({label: _("Select all")});
-        selectAll.connect("activate", () => this._selectAll());
+        let selectAll = new Gtk.MenuItem({ label: _('Select all') });
+        selectAll.connect('activate', () => this._selectAll());
         this._menu.add(selectAll);
 
         this._menu.add(new Gtk.SeparatorMenuItem());
 
-        this._showDesktopInFilesMenuItem = new Gtk.MenuItem({label: _("Show Desktop in Files")});
-        this._showDesktopInFilesMenuItem.connect("activate", () => this._onOpenDesktopInFilesClicked());
+        this._showDesktopInFilesMenuItem = new Gtk.MenuItem({ label: _('Show Desktop in Files') });
+        this._showDesktopInFilesMenuItem.connect('activate', () => this._onOpenDesktopInFilesClicked());
         this._menu.add(this._showDesktopInFilesMenuItem);
 
-        this._openTerminalMenuItem = new Gtk.MenuItem({label: _("Open in Terminal")});
-        this._openTerminalMenuItem.connect("activate", () => this._onOpenTerminalClicked());
+        this._openTerminalMenuItem = new Gtk.MenuItem({ label: _('Open in Terminal') });
+        this._openTerminalMenuItem.connect('activate', () => this._onOpenTerminalClicked());
         this._menu.add(this._openTerminalMenuItem);
 
         this._menu.add(new Gtk.SeparatorMenuItem());
 
-        this._changeBackgroundMenuItem = new Gtk.MenuItem({label: _("Change Background…")});
-        this._changeBackgroundMenuItem.connect("activate", () => {
+        this._changeBackgroundMenuItem = new Gtk.MenuItem({ label: _('Change Background…') });
+        this._changeBackgroundMenuItem.connect('activate', () => {
             let desktopFile = Gio.DesktopAppInfo.new('gnome-background-panel.desktop');
             desktopFile.launch([], null);
         });
@@ -588,34 +592,34 @@ var DesktopManager = class {
 
         this._menu.add(new Gtk.SeparatorMenuItem());
 
-        this._displaySettingsMenuItem = new Gtk.MenuItem({label: _("Display Settings")});
-        this._displaySettingsMenuItem.connect("activate", () => {
+        this._displaySettingsMenuItem = new Gtk.MenuItem({ label: _('Display Settings') });
+        this._displaySettingsMenuItem.connect('activate', () => {
             let desktopFile = Gio.DesktopAppInfo.new('gnome-display-panel.desktop');
             desktopFile.launch([], null);
         });
         this._menu.add(this._displaySettingsMenuItem);
 
-        this._settingsMenuItem = new Gtk.MenuItem({label: _("Desktop Icons settings")});
-        this._settingsMenuItem.connect("activate", () => Prefs.showPreferences());
+        this._settingsMenuItem = new Gtk.MenuItem({ label: _('Desktop Icons settings') });
+        this._settingsMenuItem.connect('activate', () => Prefs.showPreferences());
         this._menu.add(this._settingsMenuItem);
         this._menu.show_all();
     }
 
     _createScriptsMenu(Menu) {
-        if ( this._scriptsList.length == 0 ) {
+        if (this._scriptsList.length === 0)
             return;
-        }
+
         this._ScriptSubMenu = new Gtk.Menu();
-        this._ScriptMenuItem = new Gtk.MenuItem({label: _("Scripts")});
+        this._ScriptMenuItem = new Gtk.MenuItem({ label: _('Scripts') });
         this._ScriptMenuItem.set_submenu(this._ScriptSubMenu);
         Menu.add(this._ScriptMenuItem);
         Menu.add(new Gtk.SeparatorMenuItem());
-        for ( let fileItem of this._scriptsList ) {
-            if ( fileItem[0].get_attribute_boolean('access::can-execute') ) {
+        for (let fileItem of this._scriptsList) {
+            if (fileItem[0].get_attribute_boolean('access::can-execute')) {
                 let menuItemName = fileItem[0].get_name();
                 let menuItemPath = fileItem[1].get_path();
-                let menuItem = new Gtk.MenuItem({label: _(`${menuItemName}`)});
-                menuItem.connect("activate", () =>  this._onScriptClicked(menuItemPath));
+                let menuItem = new Gtk.MenuItem({ label: _(`${menuItemName}`) });
+                menuItem.connect('activate', () =>  this._onScriptClicked(menuItemPath));
                 this._ScriptSubMenu.add(menuItem);
             }
         }
@@ -623,10 +627,10 @@ var DesktopManager = class {
     }
 
     _selectAll() {
-        for(let fileItem of this._fileList) {
-            if (fileItem.isAllSelectable) {
+        for (let fileItem of this._fileList) {
+            if (fileItem.isAllSelectable)
                 fileItem.setSelected();
-            }
+
         }
     }
 
@@ -637,7 +641,7 @@ var DesktopManager = class {
                 try {
                     Gio.AppInfo.launch_default_for_uri_finish(result);
                 } catch (e) {
-                   log('Error opening Desktop in Files: ' + e.message);
+                    log(`Error opening Desktop in Files: ${e.message}`);
                 }
             }
         );
@@ -651,25 +655,25 @@ var DesktopManager = class {
     _doPaste() {
         let atom = Gdk.Atom.intern('CLIPBOARD', false);
         let clipboard = Gtk.Clipboard.get(atom);
-        clipboard.request_text((clipboard, text) => {
-            let [valid, is_cut, files] = this._parseClipboardText(text);
-            if (!valid) {
+        clipboard.request_text((clipboardIn, text) => {
+            let [valid, isCut, files] = this._parseClipboardText(text);
+            if (!valid)
                 return;
-            }
+
 
             let desktopDir = this._desktopDir.get_uri();
-            if (is_cut) {
+            if (isCut) {
                 DBusUtils.NautilusFileOperationsProxy.MoveURIsRemote(files, desktopDir,
                     (result, error) => {
                         if (error)
-                            throw new Error('Error moving files: ' + error.message);
+                            throw new Error(`Error moving files: ${error.message}`);
                     }
                 );
             } else {
                 DBusUtils.NautilusFileOperationsProxy.CopyURIsRemote(files, desktopDir,
                     (result, error) => {
                         if (error)
-                            throw new Error('Error copying files: ' + error.message);
+                            throw new Error(`Error copying files: ${error.message}`);
                     }
                 );
             }
@@ -683,12 +687,12 @@ var DesktopManager = class {
         let lines = text.split('\n');
         let [mime, action, ...files] = lines;
 
-        if (mime != 'x-special/nautilus-clipboard')
+        if (mime !== 'x-special/nautilus-clipboard')
             return [false, false, null];
 
-        if (!(['copy', 'cut'].includes(action)))
+        if (!['copy', 'cut'].includes(action))
             return [false, false, null];
-        let isCut = action == 'cut';
+        let isCut = action === 'cut';
 
         /* Last line is empty due to the split */
         if (files.length <= 1)
@@ -703,30 +707,30 @@ var DesktopManager = class {
         if (this.rubberBand) {
             this.mouseX = x;
             this.mouseY = y;
-            for(let grid of this._desktops) {
-                grid.queue_draw();
-            }
+            for (let grid of this._desktops)
+                grid.queueDraw();
+
             let x1 = Math.min(x, this.rubberBandInitX);
             let x2 = Math.max(x, this.rubberBandInitX);
             let y1 = Math.min(y, this.rubberBandInitY);
             let y2 = Math.max(y, this.rubberBandInitY);
-            for(let item of this._fileList) {
+            for (let item of this._fileList)
                 item.updateRubberband(x1, y1, x2, y2);
-            }
+
         }
         return false;
     }
 
-    onReleaseButton(grid) {
+    onReleaseButton(unusedGrid) {
         if (this.rubberBand) {
             this.rubberBand = false;
-            for(let item of this._fileList) {
+            for (let item of this._fileList)
                 item.endRubberband();
-            }
-        }
-        for(let grid of this._desktops) {
-            grid.queue_draw();
+
         }
+        for (let gridMap of this._desktops)
+            gridMap.queueDraw();
+
         return false;
     }
 
@@ -736,21 +740,21 @@ var DesktopManager = class {
         this.mouseX = x;
         this.mouseY = y;
         this.rubberBand = true;
-        for(let item of this._fileList) {
+        for (let item of this._fileList)
             item.startRubberband(x, y);
-        }
+
     }
 
     selected(fileItem, action) {
-        switch(action) {
+        switch (action) {
         case Enums.Selection.ALONE:
             if (!fileItem.isSelected) {
-                for(let item of this._fileList) {
-                    if (item === fileItem) {
+                for (let item of this._fileList) {
+                    if (item === fileItem)
                         item.setSelected();
-                    } else {
+                    else
                         item.unsetSelected();
-                    }
+
                 }
             }
             break;
@@ -759,41 +763,41 @@ var DesktopManager = class {
             break;
         case Enums.Selection.RIGHT_BUTTON:
             if (!fileItem.isSelected) {
-                for(let item of this._fileList) {
-                    if (item === fileItem) {
+                for (let item of this._fileList) {
+                    if (item === fileItem)
                         item.setSelected();
-                    } else {
+                    else
                         item.unsetSelected();
-                    }
+
                 }
             }
             break;
         case Enums.Selection.ENTER:
-            if (this.rubberBand) {
+            if (this.rubberBand)
                 fileItem.setSelected();
-            }
+
             break;
         case Enums.Selection.RELEASE:
-            for(let item of this._fileList) {
-                if (item === fileItem) {
+            for (let item of this._fileList) {
+                if (item === fileItem)
                     item.setSelected();
-                } else {
+                else
                     item.unsetSelected();
-                }
+
             }
             break;
         }
     }
 
     _removeAllFilesFromGrids() {
-        for(let fileItem of this._fileList) {
+        for (let fileItem of this._fileList)
             fileItem.removeFromGrid();
-        }
+
         this._fileList = [];
     }
 
     _updateScriptFileList() {
-        if ( this._scriptsEnumerateCancellable ) {
+        if (this._scriptsEnumerateCancellable) {
             this._scriptFilesChanged = true;
             return;
         }
@@ -806,9 +810,9 @@ var DesktopManager = class {
             return;
         }
         this._scriptFilesChanged = false;
-        if (this._scriptsEnumerateCancellable) {
+        if (this._scriptsEnumerateCancellable)
             this._scriptsEnumerateCancellable.cancel();
-        }
+
         this._scriptsEnumerateCancellable = new Gio.Cancellable();
         this._scriptsDir.enumerate_children_async(
             Enums.DEFAULT_ATTRIBUTES,
@@ -818,23 +822,23 @@ var DesktopManager = class {
             (source, result) => {
                 this._scriptsEnumerateCancellable = null;
                 try {
-                    if ( ! this._scriptFilesChanged ) {
+                    if (!this._scriptFilesChanged) {
                         let fileEnum = source.enumerate_children_finish(result);
                         let scriptsList = [];
                         let info;
-                        while ((info = fileEnum.next_file(null))) {
+                        while ((info = fileEnum.next_file(null)))
                             scriptsList.push([info, fileEnum.get_child(info)]);
-                        }
+
                         this._scriptsList = scriptsList.sort(
-                            (a,b) => {
+                            (a, b) => {
                                 return a[0].get_name().localeCompare(b[0].get_name(),
-                                { sensitivity: 'accent' , numeric: 'true', localeMatcher: 'lookup' });
+                                    { sensitivity: 'accent', numeric: 'true', localeMatcher: 'lookup' });
                             }
                         );
                     } else {
                         this._readScriptFileList();
                     }
-                } catch(e) {
+                } catch (e) {
                 }
             }
         );
@@ -893,7 +897,7 @@ var DesktopManager = class {
                                 continue;
                             }
                             fileList.push(fileItem);
-                            if (fileItem.dropCoordinates == null) {
+                            if (fileItem.dropCoordinates === null) {
                                 let basename = fileItem.file.get_basename();
                                 if (basename in this._pendingDropFiles) {
                                     fileItem.dropCoordinates = this._pendingDropFiles[basename];
@@ -924,7 +928,7 @@ var DesktopManager = class {
                         // But if there was a file change, we must re-read it to be sure that the list is complete
                         this._readFileList();
                     }
-                } catch(e) {
+                } catch (e) {
                     GLib.idle_add(GLib.PRIORITY_LOW, () => {
                         this._readFileList();
                         return GLib.SOURCE_REMOVE;
@@ -938,45 +942,45 @@ var DesktopManager = class {
         let outOfDesktops = [];
         let notAssignedYet = [];
         // First, add those icons that fit in the current desktops
-        for(let fileItem of fileList) {
-            if (fileItem.savedCoordinates == null) {
+        for (let fileItem of fileList) {
+            if (fileItem.savedCoordinates === null) {
                 notAssignedYet.push(fileItem);
                 continue;
             }
-            if (fileItem.dropCoordinates != null) {
+            if (fileItem.dropCoordinates !== null)
                 fileItem.dropCoordinates = null;
-            }
+
             let [itemX, itemY] = fileItem.savedCoordinates;
             let addedToDesktop = false;
-            for(let desktop of this._desktops) {
-                if (desktop.getDistance(itemX, itemY) == 0) {
+            for (let desktop of this._desktops) {
+                if (desktop.getDistance(itemX, itemY) === 0) {
                     addedToDesktop = true;
                     desktop.addFileItemCloseTo(fileItem, itemX, itemY, storeMode);
                     break;
                 }
             }
-            if (!addedToDesktop) {
+            if (!addedToDesktop)
                 outOfDesktops.push(fileItem);
-            }
+
         }
         // Now, assign those icons that are outside the current desktops,
         // but have assigned coordinates
-        for(let fileItem of outOfDesktops) {
+        for (let fileItem of outOfDesktops) {
             let minDistance = -1;
             let [itemX, itemY] = fileItem.savedCoordinates;
             let newDesktop = null;
             for (let desktop of this._desktops) {
                 let distance = desktop.getDistance(itemX, itemY);
-                if (distance == -1) {
+                if (distance === -1)
                     continue;
-                }
-                if ((minDistance == -1) || (distance < minDistance)) {
+
+                if (minDistance === -1 || distance < minDistance) {
                     minDistance = distance;
                     newDesktop = desktop;
                 }
             }
-            if (newDesktop == null) {
-                print("Not enough space to add icons");
+            if (newDesktop === null) {
+                print('Not enough space to add icons');
                 break;
             } else {
                 newDesktop.addFileItemCloseTo(fileItem, itemX, itemY, storeMode);
@@ -985,7 +989,7 @@ var DesktopManager = class {
         // Finally, assign those icons that still don't have coordinates
         for (let fileItem of notAssignedYet) {
             let x, y;
-            if (fileItem.dropCoordinates == null) {
+            if (fileItem.dropCoordinates === null) {
                 x = this._primaryScreen.x;
                 y = this._primaryScreen.y;
                 storeMode = Enums.StoredCoordinates.ASSIGN;
@@ -997,18 +1001,18 @@ var DesktopManager = class {
             // try first in the designated desktop
             let assigned = false;
             for (let desktop of this._desktops) {
-                if (desktop.getDistance(x, y) == 0) {
+                if (desktop.getDistance(x, y) === 0) {
                     desktop.addFileItemCloseTo(fileItem, x, y, storeMode);
                     assigned = true;
                     break;
                 }
             }
-            if (assigned) {
+            if (assigned)
                 continue;
-            }
+
             // if there is no space in the designated desktop, try in another
             for (let desktop of this._desktops) {
-                if (desktop.getDistance(x, y) != -1) {
+                if (desktop.getDistance(x, y) !== -1) {
                     desktop.addFileItemCloseTo(fileItem, x, y, storeMode);
                     break;
                 }
@@ -1018,15 +1022,15 @@ var DesktopManager = class {
 
     _updateWritableByOthers() {
         let info = this._desktopDir.query_info(Gio.FILE_ATTRIBUTE_UNIX_MODE,
-                                               Gio.FileQueryInfoFlags.NONE,
-                                               null);
+            Gio.FileQueryInfoFlags.NONE,
+            null);
         this.unixMode = info.get_attribute_uint32(Gio.FILE_ATTRIBUTE_UNIX_MODE);
-        let writableByOthers = (this.unixMode & Enums.S_IWOTH) != 0;
-        if (writableByOthers != this.writableByOthers) {
+        let writableByOthers = (this.unixMode & Enums.S_IWOTH) !== 0;
+        if (writableByOthers !== this.writableByOthers) {
             this.writableByOthers = writableByOthers;
-            if (this.writableByOthers) {
-                print(`desktop-icons: Desktop is writable by others - will not allow launching any desktop files`);
-            }
+            if (this.writableByOthers)
+                print('desktop-icons: Desktop is writable by others - will not allow launching any desktop files');
+
             return true;
         } else {
             return false;
@@ -1043,43 +1047,43 @@ var DesktopManager = class {
     }
 
     _updateDesktopIfChanged(file, otherFile, eventType) {
-        if (eventType == Gio.FileMonitorEvent.CHANGED) {
+        if (eventType === Gio.FileMonitorEvent.CHANGED) {
             // use only CHANGES_DONE_HINT
             return;
         }
-        if (!this._showHidden && (file.get_basename()[0] == '.')) {
+        if (!this._showHidden && file.get_basename()[0] === '.') {
             // If the file is not visible, we don't need to refresh the desktop
             // Unless it is a hidden file being renamed to visible
-            if (!otherFile || (otherFile.get_basename()[0] == '.')) {
+            if (!otherFile || otherFile.get_basename()[0] === '.')
                 return;
-            }
+
         }
         if (this._readingDesktopFiles) {
             // just notify that the files changed while being read from the disk.
             this._desktopFilesChanged = true;
             return;
         }
-        switch(eventType) {
-            case Gio.FileMonitorEvent.MOVED_IN:
-            case Gio.FileMonitorEvent.MOVED_CREATED:
-                /* Remove the coordinates that could exist to avoid conflicts between
+        switch (eventType) {
+        case Gio.FileMonitorEvent.MOVED_IN:
+        case Gio.FileMonitorEvent.MOVED_CREATED:
+            /* Remove the coordinates that could exist to avoid conflicts between
                    files that are already in the desktop and the new one
                  */
-                try {
-                    let info = new Gio.FileInfo();
-                    info.set_attribute_string('metadata::nautilus-icon-position', '');
-                    file.set_attributes_from_info(info, Gio.FileQueryInfoFlags.NONE, null);
-                } catch (e) {} // can happen if a file is created and deleted very fast
-                break;
-            case Gio.FileMonitorEvent.ATTRIBUTE_CHANGED:
-                /* The desktop is what changed, and not a file inside it */
-                if (file.get_uri() == this._desktopDir.get_uri()) {
-                    if (this._updateWritableByOthers()) {
-                        this._readFileList();
-                    }
-                    return;
-                }
-                break;
+            try {
+                let info = new Gio.FileInfo();
+                info.set_attribute_string('metadata::nautilus-icon-position', '');
+                file.set_attributes_from_info(info, Gio.FileQueryInfoFlags.NONE, null);
+            } catch (e) {} // can happen if a file is created and deleted very fast
+            break;
+        case Gio.FileMonitorEvent.ATTRIBUTE_CHANGED:
+            /* The desktop is what changed, and not a file inside it */
+            if (file.get_uri() === this._desktopDir.get_uri()) {
+                if (this._updateWritableByOthers())
+                    this._readFileList();
+
+                return;
+            }
+            break;
         }
         this._readFileList();
     }
@@ -1089,10 +1093,10 @@ var DesktopManager = class {
         if (selection) {
             let atom = Gdk.Atom.intern('CLIPBOARD', false);
             let clipboard = Gtk.Clipboard.get(atom);
-            let text = 'x-special/nautilus-clipboard\n' + (isCopy ? 'copy' : 'cut') + '\n';
-            for (let item of selection) {
-                text += item + '\n';
-            }
+            let text = `x-special/nautilus-clipboard\n${isCopy ? 'copy' : 'cut'}\n`;
+            for (let item of selection)
+                text += `${item}\n`;
+
             clipboard.set_text(text, -1);
         }
     }
@@ -1111,7 +1115,7 @@ var DesktopManager = class {
             DBusUtils.NautilusFileOperationsProxy.TrashFilesRemote(selection,
                 (source, error) => {
                     if (error)
-                        throw new Error('Error trashing files on the desktop: ' + error.message);
+                        throw new Error(`Error trashing files on the desktop: ${error.message}`);
                 }
             );
         }
@@ -1122,9 +1126,9 @@ var DesktopManager = class {
             this._deletingFilesRecursively = false;
             try {
                 source.delete_finish(res);
-            } catch(e) {
+            } catch (e) {
                 let windowError = new ShowErrorPopup.ShowErrorPopup(
-                    _("Error while deleting files"),
+                    _('Error while deleting files'),
                     e.message,
                     null,
                     false);
@@ -1138,12 +1142,12 @@ var DesktopManager = class {
     }
 
     _deleteRecursively() {
-        if (this._deletingFilesRecursively || (this._toDelete.length == 0)) {
+        if (this._deletingFilesRecursively || this._toDelete.length === 0)
             return;
-        }
+
         this._deletingFilesRecursively = true;
         let nextFileToDelete = this._toDelete.shift();
-        if (nextFileToDelete.query_file_type(Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null) == Gio.FileType.DIRECTORY) {
+        if (nextFileToDelete.query_file_type(Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS, null) === Gio.FileType.DIRECTORY) {
             nextFileToDelete.enumerate_children_async(
                 Enums.DEFAULT_ATTRIBUTES,
                 Gio.FileQueryInfoFlags.NOFOLLOW_SYMLINKS,
@@ -1170,16 +1174,16 @@ var DesktopManager = class {
                             this._deletingFilesRecursively = false;
                             this._deleteRecursively();
                         }
-                    } catch(e) {
+                    } catch (e) {
                         let windowError = new ShowErrorPopup.ShowErrorPopup(
-                            _("Error while deleting files"),
+                            _('Error while deleting files'),
                             e.message,
                             null,
                             false);
                         windowError.run();
                         this._toDelete = [];
                         this._deletingFilesRecursively = false;
-                        return;
+
                     }
                 });
         } else {
@@ -1188,87 +1192,87 @@ var DesktopManager = class {
     }
 
     doDeletePermanently() {
-        let filelist = "";
-        for(let fileItem of this._fileList) {
+        let filelist = '';
+        for (let fileItem of this._fileList) {
             if (fileItem.isSelected) {
-                if (filelist != "") {
-                    filelist += ", "
-                }
+                if (filelist !== '')
+                    filelist += ', ';
+
                 filelist += `"${fileItem.fileName}"`;
             }
         }
         let renameWindow = new AskConfirmPopup.AskConfirmPopup(
-            _("Are you sure you want to permanently delete these items?"),
-            `${_("If you delete an item, it will be permanently lost.")}\n\n${filelist}`,
+            _('Are you sure you want to permanently delete these items?'),
+            `${_('If you delete an item, it will be permanently lost.')}\n\n${filelist}`,
             null);
         if (renameWindow.run()) {
             this._permanentDeleteError = false;
-            for(let fileItem of this._fileList) {
-                if (fileItem.isSelected) {
+            for (let fileItem of this._fileList) {
+                if (fileItem.isSelected)
                     this._toDelete.push(fileItem.file);
-                }
+
             }
             this._deleteRecursively();
         }
     }
 
     doEmptyTrash() {
-        DBusUtils.NautilusFileOperationsProxy.EmptyTrashRemote( (source, error) => {
+        DBusUtils.NautilusFileOperationsProxy.EmptyTrashRemote((source, error) => {
             if (error)
-                throw new Error('Error trashing files on the desktop: ' + error.message);
+                throw new Error(`Error trashing files on the desktop: ${error.message}`);
         });
     }
 
     checkIfSpecialFilesAreSelected() {
-        for(let item of this._fileList) {
-            if (item.isSelected && item.isSpecial) {
+        for (let item of this._fileList) {
+            if (item.isSelected && item.isSpecial)
                 return true;
-            }
+
         }
         return false;
     }
 
     checkIfDirectoryIsSelected() {
-        for(let item of this._fileList) {
-            if (item.isSelected && item.isDirectory) {
+        for (let item of this._fileList) {
+            if (item.isSelected && item.isDirectory)
                 return true;
-            }
+
         }
         return false;
     }
 
     getCurrentSelection(getUri) {
         let listToTrash = [];
-        for(let fileItem of this._fileList) {
+        for (let fileItem of this._fileList) {
             if (fileItem.isSelected) {
-                if (getUri) {
+                if (getUri)
                     listToTrash.push(fileItem.file.get_uri());
-                } else {
+                else
                     listToTrash.push(fileItem);
-                }
+
             }
         }
-        if (listToTrash.length != 0) {
+        if (listToTrash.length !== 0)
             return listToTrash;
-        } else {
+        else
             return null;
-        }
+
     }
 
     getNumberOfSelectedItems() {
         let count = 0;
-        for(let item of this._fileList) {
-            if (item.isSelected) {
+        for (let item of this._fileList) {
+            if (item.isSelected)
                 count++;
-            }
+
         }
         return count;
     }
 
     doRename(fileItem) {
-        for(let fileItem2 of this._fileList) {
+        for (let fileItem2 of this._fileList)
             fileItem2.unsetSelected();
-        }
+
         this._renameWindow = new AskRenamePopup.AskRenamePopup(fileItem);
     }
 
@@ -1277,18 +1281,18 @@ var DesktopManager = class {
         if (fileItems) {
             let mimetype = Gio.content_type_guess(fileItems[0].fileName, null)[0];
             let chooser = Gtk.AppChooserDialog.new_for_content_type(null,
-                                                                    Gtk.DialogFlags.MODAL + Gtk.DialogFlags.USE_HEADER_BAR,
-                                                                    mimetype);
+                Gtk.DialogFlags.MODAL + Gtk.DialogFlags.USE_HEADER_BAR,
+                mimetype);
             chooser.show_all();
             let retval = chooser.run();
             chooser.hide();
-            if (retval == Gtk.ResponseType.OK) {
+            if (retval === Gtk.ResponseType.OK) {
                 let appInfo = chooser.get_app_info();
                 if (appInfo) {
                     let fileList = [];
-                    for (let item of fileItems) {
+                    for (let item of fileItems)
                         fileList.push(item.file);
-                    }
+
                     appInfo.launch(fileList, null);
                 }
             }
@@ -1299,15 +1303,15 @@ var DesktopManager = class {
     _newFolder(position) {
         let X;
         let Y;
-        if (position) {
+        if (position)
             [X, Y] = position;
-        } else {
+        else
             [X, Y] = [this._clickX, this._clickY];
-        }
-        for(let fileItem of this._fileList) {
+
+        for (let fileItem of this._fileList)
             fileItem.unsetSelected();
-        }
-        let newFolderWindow = new AskNamePopup.AskNamePopup(null, _("New folder"), null);
+
+        let newFolderWindow = new AskNamePopup.AskNamePopup(null, _('New folder'), null);
         let newName = newFolderWindow.run();
         if (newName) {
             let dir = DesktopIconsUtil.getDesktopDir().get_child(newName);
@@ -1317,37 +1321,37 @@ var DesktopManager = class {
                 info.set_attribute_string('metadata::nautilus-drop-position', `${X},${Y}`);
                 info.set_attribute_string('metadata::nautilus-icon-position', '');
                 dir.set_attributes_from_info(info, Gio.FileQueryInfoFlags.NONE, null);
-                if (position) {
+                if (position)
                     return dir.get_uri();
-                }
-            } catch(e) {
+
+            } catch (e) {
                 print(`Failed to create folder ${e.message}`);
             }
         }
     }
 
     _newDocument(template) {
-        let file = this._templateManager.getTemplateFile(template["file"]);
-        if (file == null) {
+        let file = this._templateManager.getTemplateFile(template['file']);
+        if (file === null)
             return;
-        }
+
         let counter = 0;
-        let finalName = `${template["name"]}${template["extension"]}`;
+        let finalName = `${template['name']}${template['extension']}`;
         let destination;
         do {
-            if (counter != 0) {
-                finalName = `${template["name"]} ${counter}${template["extension"]}`
-            }
+            if (counter !== 0)
+                finalName = `${template['name']} ${counter}${template['extension']}`;
+
             destination = Gio.File.new_for_path(GLib.build_filenamev([GLib.get_user_special_dir(GLib.UserDirectory.DIRECTORY_DESKTOP), finalName]));
             counter++;
-        } while(destination.query_exists(null));
+        } while (destination.query_exists(null));
         try {
             file.copy(destination, Gio.FileCopyFlags.NONE, null, null);
             let info = new Gio.FileInfo();
             info.set_attribute_string('metadata::nautilus-drop-position', `${this._clickX},${this._clickY}`);
             info.set_attribute_string('metadata::nautilus-icon-position', '');
             destination.set_attributes_from_info(info, Gio.FileQueryInfoFlags.NONE, null);
-        } catch(e) {
+        } catch (e) {
             print(`Failed to create template ${e.message}`);
         }
     }
@@ -1355,16 +1359,16 @@ var DesktopManager = class {
     _onScriptClicked(menuItemPath) {
         let pathList = [];
         let uriList = [];
-        for ( let item of this._fileList ) {
-            if ( item.isSelected &&  ! item.isSpecial ) {
-                pathList.push(`'` + item.file.get_path() + `\n'`);
-                uriList.push(`'` + item.file.get_uri() + `\n'`);
+        for (let item of this._fileList) {
+            if (item.isSelected &&  !item.isSpecial) {
+                pathList.push(`'${item.file.get_path()}\n'`);
+                uriList.push(`'${item.file.get_uri()}\n'`);
             }
         }
-        pathList = pathList.join("");
-        uriList = uriList.join("");
-        let deskTop = `'` + DesktopIconsUtil.getDesktopDir().get_uri() + `'`;
-        let execline = `/bin/bash -c "`;
+        pathList = pathList.join('');
+        uriList = uriList.join('');
+        let deskTop = `'${DesktopIconsUtil.getDesktopDir().get_uri()}'`;
+        let execline = '/bin/bash -c "';
         execline += `NAUTILUS_SCRIPT_SELECTED_FILE_PATHS=${pathList} `;
         execline += `NAUTILUS_SCRIPT_SELECTED_URIS=${uriList} `;
         execline += `NAUTILUS_SCRIPT_CURRENT_URI=${deskTop} `;
@@ -1374,26 +1378,26 @@ var DesktopManager = class {
 
     doMultiOpen() {
         let openFileListItems = this.getCurrentSelection();
-        for ( let fileItem of openFileListItems ) {
+        for (let fileItem of openFileListItems) {
             fileItem.unsetSelected();
-            fileItem.doOpen() ;
+            fileItem.doOpen();
         }
     }
 
     mailFilesFromSelection() {
         if (this.checkIfDirectoryIsSelected()) {
-            let WindowError = new ShowErrorPopup.ShowErrorPopup(_("Can not email a Directory"),
-                                                                _("Selection includes a Directory, compress the directory to a file first."),
-                                                                null,
-                                                                false);
+            let WindowError = new ShowErrorPopup.ShowErrorPopup(_('Can not email a Directory'),
+                _('Selection includes a Directory, compress the directory to a file first.'),
+                null,
+                false);
             WindowError.run();
             return;
         }
         let xdgEmailCommand = [];
-        xdgEmailCommand.push('xdg-email')
+        xdgEmailCommand.push('xdg-email');
         for (let fileItem of this._fileList) {
             if (fileItem.isSelected) {
-                fileItem.unsetSelected;
+                fileItem.unsetSelected();
                 xdgEmailCommand.push('--attach');
                 xdgEmailCommand.push(fileItem.file.get_path());
             }
@@ -1403,16 +1407,16 @@ var DesktopManager = class {
 
     doNewFolderFromSelection(position) {
         let newFolderFileItems = this.getCurrentSelection(true);
-        for (let fileItem of this._fileList) {
-           fileItem.unsetSelected();
-        }
+        for (let fileItem of this._fileList)
+            fileItem.unsetSelected();
+
         let newFolder = this._newFolder(position);
         if (newFolder) {
             DBusUtils.NautilusFileOperationsProxy.MoveURIsRemote(newFolderFileItems, newFolder,
                 (result, error) => {
-                    if (error) {
-                        throw new Error('Error moving files: ' + error.message);
-                    }
+                    if (error)
+                        throw new Error(`Error moving files: ${error.message}`);
+
                 }
             );
         }
@@ -1420,18 +1424,18 @@ var DesktopManager = class {
 
     doCompressFilesFromSelection() {
         let compressFileItems = this.getCurrentSelection(true);
-        for (let fileItem of this._fileList) {
+        for (let fileItem of this._fileList)
             fileItem.unsetSelected();
-        }
+
         let desktopFolder = this._desktopDir.get_uri();
         if (desktopFolder) {
             DBusUtils.GnomeArchiveManagerProxy.CompressRemote(compressFileItems, desktopFolder, true,
                 (result, error) => {
-                    if (error) {
-                        throw new Error('Error compressing files: ' + error.message);
-                    }
+                    if (error)
+                        throw new Error(`Error compressing files: ${error.message}`);
+
                 }
             );
         }
     }
-}
+};
diff --git a/extensions/desktop-icons-ng/ding.js b/extensions/desktop-icons-ng/ding.js
index f05ab73..6ad6e57 100755
--- a/extensions/desktop-icons-ng/ding.js
+++ b/extensions/desktop-icons-ng/ding.js
@@ -20,8 +20,6 @@
 
 imports.gi.versions.Gtk = '3.0';
 const Gtk = imports.gi.Gtk;
-const Gio = imports.gi.Gio;
-const GLib = imports.gi.GLib;
 
 let desktops = [];
 let lastCommand = null;
@@ -31,9 +29,9 @@ let asDesktop = false;
 let primaryIndex = 0;
 let localeDirectory = '.';
 
-for(let arg of ARGV) {
-    if (lastCommand == null) {
-        switch(arg) {
+for (let arg of ARGV) {
+    if (lastCommand === null) {
+        switch (arg) {
         case '-E':
             // run it as a true desktop (transparent window and so on)
             asDesktop = true;
@@ -51,16 +49,16 @@ for(let arg of ARGV) {
         }
         continue;
     }
-    if (errorFound) {
+    if (errorFound)
         break;
-    }
-    switch(lastCommand) {
+
+    switch (lastCommand) {
     case '-P':
         codePath = arg;
         break;
     case '-D':
-        let data = arg.split(":");
-        desktops.push({x:parseInt(data[0]), y:parseInt(data[1]), width:parseInt(data[2]), height:parseInt(data[3]), zoom:parseFloat(data[4])});
+        var data = arg.split(':');
+        desktops.push({ x: parseInt(data[0]), y: parseInt(data[1]), width: parseInt(data[2]), height: parseInt(data[3]), zoom: parseFloat(data[4]) });
         break;
     case '-M':
         primaryIndex = parseInt(arg);
@@ -72,11 +70,11 @@ for(let arg of ARGV) {
     lastCommand = null;
 }
 
-if (desktops.length == 0) {
+if (desktops.length === 0) {
     /* if no desktop list is provided, like when launching the program in stand-alone mode,
      * configure a 1280x720 desktop
      */
-    desktops.push({x:0, y:0, width: 1280, height: 720, zoom: 1});
+    desktops.push({ x: 0, y: 0, width: 1280, height: 720, zoom: 1 });
 }
 
 // this allows to import files from the current folder
@@ -86,18 +84,19 @@ imports.searchPath.unshift(codePath);
 const Prefs = imports.preferences;
 const Gettext = imports.gettext;
 
-Gettext.bindtextdomain("ding", localeDirectory);
+Gettext.bindtextdomain('ding', localeDirectory);
 
 const DesktopManager = imports.desktopManager;
 
 if (!errorFound) {
     Gtk.init(null);
     Prefs.init(codePath);
-    var desktopManager = new DesktopManager.DesktopManager(desktops, codePath, asDesktop, primaryIndex);
+
+    var unusedDesktopManager = new DesktopManager.DesktopManager(desktops, codePath, asDesktop, primaryIndex);
     Gtk.main();
     // return value
-    0;
+    // 0;
 } else {
     // return value
-    1;
+    // 1;
 }
diff --git a/extensions/desktop-icons-ng/extension.js b/extensions/desktop-icons-ng/extension.js
index a7688b4..52de907 100644
--- a/extensions/desktop-icons-ng/extension.js
+++ b/extensions/desktop-icons-ng/extension.js
@@ -1,3 +1,4 @@
+/* exported init enable disable */
 /* DING: Desktop Icons New Generation for GNOME Shell
  *
  * Copyright (C) 2019 Sergio Costas (rastersoft@gmail.com)
@@ -19,13 +20,12 @@
 const GLib = imports.gi.GLib;
 const Gio = imports.gi.Gio;
 const Meta = imports.gi.Meta;
-const St = imports.gi.St;
 
 const Main = imports.ui.main;
 
 const ExtensionUtils = imports.misc.extensionUtils;
 const Config = imports.misc.config;
-const Mainloop = imports.mainloop;
+const Mainloop = imports.mainloop; /* eslint-disable-line no-restricted-properties */
 
 const Me = ExtensionUtils.getCurrentExtension();
 const EmulateX11 = Me.imports.emulateX11WindowType;
@@ -39,6 +39,7 @@ function init() {
     data.currentProcess = null;
     data.reloadTime = 100;
     data.x11Manager = new EmulateX11.EmulateX11WindowType();
+
     // Ensure that there aren't "rogue" processes
     doKillAllOldDesktopProcesses();
 }
@@ -50,14 +51,18 @@ function init() {
 function enable() {
     // If the desktop is still starting up, we wait until it is ready
     if (Main.layoutManager._startingUp) {
-        data.startupPreparedId = Main.layoutManager.connect('startup-complete', () => { innerEnable(true); });
+        data.startupPreparedId = Main.layoutManager.connect('startup-complete', () => {
+            innerEnable(true);
+        });
     } else {
         innerEnable(false);
     }
+
 }
 
 /**
  * The true code that configures everything and launches the desktop program
+ * @param {int} removeId no idea yet
  */
 function innerEnable(removeId) {
 
@@ -67,9 +72,9 @@ function innerEnable(removeId) {
     }
 
     // under X11 we don't need to cheat, so only do all this under wayland
-    if (Meta.is_wayland_compositor()) {
+    if (Meta.is_wayland_compositor())
         data.x11Manager.enable();
-    }
+
 
     /*
      * If the desktop geometry changes (because a new monitor has been added, for example),
@@ -97,9 +102,9 @@ function innerEnable(removeId) {
     });
 
     data.isEnabled = true;
-    if (data.launchDesktopId) {
+    if (data.launchDesktopId)
         GLib.source_remove(data.launchDesktopId);
-    }
+
     launchDesktop();
 }
 
@@ -113,35 +118,35 @@ function disable() {
     data.x11Manager.disable();
 
     // disconnect signals only if connected
-    if (data.startupPreparedId) {
+    if (data.startupPreparedId)
         Main.layoutManager.disconnect(data.startupPreparedId);
-    }
-    if (data.monitorsChangedId) {
+
+    if (data.monitorsChangedId)
         Main.layoutManager.disconnect(data.monitorsChangedId);
-    }
-    if (data.workareasChangedId) {
+
+    if (data.workareasChangedId)
         global.display.disconnect(data.workareasChangedId);
-    }
-    if (data.sizeChangedId) {
+
+    if (data.sizeChangedId)
         global.window_manager.disconnect(data.sizeChangedId);
-    }
+
 }
 
 function reloadIfSizesChanged() {
-    if (data.desktopCoordinates.length != Main.layoutManager.monitors.length) {
+    if (data.desktopCoordinates.length !== Main.layoutManager.monitors.length) {
         killCurrentProcess();
         return;
     }
-    for(let monitorIndex = 0; monitorIndex < Main.layoutManager.monitors.length; monitorIndex++) {
+    for (let monitorIndex = 0; monitorIndex < Main.layoutManager.monitors.length; monitorIndex++) {
         let ws = global.workspace_manager.get_workspace_by_index(0);
         let area = ws.get_work_area_for_monitor(monitorIndex);
         let area2 = data.desktopCoordinates[monitorIndex];
         let scale = Main.layoutManager.monitors[monitorIndex].geometry_scale;
-        if ((area.x != area2.x) ||
-            (area.y != area2.y) ||
-            (area.width != area2.width) ||
-            (area.height != area2.height) ||
-            (scale != area2.zoom)) {
+        if (area.x !== area2.x ||
+            area.y !== area2.y ||
+            area.width !== area2.width ||
+            area.height !== area2.height ||
+            scale !== area2.zoom) {
             killCurrentProcess();
             return;
         }
@@ -166,9 +171,9 @@ function killCurrentProcess() {
     }
 
     // kill the desktop program. It will be reloaded automatically.
-    if (data.currentProcess && data.currentProcess.subprocess) {
+    if (data.currentProcess && data.currentProcess.subprocess)
         data.currentProcess.subprocess.send_signal(15);
-    }
+
 }
 
 /**
@@ -182,35 +187,35 @@ function killCurrentProcess() {
 function doKillAllOldDesktopProcesses() {
 
     let procFolder = Gio.File.new_for_path('/proc');
-    if (!procFolder.query_exists(null)) {
+    if (!procFolder.query_exists(null))
         return;
-    }
+
 
     let fileEnum = procFolder.enumerate_children('standard::*', Gio.FileQueryInfoFlags.NONE, null);
     let info;
     while ((info = fileEnum.next_file(null))) {
         let filename = info.get_name();
-        if (!filename) {
+        if (!filename)
             break;
-        }
+
         let processPath = GLib.build_filenamev(['/proc', filename, 'cmdline']);
         let processUser = Gio.File.new_for_path(processPath);
-        if (!processUser.query_exists(null)) {
+        if (!processUser.query_exists(null))
             continue;
-        }
-        let [data, etag] = processUser.load_bytes(null);
+
+        let [dataV, unusedEtag] = processUser.load_bytes(null);
         let contents = '';
-        data = data.get_data();
-        for (let i = 0; i < data.length; i++) {
-            if (data[i] < 32) {
+        dataV = dataV.get_data();
+        for (let i = 0; i < dataV.length; i++) {
+            if (dataV[i] < 32)
                 contents += ' ';
-            } else {
-                contents += String.fromCharCode(data[i]);
-            }
+            else
+                contents += String.fromCharCode(dataV[i]);
+
         }
-        let path = 'gjs ' + GLib.build_filenamev([ExtensionUtils.getCurrentExtension().path, 'ding.js']);
+        let path = `gjs ${GLib.build_filenamev([ExtensionUtils.getCurrentExtension().path, 'ding.js'])}`;
         if (contents.startsWith(path)) {
-            let proc = new Gio.Subprocess({argv: ['/bin/kill', filename]});
+            let proc = new Gio.Subprocess({ argv: ['/bin/kill', filename] });
             proc.init(null);
             proc.wait(null);
         }
@@ -240,34 +245,34 @@ function launchDesktop() {
     argv.push('-M');
     argv.push(`${Main.layoutManager.primaryIndex}`);
 
-    for(let monitorIndex = 0; monitorIndex < Main.layoutManager.monitors.length; monitorIndex++) {
+    for (let monitorIndex = 0; monitorIndex < Main.layoutManager.monitors.length; monitorIndex++) {
         let ws = global.workspace_manager.get_workspace_by_index(0);
         let area = ws.get_work_area_for_monitor(monitorIndex);
         // send the working area of each monitor in the desktop
         argv.push('-D');
         let scale = Main.layoutManager.monitors[monitorIndex].geometry_scale;
         argv.push(`${area.x}:${area.y}:${area.width}:${area.height}:${scale}`);
-        data.desktopCoordinates.push({x: area.x, y: area.y, width: area.width, height: area.height, zoom: scale})
-        if (first || (area.x < data.minx)) {
+        data.desktopCoordinates.push({ x: area.x, y: area.y, width: area.width, height: area.height, zoom: scale });
+        if (first || area.x < data.minx)
             data.minx = area.x;
-        }
-        if (first || (area.y < data.miny)) {
+
+        if (first || area.y < data.miny)
             data.miny = area.y;
-        }
-        if (first || ((area.x + area.width) > data.maxx)) {
+
+        if (first || area.x + area.width > data.maxx)
             data.maxx = area.x + area.width;
-        }
-        if (first || ((area.y + area.height) > data.maxy)) {
+
+        if (first || area.y + area.height > data.maxy)
             data.maxy = area.y + area.height;
-        }
+
         first = false;
     }
 
     argv.push('-L');
     argv.push(Config.LOCALEDIR);
 
-    data.currentProcess = new LaunchSubprocess(0, "DING", "-U");
-    data.currentProcess.set_cwd(GLib.get_home_dir());
+    data.currentProcess = new LaunchSubprocess(0, 'DING', '-U');
+    data.currentProcess.setCwd(GLib.get_home_dir());
     data.currentProcess.spawnv(argv);
     data.x11Manager.set_wayland_client(data.currentProcess);
 
@@ -277,24 +282,24 @@ function launchDesktop() {
      * too fast if it has a bug that makes it fail continuously, avoiding filling the journal too fast.
      */
     data.currentProcess.subprocess.wait_async(null, (obj, res) => {
-        let b = obj.wait_finish(res);
-        if (!data.currentProcess || obj !== data.currentProcess.subprocess) {
+        let unusedB = obj.wait_finish(res);
+        if (!data.currentProcess || obj !== data.currentProcess.subprocess)
             return;
-        }
+
         if (obj.get_if_exited()) {
             let retval = obj.get_exit_status();
-            if (retval != 0) {
+            if (retval !== 0)
                 data.reloadTime = 1000;
-            }
+
         } else {
             data.reloadTime = 1000;
         }
         data.currentProcess = null;
         data.x11Manager.set_wayland_client(null);
         if (data.isEnabled) {
-            if (data.launchDesktopId) {
+            if (data.launchDesktopId)
                 GLib.source_remove(data.launchDesktopId);
-            }
+
             data.launchDesktopId = Mainloop.timeout_add(data.reloadTime, () => {
                 data.launchDesktopId = 0;
                 launchDesktop();
@@ -311,21 +316,21 @@ function launchDesktop() {
  * It is compatible with https://gitlab.gnome.org/GNOME/mutter/merge_requests/754 to simplify the code
  *
  * @param {int} flags Flags for the SubprocessLauncher class
- * @param {string} process_id An string id for the debug output
- * @param {string} cmd_parameter A command line parameter to pass when running. It will be passed only under Wayland,
+ * @param {string} processID An string id for the debug output
+ * @param {string} cmdPrameter A command line parameter to pass when running. It will be passed only under Wayland,
  *                          so, if this parameter isn't passed, the app can assume that it is running under X11.
  */
 var LaunchSubprocess = class {
 
-    constructor(flags, process_id, cmd_parameter) {
-        this._process_id = process_id;
-        this._cmd_parameter = cmd_parameter;
+    constructor(flags, processID, cmdPrameter) {
+        this._process_id = processID;
+        this._cmd_parameter = cmdPrameter;
         this._UUID = null;
         this._flags = flags | Gio.SubprocessFlags.STDOUT_PIPE | Gio.SubprocessFlags.STDERR_MERGE;
-        this._launcher = new Gio.SubprocessLauncher({flags: this._flags});
+        this._launcher = new Gio.SubprocessLauncher({ flags: this._flags });
         if (Meta.is_wayland_compositor()) {
             this._waylandClient = Meta.WaylandClient.new(this._launcher);
-            if (Config.PACKAGE_VERSION == '3.38.0') {
+            if (Config.PACKAGE_VERSION === '3.38.0') {
                 // workaround for bug in 3.38.0
                 this._launcher.ref();
             }
@@ -335,29 +340,29 @@ var LaunchSubprocess = class {
     }
 
     spawnv(argv) {
-        if (Meta.is_wayland_compositor()) {
+        if (Meta.is_wayland_compositor())
             this.subprocess = this._waylandClient.spawnv(global.display, argv);
-        } else {
+        else
             this.subprocess = this._launcher.spawnv(argv);
-        }
+
         /* This is for GLib 2.68
         if (this._launcher.close) {
             this._launcher.close();
         }*/
         this._launcher = null;
         if (this.subprocess) {
-                /*
+            /*
                  * It reads STDOUT and STDERR and sends it to the journal using global.log(). This allows to
                  * have any error from the desktop app in the same journal than other extensions. Every line from
                  * the desktop program is prepended with the "process_id" parameter sent in the constructor.
                  */
             this.subprocess.communicate_utf8_async(null, null, (object, res) => {
                 try {
-                    let [d, stdout, stderr] = object.communicate_utf8_finish(res);
-                    if (stdout.length != 0) {
+                    let [unused, stdout, unusedStderr] = object.communicate_utf8_finish(res);
+                    if (stdout.length !== 0)
                         global.log(`${this._process_id}: ${stdout}`);
-                    }
-                } catch(e) {
+
+                } catch (e) {
                     global.log(`${this._process_id}_Error: ${e}`);
                 }
             });
@@ -369,37 +374,38 @@ var LaunchSubprocess = class {
         return this.subprocess;
     }
 
-    set_cwd(cwd) {
-        this._launcher.set_cwd (cwd);
+    setCwd(cwd) {
+        this._launcher.set_cwd(cwd);
     }
 
     /**
      * Queries whether the passed window belongs to the launched subprocess or not.
      * @param {MetaWindow} window The window to check.
+     * @return {bool} no idea yet
      */
-    query_window_belongs_to (window) {
-        if (!Meta.is_wayland_compositor()) {
+    queryWindowBelongsTo(window) {
+        if (!Meta.is_wayland_compositor())
             return false;
-        }
-        if (!this.process_running) {
+
+        if (!this.process_running)
             return false;
-        }
+
         try {
-            return (this._waylandClient.owns_window(window));
-        } catch(e) {
+            return this._waylandClient.owns_window(window);
+        } catch (e) {
             return false;
         }
     }
 
-    show_in_window_list(window) {
-        if (Meta.is_wayland_compositor() && this.process_running) {
+    showInWindowList(window) {
+        if (Meta.is_wayland_compositor() && this.process_running)
             this._waylandClient.show_in_window_list(window);
-        }
+
     }
 
-    hide_from_window_list(window) {
-        if (Meta.is_wayland_compositor() && this.process_running) {
+    hideFromWindowList(window) {
+        if (Meta.is_wayland_compositor() && this.process_running)
             this._waylandClient.hide_from_window_list(window);
-        }
+
     }
-}
+};
diff --git a/extensions/desktop-icons-ng/fileItem.js b/extensions/desktop-icons-ng/fileItem.js
index 1ea1f7f..84e6d39 100644
--- a/extensions/desktop-icons-ng/fileItem.js
+++ b/extensions/desktop-icons-ng/fileItem.js
@@ -17,7 +17,6 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-const GObject = imports.gi.GObject;
 const Gtk = imports.gi.Gtk;
 const Gdk = imports.gi.Gdk;
 const Gio = imports.gi.Gio;
@@ -25,14 +24,14 @@ const GLib = imports.gi.GLib;
 const Pango = imports.gi.Pango;
 const GdkPixbuf = imports.gi.GdkPixbuf;
 const GnomeDesktop = imports.gi.GnomeDesktop;
-const DesktopIconsUtil = imports.desktopIconsUtil;
 
+const DesktopIconsUtil = imports.desktopIconsUtil;
 const Prefs = imports.preferences;
 const Enums = imports.enums;
 const DBusUtils = imports.dbusUtils;
 
 const ByteArray = imports.byteArray;
-const Mainloop = imports.mainloop;
+const Mainloop = imports.mainloop; /* eslint-disable-line no-restricted-properties */
 const Signals = imports.signals;
 const Gettext = imports.gettext.domain('ding');
 
@@ -48,7 +47,7 @@ var FileItem = class {
         this._loadThumbnailDataCancellable = null;
         this._thumbnailScriptWatch = 0;
         this._queryFileInfoCancellable = null;
-        this._isSpecial = this._fileExtra != Enums.FileType.NONE;
+        this._isSpecial = this._fileExtra !== Enums.FileType.NONE;
         this._grid = null;
 
         this._file = file;
@@ -56,19 +55,19 @@ var FileItem = class {
         this._savedCoordinates = this._readCoordinatesFromAttribute(fileInfo, 'metadata::nautilus-icon-position');
         this._dropCoordinates = this._readCoordinatesFromAttribute(fileInfo, 'metadata::nautilus-drop-position');
 
-        this.actor = new Gtk.EventBox({visible: true});
+        this.actor = new Gtk.EventBox({ visible: true });
         this.actor.connect('destroy', () => this._onDestroy());
 
-        this._eventBox = new Gtk.EventBox({visible: true});
+        this._eventBox = new Gtk.EventBox({ visible: true });
 
-        this._innerContainer = new Gtk.Box({orientation: Gtk.Orientation.VERTICAL});
-        this._container = new Gtk.Box({orientation: Gtk.Orientation.VERTICAL});
+        this._innerContainer = new Gtk.Box({ orientation: Gtk.Orientation.VERTICAL });
+        this._container = new Gtk.Box({ orientation: Gtk.Orientation.VERTICAL });
         this._styleContext = this._innerContainer.get_style_context();
         this._eventBox.add(this._innerContainer);
 
 
         this._icon = new Gtk.Image();
-        this._iconContainer = new Gtk.Box({orientation: Gtk.Orientation.VERTICAL});
+        this._iconContainer = new Gtk.Box({ orientation: Gtk.Orientation.VERTICAL });
         this._innerContainer.pack_start(this._iconContainer, false, false, 0);
         this._iconContainer.set_size_request(Prefs.get_desired_width(), Prefs.get_icon_size());
         this._iconContainer.pack_start(this._icon, true, true, 0);
@@ -95,7 +94,9 @@ var FileItem = class {
          * in a second EventBox, located outside.
          */
 
-        this.actor.connect('button-press-event', (actor, event) => {return true;});
+        this.actor.connect('button-press-event', (unusedActor, unusedEvent) => {
+            return true;
+        });
         this._eventBox.connect('button-press-event', (actor, event) => this._onPressButton(actor, event));
         this._eventBox.connect('enter-notify-event', (actor, event) => this._onEnter(actor, event));
         this._eventBox.connect('leave-notify-event', (actor, event) => this._onLeave(actor, event));
@@ -112,60 +113,60 @@ var FileItem = class {
         this._isSelected = false;
         this._primaryButtonPressed = false;
 
-        if (this._attributeCanExecute && !this._isValidDesktopFile) {
+        if (this._attributeCanExecute && !this._isValidDesktopFile)
             this._execLine = this.file.get_path();
-        }
-        if (fileExtra == Enums.FileType.USER_DIRECTORY_TRASH) {
+
+        if (fileExtra === Enums.FileType.USER_DIRECTORY_TRASH) {
             // if this icon is the trash, monitor the state of the directory to update the icon
             this._trashChanged = false;
             this._queryTrashInfoCancellable = null;
             this._scheduleTrashRefreshId = 0;
             this._monitorTrashDir = this._file.monitor_directory(Gio.FileMonitorFlags.WATCH_MOVES, null);
-            this._monitorTrashId = this._monitorTrashDir.connect('changed', (obj, file, otherFile, eventType) => {
-                switch(eventType) {
-                    case Gio.FileMonitorEvent.DELETED:
-                    case Gio.FileMonitorEvent.MOVED_OUT:
-                    case Gio.FileMonitorEvent.CREATED:
-                    case Gio.FileMonitorEvent.MOVED_IN:
-                        if (this._queryTrashInfoCancellable || this._scheduleTrashRefreshId) {
-                            if (this._scheduleTrashRefreshId)
-                                GLib.source_remove(this._scheduleTrashRefreshId);
-                            this._scheduleTrashRefreshId = Mainloop.timeout_add(200, () => this._refreshTrashIcon());
-                        } else {
-                            this._refreshTrashIcon();
-                        }
+            this._monitorTrashId = this._monitorTrashDir.connect('changed', (obj, unusedFile, otherFile, eventType) => {
+                switch (eventType) {
+                case Gio.FileMonitorEvent.DELETED:
+                case Gio.FileMonitorEvent.MOVED_OUT:
+                case Gio.FileMonitorEvent.CREATED:
+                case Gio.FileMonitorEvent.MOVED_IN:
+                    if (this._queryTrashInfoCancellable || this._scheduleTrashRefreshId) {
+                        if (this._scheduleTrashRefreshId)
+                            GLib.source_remove(this._scheduleTrashRefreshId);
+                        this._scheduleTrashRefreshId = Mainloop.timeout_add(200, () => this._refreshTrashIcon());
+                    } else {
+                        this._refreshTrashIcon();
+                    }
                     break;
                 }
             });
         }
         this.actor.show_all();
         this._updateName();
-        if (this._dropCoordinates) {
+        if (this._dropCoordinates)
             this.setSelected();
-        }
+
     }
 
     _setFileName(text) {
-        if (this._fileExtra == Enums.FileType.USER_DIRECTORY_HOME) {
+        if (this._fileExtra === Enums.FileType.USER_DIRECTORY_HOME) {
             // TRANSLATORS: "Home" is the text that will be shown in the user's personal folder
-            text = _("Home");
+            text = _('Home');
         }
         this._currentFileName = text;
         this._eventBox.set_tooltip_text(text);
-        for (let character of ".,-_@:") {
-            text = text.split(character).join(character + '\u200B');
-        }
+        for (let character of '.,-_@:')
+            text = text.split(character).join(`${character}\u200B`);
+
         this._label.label = text;
     }
 
     _readCoordinatesFromAttribute(fileInfo, attribute) {
         let savedCoordinates = fileInfo.get_attribute_as_string(attribute);
-        if ((savedCoordinates != null) && (savedCoordinates != '')) {
+        if (savedCoordinates !== null && savedCoordinates !== '') {
             savedCoordinates = savedCoordinates.split(',');
             if (savedCoordinates.length >= 2) {
-                if (!isNaN(savedCoordinates[0]) && !isNaN(savedCoordinates[1])) {
+                if (!isNaN(savedCoordinates[0]) && !isNaN(savedCoordinates[1]))
                     return [Number(savedCoordinates[0]), Number(savedCoordinates[1])];
-                }
+
             }
         }
         return null;
@@ -176,113 +177,111 @@ var FileItem = class {
             this._grid.removeItem(this);
             this._grid = null;
         }
-        if (this._menu) {
+        if (this._menu)
             this._menu.popdown();
-        }
+
     }
 
     _setDragSource() {
         this._dragSource.drag_source_set(Gdk.ModifierType.BUTTON1_MASK, null, Gdk.DragAction.MOVE | Gdk.DragAction.COPY);
         let targets = new Gtk.TargetList(null);
         targets.add(Gdk.atom_intern('x-special/ding-icon-list', false), Gtk.TargetFlags.SAME_APP, 0);
-        if ((this._fileExtra != Enums.FileType.USER_DIRECTORY_TRASH) &&
-            (this._fileExtra != Enums.FileType.USER_DIRECTORY_HOME) &&
-            (this._fileExtra != Enums.FileType.EXTERNAL_DRIVE)) {
-                targets.add(Gdk.atom_intern('x-special/gnome-icon-list', false), 0, 1);
-                targets.add(Gdk.atom_intern('text/uri-list', false), 0, 2);
+        if (this._fileExtra !== Enums.FileType.USER_DIRECTORY_TRASH &&
+            this._fileExtra !== Enums.FileType.USER_DIRECTORY_HOME &&
+            this._fileExtra !== Enums.FileType.EXTERNAL_DRIVE) {
+            targets.add(Gdk.atom_intern('x-special/gnome-icon-list', false), 0, 1);
+            targets.add(Gdk.atom_intern('text/uri-list', false), 0, 2);
         }
         this._dragSource.drag_source_set_target_list(targets);
-        this._dragSource.connect('drag-begin', (widget, context) => {
+        this._dragSource.connect('drag-begin', (unusedWidget, unusedContext) => {
             this._desktopManager.onDragBegin(this);
         });
-        this._dragSource.connect('drag-data-get', (widget, context, data, info, time) => {
+        this._dragSource.connect('drag-data-get', (widget, context, data, info, unusedTime) => {
             let dragData = this._desktopManager.fillDragDataGet(info);
-            if (dragData != null) {
+            if (dragData !== null) {
                 let list = ByteArray.fromString(dragData[1]);
                 data.set(dragData[0], 8, list);
             }
         });
-        this._dragSource.connect('drag-end', (widget, context) => {
+        this._dragSource.connect('drag-end', (unusedWidget, unusedContext) => {
             this._desktopManager.onDragEnd();
-        })
+        });
     }
 
     _setDropDestination(dropDestination) {
         dropDestination.drag_dest_set(Gtk.DestDefaults.DROP | Gtk.DestDefaults.MOTION, null, Gdk.DragAction.MOVE);
-        if ((this._fileExtra == Enums.FileType.USER_DIRECTORY_TRASH) ||
-            (this._fileExtra == Enums.FileType.USER_DIRECTORY_HOME) ||
-            (this._fileExtra != Enums.FileType.EXTERNAL_DRIVE) ||
-            (this._isDirectory)) {
-                let targets = new Gtk.TargetList(null);
-                targets.add(Gdk.atom_intern('x-special/gnome-icon-list', false), 0, 1);
-                targets.add(Gdk.atom_intern('text/uri-list', false), 0, 2);
-                dropDestination.drag_dest_set_target_list(targets);
-                dropDestination.connect('drag-data-received', (widget, context, x, y, selection, info, time) => {
-                    if ((info == 1) || (info == 2)) {
-                        let fileList = DesktopIconsUtil.getFilesFromNautilusDnD(selection, info);
-                        if (fileList.length != 0) {
-                            if (this._desktopManager.dragItem && ((this._desktopManager.dragItem.uri == this._file.get_uri()) || !(this._isValidDesktopFile || this.isDirectory))) {
-                                // Dragging a file/folder over itself or over another file will do nothing, allow drag to directory or validdesktop file
-                                return;
-                            }
-                            if ( this._isValidDesktopFile ) {
-                                // open the desktopfile with these dropped files as the arguments
-                                this.doOpen(fileList);
-                                return;
-                            }
-                            if (this._fileExtra != Enums.FileType.USER_DIRECTORY_TRASH) {
-                                let data = Gio.File.new_for_uri(fileList[0]).query_info('id::filesystem', Gio.FileQueryInfoFlags.NONE, null);
-                                let id_fs = data.get_attribute_string('id::filesystem');
-                                if (this._desktopManager.desktopFsId == id_fs) {
-                                    DBusUtils.NautilusFileOperationsProxy.MoveURIsRemote(fileList, this._file.get_uri(),
-                                        (result, error) => {
-                                            if (error) {
-                                                throw new Error('Error moving files: ' + error.message);
-                                            }
-                                        }
-                                    );
-                                } else {
-                                    DBusUtils.NautilusFileOperationsProxy.CopyURIsRemote(fileList, this._file.get_uri(),
-                                        (result, error) => {
-                                            if (error) {
-                                                throw new Error('Error moving files: ' + error.message);
-                                            }
-                                        }
-                                    );
-                                }
+        if (this._fileExtra === Enums.FileType.USER_DIRECTORY_TRASH ||
+            this._fileExtra === Enums.FileType.USER_DIRECTORY_HOME ||
+            this._fileExtra !== Enums.FileType.EXTERNAL_DRIVE ||
+            this._isDirectory) {
+            let targets = new Gtk.TargetList(null);
+            targets.add(Gdk.atom_intern('x-special/gnome-icon-list', false), 0, 1);
+            targets.add(Gdk.atom_intern('text/uri-list', false), 0, 2);
+            dropDestination.drag_dest_set_target_list(targets);
+            dropDestination.connect('drag-data-received', (widget, context, x, y, selection, info, unusedTime) => {
+                if (info === 1 || info === 2) {
+                    let fileList = DesktopIconsUtil.getFilesFromNautilusDnD(selection, info);
+                    if (fileList.length !== 0) {
+                        if (this._desktopManager.dragItem && (this._desktopManager.dragItem.uri === this._file.get_uri() || !(this._isValidDesktopFile || this.isDirectory))) {
+                            // Dragging a file/folder over itself or over another file will do nothing, allow drag to directory or validdesktop file
+                            return;
+                        }
+                        if (this._isValidDesktopFile) {
+                            // open the desktopfile with these dropped files as the arguments
+                            this.doOpen(fileList);
+                            return;
+                        }
+                        if (this._fileExtra !== Enums.FileType.USER_DIRECTORY_TRASH) {
+                            let data = Gio.File.new_for_uri(fileList[0]).query_info('id::filesystem', Gio.FileQueryInfoFlags.NONE, null);
+                            let idFs = data.get_attribute_string('id::filesystem');
+                            if (this._desktopManager.desktopFsId === idFs) {
+                                DBusUtils.NautilusFileOperationsProxy.MoveURIsRemote(fileList, this._file.get_uri(),
+                                    (result, error) => {
+                                        if (error)
+                                            throw new Error(`Error moving files: ${error.message}`);
+
+                                    }
+                                );
                             } else {
-                                DBusUtils.NautilusFileOperationsProxy.TrashFilesRemote(fileList,
+                                DBusUtils.NautilusFileOperationsProxy.CopyURIsRemote(fileList, this._file.get_uri(),
                                     (result, error) => {
-                                        if (error) {
-                                            throw new Error('Error moving files: ' + error.message);
-                                        }
+                                        if (error)
+                                            throw new Error(`Error moving files: ${error.message}`);
+
                                     }
                                 );
                             }
+                        } else {
+                            DBusUtils.NautilusFileOperationsProxy.TrashFilesRemote(fileList,
+                                (result, error) => {
+                                    if (error)
+                                        throw new Error(`Error moving files: ${error.message}`);
+
+                                }
+                            );
                         }
                     }
-                });
+                }
+            });
 
 
-                dropDestination.connect('drag-motion', (widget, context, x, y, time) => {
-                    if (!this._styleContext.has_class('file-item-hover'))
-                    {
+            dropDestination.connect('drag-motion', (unusedWidget, unusedContext, unusedX, unusedY, unusedTime) => {
+                if (!this._styleContext.has_class('file-item-hover'))
                     this._styleContext.add_class('file-item-hover');
-                    };
-                });
-                dropDestination.connect('drag-leave', (widget, context, time) => {
-                    if (this._styleContext.has_class('file-item-hover'))
-                    {
+
+            });
+            dropDestination.connect('drag-leave', (unusedWidget, unusedContext, unusedTime) => {
+                if (this._styleContext.has_class('file-item-hover'))
                     this._styleContext.remove_class('file-item-hover');
-                    }
-                    });
+
+            });
         }
     }
 
     onAttributeChanged() {
-        if (this._isDesktopFile) {
+        if (this._isDesktopFile)
             this._refreshMetadataAsync(true);
-        }
+
     }
 
 
@@ -290,8 +289,8 @@ var FileItem = class {
         this._x1 = x;
         this._y1 = y;
         this._zoom = zoom;
-        this._x2 = x + (width * zoom) - 1;
-        this._y2 = y + (height * zoom) - 1;
+        this._x2 = x + width * zoom - 1;
+        this._y2 = y + height * zoom - 1;
         this._grid = grid;
         this._container.set_size_request(width, height);
         this._label.margin_start = margin;
@@ -306,32 +305,32 @@ var FileItem = class {
 
     _onDestroy() {
         /* Regular file data */
-        if (this._queryFileInfoCancellable) {
+        if (this._queryFileInfoCancellable)
             this._queryFileInfoCancellable.cancel();
-        }
+
 
         /* Thumbnailing */
-        if (this._thumbnailScriptWatch) {
+        if (this._thumbnailScriptWatch)
             GLib.source_remove(this._thumbnailScriptWatch);
-        }
-        if (this._loadThumbnailDataCancellable) {
+
+        if (this._loadThumbnailDataCancellable)
             this._loadThumbnailDataCancellable.cancel();
-        }
+
 
         /* Trash */
         if (this._monitorTrashDir) {
             this._monitorTrashDir.disconnect(this._monitorTrashId);
             this._monitorTrashDir.cancel();
         }
-        if (this._queryTrashInfoCancellable) {
+        if (this._queryTrashInfoCancellable)
             this._queryTrashInfoCancellable.cancel();
-        }
-        if (this._scheduleTrashRefreshId) {
+
+        if (this._scheduleTrashRefreshId)
             GLib.source_remove(this._scheduleTrashRefreshId);
-        }
-        if (this._menuId) {
+
+        if (this._menuId)
             this._menu.disconnect(this._menuId);
-        }
+
     }
 
     _refreshMetadataAsync(rebuild) {
@@ -339,21 +338,21 @@ var FileItem = class {
             this._queryFileInfoCancellable.cancel();
         this._queryFileInfoCancellable = new Gio.Cancellable();
         this._file.query_info_async(Enums.DEFAULT_ATTRIBUTES,
-                                    Gio.FileQueryInfoFlags.NONE,
-                                    GLib.PRIORITY_DEFAULT,
-                                    this._queryFileInfoCancellable,
+            Gio.FileQueryInfoFlags.NONE,
+            GLib.PRIORITY_DEFAULT,
+            this._queryFileInfoCancellable,
             (source, result) => {
                 try {
                     let newFileInfo = source.query_info_finish(result);
                     this._queryFileInfoCancellable = null;
                     this._updateMetadataFromFileInfo(newFileInfo);
-                    if (rebuild) {
+                    if (rebuild)
                         this._updateIcon();
-                    }
+
                     this._updateName();
-                } catch(error) {
+                } catch (error) {
                     if (!error.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED))
-                        print("Error getting the file info: " + error);
+                        print(`Error getting the file info: ${error}`);
                 }
             }
         );
@@ -366,11 +365,11 @@ var FileItem = class {
 
         this._displayName = fileInfo.get_attribute_as_string('standard::display-name');
         this._attributeCanExecute = fileInfo.get_attribute_boolean('access::can-execute');
-        this._unixmode = fileInfo.get_attribute_uint32('unix::mode')
-        this._writableByOthers = (this._unixmode & Enums.S_IWOTH) != 0;
-        this._trusted = fileInfo.get_attribute_as_string('metadata::trusted') == 'true';
+        this._unixmode = fileInfo.get_attribute_uint32('unix::mode');
+        this._writableByOthers = (this._unixmode & Enums.S_IWOTH) !== 0;
+        this._trusted = fileInfo.get_attribute_as_string('metadata::trusted') === 'true';
         this._attributeContentType = fileInfo.get_content_type();
-        this._isDesktopFile = this._attributeContentType == 'application/x-desktop';
+        this._isDesktopFile = this._attributeContentType === 'application/x-desktop';
 
         if (this._isDesktopFile && this._writableByOthers)
             log(`desktop-icons: File ${this._displayName} is writable by others - will not allow launching`);
@@ -387,23 +386,23 @@ var FileItem = class {
             this._isValidDesktopFile = false;
         }
 
-        if (this.displayName != oldLabelText) {
+        if (this.displayName !== oldLabelText)
             this._setFileName(this.displayName);
-        }
+
 
         this._fileType = fileInfo.get_file_type();
-        this._isDirectory = this._fileType == Gio.FileType.DIRECTORY;
-        this._isSpecial = this._fileExtra != Enums.FileType.NONE;
+        this._isDirectory = this._fileType === Gio.FileType.DIRECTORY;
+        this._isSpecial = this._fileExtra !== Enums.FileType.NONE;
         this._isHidden = fileInfo.get_is_hidden() | fileInfo.get_is_backup();
         this._isSymlink = fileInfo.get_is_symlink();
-        this._modifiedTime = fileInfo.get_attribute_uint64("time::modified");
+        this._modifiedTime = fileInfo.get_attribute_uint64('time::modified');
         /*
          * This is a glib trick to detect broken symlinks. If a file is a symlink, the filetype
          * points to the final file, unless it is broken; thus if the file type is SYMBOLIC_LINK,
          * it must be a broken link.
          * https://developer.gnome.org/gio/stable/GFile.html#g-file-query-info
          */
-        this._isBrokenSymlink = this._isSymlink && this._fileType == Gio.FileType.SYMBOLIC_LINK
+        this._isBrokenSymlink = this._isSymlink && this._fileType === Gio.FileType.SYMBOLIC_LINK;
     }
 
     onFileRenamed(file) {
@@ -414,51 +413,51 @@ var FileItem = class {
     _updateIcon() {
         try {
             let customIcon = this._fileInfo.get_attribute_as_string('metadata::custom-icon');
-            if (customIcon && (customIcon != '')) {
+            if (customIcon && customIcon !== '') {
                 let customIconFile = Gio.File.new_for_uri(customIcon);
                 if (customIconFile.query_exists(null)) {
-                    if (this._loadImageAsIcon(customIconFile)) {
+                    if (this._loadImageAsIcon(customIconFile))
                         return;
-                    }
+
                 }
             }
         } catch (error) {
             print(error);
         }
 
-        if (this._fileExtra == Enums.FileType.USER_DIRECTORY_TRASH) {
+        if (this._fileExtra === Enums.FileType.USER_DIRECTORY_TRASH) {
             let pixbuf = this._createEmblemedIcon(this._fileInfo.get_icon(), null);
             this._icon.set_from_pixbuf(pixbuf);
             this._dragSource.drag_source_set_icon_pixbuf(pixbuf);
             return;
         }
-        let icon_set = false;
+        let iconSet = false;
 
         let thumbnailFactory = GnomeDesktop.DesktopThumbnailFactory.new(GnomeDesktop.DesktopThumbnailSize.LARGE);
-        if ((Prefs.nautilusSettings.get_string('show-image-thumbnails') != 'never') &&
-            (thumbnailFactory.can_thumbnail(this._file.get_uri(),
-                                            this._attributeContentType,
-                                            this._modifiedTime))) {
+        if (Prefs.nautilusSettings.get_string('show-image-thumbnails') !== 'never' &&
+            thumbnailFactory.can_thumbnail(this._file.get_uri(),
+                this._attributeContentType,
+                this._modifiedTime)) {
             let thumbnail = thumbnailFactory.lookup(this._file.get_uri(), this._modifiedTime);
-            if (thumbnail == null) {
+            if (thumbnail === null) {
                 if (!thumbnailFactory.has_valid_failed_thumbnail(this._file.get_uri(),
-                                                                 this._modifiedTime)) {
+                    this._modifiedTime)) {
                     let argv = [];
                     argv.push(GLib.build_filenamev([this._codePath, 'createThumbnail.js']));
                     argv.push(this._file.get_path());
-                    let [success, pid] = GLib.spawn_async(null, argv, null,
-                                                          GLib.SpawnFlags.SEARCH_PATH | GLib.SpawnFlags.DO_NOT_REAP_CHILD, null);
+                    let [unusedSuccess, pid] = GLib.spawn_async(null, argv, null,
+                        GLib.SpawnFlags.SEARCH_PATH | GLib.SpawnFlags.DO_NOT_REAP_CHILD, null);
                     if (this._thumbnailScriptWatch)
                         GLib.source_remove(this._thumbnailScriptWatch);
                     this._thumbnailScriptWatch = GLib.child_watch_add(GLib.PRIORITY_DEFAULT,
-                                                                      pid,
-                        (pid, exitCode) => {
+                        pid,
+                        (pidC, exitCode) => {
                             this._thumbnailScriptWatch = 0;
-                            if (exitCode == 0)
+                            if (exitCode === 0)
                                 this._updateIcon();
                             else
-                                print('Failed to generate thumbnail for ' + this._filePath);
-                            GLib.spawn_close_pid(pid);
+                                print(`Failed to generate thumbnail for ${this._filePath}`);
+                            GLib.spawn_close_pid(pidC);
                             return false;
                         }
                     );
@@ -469,50 +468,48 @@ var FileItem = class {
                 this._loadThumbnailDataCancellable = new Gio.Cancellable();
                 let thumbnailFile = Gio.File.new_for_path(thumbnail);
                 try {
-                    icon_set = this._loadImageAsIcon(thumbnailFile);
+                    iconSet = this._loadImageAsIcon(thumbnailFile);
                 } catch (error) {
                     if (!error.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED)) {
-                        print('Error while loading thumbnail: ' + error);
+                        print(`Error while loading thumbnail: ${error}`);
                         this._icon.set_from_pixbuf(this._createEmblemedIcon(this._fileInfo.get_icon(), null));
                     }
                 }
             }
         }
 
-        if (!icon_set) {
+        if (!iconSet) {
             let pixbuf;
-            if (this._isBrokenSymlink) {
+            if (this._isBrokenSymlink)
                 pixbuf = this._createEmblemedIcon(null, 'text-x-generic');
-            } else {
-                if (this.trustedDesktopFile && this._desktopFile.has_key('Icon')) {
-                    pixbuf = this._createEmblemedIcon(null, this._desktopFile.get_string('Icon'));
-                } else {
-                    pixbuf = this._createEmblemedIcon(this._getDefaultIcon(), null);
-                }
-            }
+            else if (this.trustedDesktopFile && this._desktopFile.has_key('Icon'))
+                pixbuf = this._createEmblemedIcon(null, this._desktopFile.get_string('Icon'));
+            else
+                pixbuf = this._createEmblemedIcon(this._getDefaultIcon(), null);
+
             this._icon.set_from_pixbuf(pixbuf);
             this._dragSource.drag_source_set_icon_pixbuf(pixbuf);
         }
     }
 
     _getDefaultIcon() {
-        if (this._fileExtra == Enums.FileType.EXTERNAL_DRIVE) {
+        if (this._fileExtra === Enums.FileType.EXTERNAL_DRIVE)
             return this._custom.get_icon();
-        }
+
         return this._fileInfo.get_icon();
     }
 
     _loadImageAsIcon(imageFile) {
-        let [thumbnailData, etag_out] = imageFile.load_bytes(this._loadThumbnailDataCancellable);
+        let [thumbnailData, unusedEtagOut] = imageFile.load_bytes(this._loadThumbnailDataCancellable);
         this._loadThumbnailDataCancellable = null;
         let thumbnailStream = Gio.MemoryInputStream.new_from_bytes(thumbnailData);
         let thumbnailPixbuf = GdkPixbuf.Pixbuf.new_from_stream(thumbnailStream, null);
 
-        if (thumbnailPixbuf != null) {
+        if (thumbnailPixbuf !== null) {
             let width = Prefs.get_desired_width();
             let height = Prefs.get_icon_size();
             let aspectRatio = thumbnailPixbuf.width / thumbnailPixbuf.height;
-            if ((width / height) > aspectRatio)
+            if (width / height > aspectRatio)
                 width = height * aspectRatio;
             else
                 height = width / aspectRatio;
@@ -533,15 +530,15 @@ var FileItem = class {
          * to ensure that the emblems fit.
          */
 
-        if (this._copiedPixbuf) {
+        if (this._copiedPixbuf)
             return pixbuf;
-        }
+
 
         this._copiedPixbuf = true;
         let minsize = Prefs.get_icon_size();
-        if ((pixbuf.width < minsize) || (pixbuf.height < minsize)) {
-            let width = (pixbuf.width < minsize) ? minsize : pixbuf.width;
-            let height = (pixbuf.height < minsize) ? minsize : pixbuf.height;
+        if (pixbuf.width < minsize || pixbuf.height < minsize) {
+            let width = pixbuf.width < minsize ? minsize : pixbuf.width;
+            let height = pixbuf.height < minsize ? minsize : pixbuf.height;
             let newpixbuf = GdkPixbuf.Pixbuf.new(pixbuf.colorspace, true, pixbuf.bits_per_sample, width, height);
             newpixbuf.fill(0);
             let x = Math.floor((width - pixbuf.width) / 2);
@@ -584,17 +581,17 @@ var FileItem = class {
         this._queryTrashInfoCancellable = new Gio.Cancellable();
 
         this._file.query_info_async(Enums.DEFAULT_ATTRIBUTES,
-                                    Gio.FileQueryInfoFlags.NONE,
-                                    GLib.PRIORITY_DEFAULT,
-                                    this._queryTrashInfoCancellable,
+            Gio.FileQueryInfoFlags.NONE,
+            GLib.PRIORITY_DEFAULT,
+            this._queryTrashInfoCancellable,
             (source, result) => {
                 try {
                     this._fileInfo = source.query_info_finish(result);
                     this._queryTrashInfoCancellable = null;
                     this._updateIcon();
-                } catch(error) {
+                } catch (error) {
                     if (!error.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED))
-                        print('Error getting the number of files in the trash: ' + error);
+                        print(`Error getting the number of files in the trash: ${error}`);
                 }
             });
         this._scheduleTrashRefreshId = 0;
@@ -610,7 +607,7 @@ var FileItem = class {
     }
 
     _createEmblemedIcon(icon, iconName) {
-        if (icon == null) {
+        if (icon === null) {
             if (GLib.path_is_absolute(iconName)) {
                 let iconFile = Gio.File.new_for_commandline_arg(iconName);
                 icon = new Gio.FileIcon({ file: iconFile });
@@ -624,7 +621,7 @@ var FileItem = class {
         try {
             itemIcon = theme.lookup_by_gicon(icon, Prefs.get_icon_size(), Gtk.IconLookupFlags.FORCE_SIZE).load_icon();
         } catch (e) {
-            itemIcon = theme.load_icon("text-x-generic", Prefs.get_icon_size(), Gtk.IconLookupFlags.FORCE_SIZE);
+            itemIcon = theme.load_icon('text-x-generic', Prefs.get_icon_size(), Gtk.IconLookupFlags.FORCE_SIZE);
         }
 
         itemIcon = this._addEmblemsToPixbufIfNeeded(itemIcon);
@@ -634,7 +631,7 @@ var FileItem = class {
 
     doRename() {
         if (!this.canRename()) {
-            log (`Error: ${this.file.get_uri()} cannot be renamed`);
+            log(`Error: ${this.file.get_uri()} cannot be renamed`);
             return;
         }
 
@@ -642,16 +639,16 @@ var FileItem = class {
     }
 
     doOpen(fileList) {
-        if (! fileList ) {
-            fileList = [] ;
-        }
+        if (!fileList)
+            fileList = [];
+
         this._doOpenContext(null, fileList);
     }
 
     _doOpenContext(context, fileList) {
-        if (! fileList ) {
-            fileList = [] ;
-        }
+        if (!fileList)
+            fileList = [];
+
         if (this._isBrokenSymlink) {
             log(`Error: Can’t open ${this.file.get_uri()} because it is a broken symlink.`);
             return;
@@ -682,7 +679,7 @@ var FileItem = class {
                 try {
                     Gio.AppInfo.launch_default_for_uri_finish(result);
                 } catch (e) {
-                    log('Error opening file ' + this.file.get_uri() + ': ' + e.message);
+                    log(`Error opening file ${this.file.get_uri()}: ${e.message}`);
                 }
             }
         );
@@ -693,7 +690,7 @@ var FileItem = class {
         DBusUtils.FreeDesktopFileManagerProxy.ShowItemsRemote(showInFilesList, '',
             (result, error) => {
                 if (error)
-                    log('Error showing file on desktop: ' + error.message);
+                    log(`Error showing file on desktop: ${error.message}`);
             }
         );
     }
@@ -703,7 +700,7 @@ var FileItem = class {
         DBusUtils.FreeDesktopFileManagerProxy.ShowItemPropertiesRemote(propertiesFileList, '',
             (result, error) => {
                 if (error)
-                    log('Error showing properties: ' + error.message);
+                    log(`Error showing properties: ${error.message}`);
             }
         );
     }
@@ -717,27 +714,27 @@ var FileItem = class {
 
         let info = new Gio.FileInfo();
         info.set_attribute_string('metadata::trusted',
-                                  value ? 'true' : 'false');
+            value ? 'true' : 'false');
         this._file.set_attributes_async(info,
-                                        Gio.FileQueryInfoFlags.NONE,
-                                        GLib.PRIORITY_LOW,
-                                        null,
+            Gio.FileQueryInfoFlags.NONE,
+            GLib.PRIORITY_LOW,
+            null,
             (source, result) => {
                 try {
                     source.set_attributes_finish(result);
                     this._refreshMetadataAsync(true);
-                } catch(e) {
+                } catch (e) {
                     log(`Failed to set metadata::trusted: ${e.message}`);
                 }
-        });
+            });
     }
 
     _updateName() {
-        if (this._isValidDesktopFile && !this._desktopManager.writableByOthers && !this._writableByOthers && this.trustedDesktopFile) {
-            this._setFileName(this._desktopFile.get_locale_string("Name"));
-        } else {
+        if (this._isValidDesktopFile && !this._desktopManager.writableByOthers && !this._writableByOthers && this.trustedDesktopFile)
+            this._setFileName(this._desktopFile.get_locale_string('Name'));
+        else
             this._setFileName(this._fileInfo.get_display_name());
-        }
+
     }
 
     _onAllowDisallowLaunchingClicked() {
@@ -753,14 +750,14 @@ var FileItem = class {
             let newUnixMode = this._unixmode | Enums.S_IXUSR;
             info.set_attribute_uint32(Gio.FILE_ATTRIBUTE_UNIX_MODE, newUnixMode);
             this._file.set_attributes(info,
-                                      Gio.FileQueryInfoFlags.NONE,
-                                      null);
+                Gio.FileQueryInfoFlags.NONE,
+                null);
         }
         this._updateName();
     }
 
     canRename() {
-        return !this.trustedDesktopFile && this._fileExtra == Enums.FileType.NONE;
+        return !this.trustedDesktopFile && this._fileExtra === Enums.FileType.NONE;
     }
 
     _doDiscreteGpu() {
@@ -774,23 +771,23 @@ var FileItem = class {
             return;
         }
 
-        for(let gpu in gpus) {
+        for (let gpu in gpus) {
             if (!gpus[gpu])
                 continue;
 
-            let default_variant = gpus[gpu]['Default'];
-            if (!default_variant || default_variant.get_boolean())
+            let defaultVariant = gpus[gpu]['Default'];
+            if (!defaultVariant || defaultVariant.get_boolean())
                 continue;
 
             let env = gpus[gpu]['Environment'];
             if (!env)
                 continue;
 
-            let env_s = env.get_strv();
-            let context = new Gio.AppLaunchContext;
-            for (let i = 0; i < env_s.length; i=i+2) {
-                context.setenv(env_s[i], env_s[i+1]);
-            }
+            let envS = env.get_strv();
+            let context = new Gio.AppLaunchContext();
+            for (let i = 0; i < envS.length; i += 2)
+                context.setenv(envS[i], envS[i + 1]);
+
             this._doOpenContext(context, null);
             return;
         }
@@ -805,18 +802,20 @@ var FileItem = class {
             this._menu = null;
             this._menuId = null;
         });
-        let open = new Gtk.MenuItem({label: (this._selectedItemsNum > 1 ? _("Open All...") : _("Open"))});
-        open.connect('activate', () => {this._desktopManager.doMultiOpen();});
+        let open = new Gtk.MenuItem({ label: this._selectedItemsNum > 1 ? _('Open All...') : _('Open') });
+        open.connect('activate', () => {
+            this._desktopManager.doMultiOpen();
+        });
         this._menu.add(open);
         this._desktopManager._createScriptsMenu(this._menu);
         switch (this._fileExtra) {
         case Enums.FileType.NONE:
             if (!this._isDirectory) {
-                this._actionOpenWith = new Gtk.MenuItem({label: this._selectedItemsNum > 1 ? _("Open All With Other Application...") : _("Open With Other Application")});
+                this._actionOpenWith = new Gtk.MenuItem({ label: this._selectedItemsNum > 1 ? _('Open All With Other Application...') : _('Open With Other Application') });
                 this._actionOpenWith.connect('activate', () => this._desktopManager.doOpenWith());
                 this._menu.add(this._actionOpenWith);
                 if (DBusUtils.discreteGpuAvailable && this.trustedDesktopFile) {
-                    this._actionDedicatedGPU = new Gtk.MenuItem({label:_('Launch using Dedicated Graphics Card')});
+                    this._actionDedicatedGPU = new Gtk.MenuItem({ label: _('Launch using Dedicated Graphics Card') });
                     this._actionDedicatedGPU.connect('activate', () => this._doDiscreteGpu());
                     this._menu.add(this._actionDedicatedGPU);
                 }
@@ -824,49 +823,59 @@ var FileItem = class {
                 this._actionOpenWith = null;
             }
             this._menu.add(new Gtk.SeparatorMenuItem());
-            this._actionCut = new Gtk.MenuItem({label:_('Cut')});
-            this._actionCut.connect('activate', () => {this._desktopManager.doCut();});
+            this._actionCut = new Gtk.MenuItem({ label: _('Cut') });
+            this._actionCut.connect('activate', () => {
+                this._desktopManager.doCut();
+            });
             this._menu.add(this._actionCut);
-            this._actionCopy = new Gtk.MenuItem({label:_('Copy')});
-            this._actionCopy.connect('activate', () => {this._desktopManager.doCopy();});
+            this._actionCopy = new Gtk.MenuItem({ label: _('Copy') });
+            this._actionCopy.connect('activate', () => {
+                this._desktopManager.doCopy();
+            });
             this._menu.add(this._actionCopy);
-            if (this.canRename() && (this._selectedItemsNum == 1)) {
-                let rename = new Gtk.MenuItem({label:_('Rename…')});
+            if (this.canRename() && this._selectedItemsNum === 1) {
+                let rename = new Gtk.MenuItem({ label: _('Rename…') });
                 rename.connect('activate', () => this.doRename());
                 this._menu.add(rename);
             }
-            this._actionTrash = new Gtk.MenuItem({label:_('Move to Trash')});
-            this._actionTrash.connect('activate', () => {this._desktopManager.doTrash();});
+            this._actionTrash = new Gtk.MenuItem({ label: _('Move to Trash') });
+            this._actionTrash.connect('activate', () => {
+                this._desktopManager.doTrash();
+            });
             this._menu.add(this._actionTrash);
             if (Prefs.nautilusSettings.get_boolean('show-delete-permanently')) {
-                this._actionDelete = new Gtk.MenuItem({label:_('Delete permanently')});
-                this._actionDelete.connect('activate', () => {this._desktopManager.doDeletePermanently();});
+                this._actionDelete = new Gtk.MenuItem({ label: _('Delete permanently') });
+                this._actionDelete.connect('activate', () => {
+                    this._desktopManager.doDeletePermanently();
+                });
                 this._menu.add(this._actionDelete);
             }
-            if (this._isValidDesktopFile && !this._desktopManager.writableByOthers && !this._writableByOthers && (this._selectedItemsNum == 1 )) {
+            if (this._isValidDesktopFile && !this._desktopManager.writableByOthers && !this._writableByOthers && this._selectedItemsNum === 1) {
                 this._menu.add(new Gtk.SeparatorMenuItem());
-                this._allowLaunchingMenuItem = new Gtk.MenuItem({label: this.trustedDesktopFile ? _("Don't Allow Launching") : _("Allow Launching")});
+                this._allowLaunchingMenuItem = new Gtk.MenuItem({ label: this.trustedDesktopFile ? _("Don't Allow Launching") : _('Allow Launching') });
                 this._allowLaunchingMenuItem.connect('activate', () => this._onAllowDisallowLaunchingClicked());
                 this._menu.add(this._allowLaunchingMenuItem);
             }
             break;
         case Enums.FileType.USER_DIRECTORY_TRASH:
             this._menu.add(new Gtk.SeparatorMenuItem());
-            let trashItem = new Gtk.MenuItem({label: _('Empty Trash')});
-            trashItem.connect('activate', () => {this._desktopManager.doEmptyTrash();});
+            var trashItem = new Gtk.MenuItem({ label: _('Empty Trash') });
+            trashItem.connect('activate', () => {
+                this._desktopManager.doEmptyTrash();
+            });
             this._menu.add(trashItem);
             break;
         case Enums.FileType.EXTERNAL_DRIVE:
             this._menu.add(new Gtk.SeparatorMenuItem());
             if (this._custom.can_eject()) {
-                this._volumeItem = new Gtk.MenuItem({label: _('Eject')});
+                this._volumeItem = new Gtk.MenuItem({ label: _('Eject') });
                 this._volumeItem.connect('activate', () => {
                     this._custom.eject_with_operation(Gio.MountUnmountFlags.NONE, null, null, (obj, res) => {
                         obj.eject_with_operation_finish(res);
                     });
                 });
             } else if (this._custom.can_unmount()) {
-                this._volumeItem = new Gtk.MenuItem({label: _('Unmount')});
+                this._volumeItem = new Gtk.MenuItem({ label: _('Unmount') });
                 this._volumeItem.connect('activate', () => {
                     this._custom.unmount_with_operation(Gio.MountUnmountFlags.NONE, null, null, (obj, res) => {
                         obj.unmount_with_operation_finish(res);
@@ -879,50 +888,56 @@ var FileItem = class {
             break;
         }
         this._menu.add(new Gtk.SeparatorMenuItem());
-        if ( (! this._desktopManager.checkIfSpecialFilesAreSelected()) && (this._selectedItemsNum >= 1 )) {
-            if (! this._isDirectory) {
-                let mailFilesFromSelection = new Gtk.MenuItem({label: _('Send to...')});
-                mailFilesFromSelection.connect('activate', () => {this._desktopManager.mailFilesFromSelection();});
+        if (!this._desktopManager.checkIfSpecialFilesAreSelected() && this._selectedItemsNum >= 1) {
+            if (!this._isDirectory) {
+                let mailFilesFromSelection = new Gtk.MenuItem({ label: _('Send to...') });
+                mailFilesFromSelection.connect('activate', () => {
+                    this._desktopManager.mailFilesFromSelection();
+                });
                 this._menu.add(mailFilesFromSelection);
             }
-            let compressFilesFromSelection = new Gtk.MenuItem({label: Gettext.ngettext('Compress {0} file', 'Compress {0} files', this._selectedItemsNum).replace('{0}', this._selectedItemsNum)});
-            compressFilesFromSelection.connect('activate', () => {this._desktopManager.doCompressFilesFromSelection();});
+            let compressFilesFromSelection = new Gtk.MenuItem({ label: Gettext.ngettext('Compress {0} file', 'Compress {0} files', this._selectedItemsNum).replace('{0}', this._selectedItemsNum) });
+            compressFilesFromSelection.connect('activate', () => {
+                this._desktopManager.doCompressFilesFromSelection();
+            });
             this._menu.add(compressFilesFromSelection);
-            let newFolderFromSelection = new Gtk.MenuItem({label:  Gettext.ngettext('New Folder with {0} item', 'New Folder with {0} items' , this._selectedItemsNum).replace('{0}', this._selectedItemsNum)});
-            newFolderFromSelection.connect('activate', () => {this._desktopManager.doNewFolderFromSelection(this._savedCoordinates);});
+            let newFolderFromSelection = new Gtk.MenuItem({ label: Gettext.ngettext('New Folder with {0} item', 'New Folder with {0} items', this._selectedItemsNum).replace('{0}', this._selectedItemsNum) });
+            newFolderFromSelection.connect('activate', () => {
+                this._desktopManager.doNewFolderFromSelection(this._savedCoordinates);
+            });
             this._menu.add(newFolderFromSelection);
             this._menu.add(new Gtk.SeparatorMenuItem());
         }
         this._menu.add(new Gtk.SeparatorMenuItem());
-        let properties = new Gtk.MenuItem({label: this._selectedItemsNum > 1 ? _('Common Properties') : _('Properties') });
+        let properties = new Gtk.MenuItem({ label: this._selectedItemsNum > 1 ? _('Common Properties') : _('Properties') });
         properties.connect('activate', () => this._onPropertiesClicked());
         this._menu.add(properties);
         this._menu.add(new Gtk.SeparatorMenuItem());
-        let showInFiles = new Gtk.MenuItem({label: this._selectedItemsNum > 1 ? _('Show All in Files') : _('Show in Files')});
+        let showInFiles = new Gtk.MenuItem({ label: this._selectedItemsNum > 1 ? _('Show All in Files') : _('Show in Files') });
         showInFiles.connect('activate', () => this._onShowInFilesClicked());
         this._menu.add(showInFiles);
-        if (this._isDirectory && this.file.get_path() != null && this._selectedItemsNum == 1) {
-            let openInTerminal = new Gtk.MenuItem({label: _('Open in Terminal')});
+        if (this._isDirectory && this.file.get_path() !== null && this._selectedItemsNum === 1) {
+            let openInTerminal = new Gtk.MenuItem({ label: _('Open in Terminal') });
             openInTerminal.connect('activate', () => this._onOpenTerminalClicked());
             this._menu.add(openInTerminal);
         }
         this._menu.show_all();
     }
 
-    _onOpenTerminalClicked () {
+    _onOpenTerminalClicked() {
         DesktopIconsUtil.launchTerminal(this.file.get_path(), null);
     }
 
     _onPressButton(actor, event) {
         let button = event.get_button()[1];
-        if (button == 3) {
-            if (!this._isSelected) {
+        if (button === 3) {
+            if (!this._isSelected)
                 this._desktopManager.selected(this, Enums.Selection.RIGHT_BUTTON);
-            }
+
             this._createMenu();
             this._menu.popup_at_pointer(event);
             if (this._actionOpenWith) {
-                let allowOpenWith = (this._selectedItemsNum > 0);
+                let allowOpenWith = this._selectedItemsNum > 0;
                 this._actionOpenWith.set_sensitive(allowOpenWith);
             }
             let allowCutCopyTrash = this._desktopManager.checkIfSpecialFilesAreSelected();
@@ -932,36 +947,36 @@ var FileItem = class {
                 this._actionCopy.set_sensitive(!allowCutCopyTrash);
             if (this._actionTrash)
                 this._actionTrash.set_sensitive(!allowCutCopyTrash);
-        } else if (button == 1) {
-            if (event.get_event_type() == Gdk.EventType.BUTTON_PRESS) {
-                let [a, x, y] = event.get_coords();
+        } else if (button === 1) {
+            if (event.get_event_type() === Gdk.EventType.BUTTON_PRESS) {
+                let [unused, x, y] = event.get_coords();
                 let state = event.get_state()[1];
                 this._primaryButtonPressed = true;
                 this._buttonPressInitialX = x;
                 this._buttonPressInitialY = y;
                 let shiftPressed = !!(state & Gdk.ModifierType.SHIFT_MASK);
                 let controlPressed = !!(state & Gdk.ModifierType.CONTROL_MASK);
-                if (shiftPressed || controlPressed) {
+                if (shiftPressed || controlPressed)
                     this._desktopManager.selected(this, Enums.Selection.WITH_SHIFT);
-                } else {
+                else
                     this._desktopManager.selected(this, Enums.Selection.ALONE);
-                }
+
             }
-            if ((event.get_event_type() == Gdk.EventType.DOUBLE_BUTTON_PRESS) && !Prefs.CLICK_POLICY_SINGLE) {
+            if (event.get_event_type() === Gdk.EventType.DOUBLE_BUTTON_PRESS && !Prefs.CLICK_POLICY_SINGLE)
                 this.doOpen();
-            }
+
         }
 
         return false;
     }
 
     _setSelectedStatus() {
-        if (this._isSelected && !this._styleContext.has_class('desktop-icons-selected')) {
+        if (this._isSelected && !this._styleContext.has_class('desktop-icons-selected'))
             this._styleContext.add_class('desktop-icons-selected');
-        }
-        if (!this._isSelected && this._styleContext.has_class('desktop-icons-selected')) {
+
+        if (!this._isSelected && this._styleContext.has_class('desktop-icons-selected'))
             this._styleContext.remove_class('desktop-icons-selected');
-        }
+
     }
 
     setSelected() {
@@ -984,15 +999,16 @@ var FileItem = class {
     }
 
     get isAllSelectable() {
-        return this._fileExtra == Enums.FileType.NONE;
+        return this._fileExtra === Enums.FileType.NONE;
     }
 
     get isDrive() {
-        return this._fileExtra == Enums.FileType.EXTERNAL_DRIVE;
+        return this._fileExtra === Enums.FileType.EXTERNAL_DRIVE;
     }
+
     _onReleaseButton(actor, event) {
         let button = event.get_button()[1];
-        if (button == 1) {
+        if (button === 1) {
             // primaryButtonPressed is TRUE only if the user has pressed the button
             // over an icon, and if (s)he has not started a drag&drop operation
             if (this._primaryButtonPressed) {
@@ -1001,38 +1017,38 @@ var FileItem = class {
                 let controlPressed = !!(event.get_state()[1] & Gdk.ModifierType.CONTROL_MASK);
                 if (!shiftPressed && !controlPressed) {
                     this._desktopManager.selected(this, Enums.Selection.RELEASE);
-                    if (Prefs.CLICK_POLICY_SINGLE) {
+                    if (Prefs.CLICK_POLICY_SINGLE)
                         this.doOpen();
-                    }
+
                 }
             }
         }
         return false;
     }
 
-    _onEnter(actor, event) {
-        if (!this._styleContext.has_class('file-item-hover')) {
+    _onEnter(unusedActor, unusedEvent) {
+        if (!this._styleContext.has_class('file-item-hover'))
             this._styleContext.add_class('file-item-hover');
-        }
+
         if (Prefs.CLICK_POLICY_SINGLE) {
             let window = this._eventBox.get_window();
-            if (window) {
-                window.set_cursor(Gdk.Cursor.new_from_name(Gdk.Display.get_default(), "hand"));
-            }
+            if (window)
+                window.set_cursor(Gdk.Cursor.new_from_name(Gdk.Display.get_default(), 'hand'));
+
         }
         return false;
     }
 
-    _onLeave(actor, event) {
+    _onLeave(unusedActor, unusedEvent) {
         this._primaryButtonPressed = false;
-        if (this._styleContext.has_class('file-item-hover')) {
+        if (this._styleContext.has_class('file-item-hover'))
             this._styleContext.remove_class('file-item-hover');
-        }
+
         if (Prefs.CLICK_POLICY_SINGLE) {
             let window = this._eventBox.get_window();
-            if (window) {
-                window.set_cursor(Gdk.Cursor.new_from_name(Gdk.Display.get_default(), "default"));
-            }
+            if (window)
+                window.set_cursor(Gdk.Cursor.new_from_name(Gdk.Display.get_default(), 'default'));
+
         }
         return false;
     }
@@ -1047,10 +1063,10 @@ var FileItem = class {
     }
 
     updateRubberband(x1, y1, x2, y2) {
-        if ((x2 < this._x1) || (x1 > this._x2) || (y2 < this._y1) || (y1 > this._y2)) {
-            if (this._touchedByRubberband) {
+        if (x2 < this._x1 || x1 > this._x2 || y2 < this._y1 || y1 > this._y2) {
+            if (this._touchedByRubberband)
                 this.unsetSelected();
-            }
+
         } else {
             this.setSelected();
             this._touchedByRubberband = true;
@@ -1063,7 +1079,7 @@ var FileItem = class {
 
     _onSetMetadataFileFinished(source, result) {
         try {
-            let [success, info] = source.set_attributes_finish(result);
+            let [unusedSuccess, unusedInfo] = source.set_attributes_finish(result);
         } catch (error) {
             if (!error.matches(Gio.IOErrorEnum, Gio.IOErrorEnum.CANCELLED))
                 log('Error setting metadata to desktop files ', error);
@@ -1073,7 +1089,7 @@ var FileItem = class {
     set savedCoordinates(pos) {
         try {
             let info = new Gio.FileInfo();
-            if (pos != null) {
+            if (pos !== null) {
                 this._savedCoordinates = [pos[0], pos[1]];
                 info.set_attribute_string('metadata::nautilus-icon-position', `${pos[0]},${pos[1]}`);
             } else {
@@ -1081,7 +1097,7 @@ var FileItem = class {
                 info.set_attribute_string('metadata::nautilus-icon-position', '');
             }
             this.file.set_attributes_from_info(info, Gio.FileQueryInfoFlags.NONE, null);
-        } catch(e) {
+        } catch (e) {
             print(`Failed to store the desktop coordinates for ${this.uri}: ${e}`);
         }
     }
@@ -1092,7 +1108,7 @@ var FileItem = class {
 
     set dropCoordinates(pos) {
         let info = new Gio.FileInfo();
-        if (pos != null) {
+        if (pos !== null) {
             this._dropCoordinates = [pos[0], pos[1]];
             info.set_attribute_string('metadata::nautilus-drop-position', `${pos[0]},${pos[1]}`);
         } else {
@@ -1111,7 +1127,7 @@ var FileItem = class {
     }
 
     set state(state) {
-        if (state == this._state)
+        if (state === this._state)
             return;
 
         this._state = state;
