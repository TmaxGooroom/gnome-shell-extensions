From: jungrae kim <jungrae_kim@tmax.co.kr>
Date: Mon, 5 Apr 2021 15:19:52 +0900
Subject: [feat] search : add search extension

 - add search extension

[IMS] N/A
---
 extensions/arc-menu/metadata.json                  |  15 -
 extensions/search/baseMenuLayout.js                | 309 +++++++
 extensions/search/constants.js                     |  43 +
 extensions/search/controller.js                    | 162 ++++
 extensions/search/convenience.js                   | 123 +++
 extensions/search/extension.js                     | 193 ++++
 extensions/search/menuButton.js                    | 368 ++++++++
 extensions/search/menuWidgets.js                   | 999 +++++++++++++++++++++
 extensions/search/meson.build                      |  23 +
 extensions/search/metadata.json.in                 |  11 +
 extensions/search/schemas/meson.build              |  14 +
 .../org.gnome.shell.extensions.search.gschema.xml  |  15 +
 extensions/search/search.js                        | 801 +++++++++++++++++
 extensions/search/searchMenuLayout.js              |  80 ++
 extensions/search/stylesheet.css                   | 298 ++++++
 extensions/search/utils.js                         | 169 ++++
 meson.build                                        |   3 +-
 17 files changed, 3610 insertions(+), 16 deletions(-)
 delete mode 100644 extensions/arc-menu/metadata.json
 create mode 100644 extensions/search/baseMenuLayout.js
 create mode 100644 extensions/search/constants.js
 create mode 100644 extensions/search/controller.js
 create mode 100644 extensions/search/convenience.js
 create mode 100644 extensions/search/extension.js
 create mode 100644 extensions/search/menuButton.js
 create mode 100644 extensions/search/menuWidgets.js
 create mode 100644 extensions/search/meson.build
 create mode 100644 extensions/search/metadata.json.in
 create mode 100644 extensions/search/schemas/meson.build
 create mode 100644 extensions/search/schemas/org.gnome.shell.extensions.search.gschema.xml
 create mode 100644 extensions/search/search.js
 create mode 100644 extensions/search/searchMenuLayout.js
 create mode 100644 extensions/search/stylesheet.css
 create mode 100644 extensions/search/utils.js

diff --git a/extensions/arc-menu/metadata.json b/extensions/arc-menu/metadata.json
deleted file mode 100644
index 6bc5e0a..0000000
--- a/extensions/arc-menu/metadata.json
+++ /dev/null
@@ -1,15 +0,0 @@
-{
-  "_generated": "Generated by SweetTooth, do not edit",
-  "description": "An Application Menu for GNOME  \n\nSupports GNOME shell 3.36, 3.38, and 40\nFor older GNOME shell versions go to: https://extensions.gnome.org/extension/1228/arc-menu/\n\nYou must have the following dependencies installed to use ArcMenu: https://gitlab.com/arcmenu/ArcMenu/-/wikis/ArcMenu-Dependencies\n\nIf you have an error after upgrading visit: https://gitlab.com/arcmenu/ArcMenu/-/wikis/Error-when-upgrading-ArcMenu-on-extensions.gnome.org\n\nPlease report any issues or concerns at: https://gitlab.com/arcmenu/ArcMenu",
-  "extension-id": "arcmenu",
-  "gettext-domain": "arcmenu",
-  "name": "ArcMenu",
-  "settings-schema": "org.gnome.shell.extensions.arcmenu",
-  "shell-version": [
-    "3.36",
-    "3.38"
-  ],
-  "url": "https://gitlab.com/arcmenu/ArcMenu",
-  "uuid": "arcmenu@tmax",
-  "version": 8
-}
diff --git a/extensions/search/baseMenuLayout.js b/extensions/search/baseMenuLayout.js
new file mode 100644
index 0000000..8899f87
--- /dev/null
+++ b/extensions/search/baseMenuLayout.js
@@ -0,0 +1,309 @@
+/*
+ * ArcMenu - A traditional application menu for GNOME 3
+ *
+ * ArcMenu Lead Developer and Maintainer
+ * Andrew Zaech https://gitlab.com/AndrewZaech
+ *
+ * ArcMenu Founder, Former Maintainer, and Former Graphic Designer
+ * LinxGem33 https://gitlab.com/LinxGem33 - (No Longer Active)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+const Me = imports.misc.extensionUtils.getCurrentExtension();
+
+const { Clutter, St } = imports.gi;
+const ArcSearch = Me.imports.search;
+const MW = Me.imports.menuWidgets;
+const Utils =  Me.imports.utils;
+
+// This class handles the core functionality of all the menu layouts.
+// Each menu layout extends this class.
+var BaseLayout = class {
+    constructor(menuButton) {
+        this.mainBox = menuButton.mainBox;
+        this.searchMenu = menuButton.searchMenu;
+        this.isRunning = true;
+        this._focusChild = null;
+        this.newSearch = new ArcSearch.SearchResults(this);
+
+        this._mainBoxKeyPressId = this.mainBox.connect('key-press-event', this._onMainBoxKeyPress.bind(this));
+
+        this.mainBox.vertical = false;
+        this.createLayout();
+        this.updateStyle();
+    }
+
+    resetSearch() {
+        this.searchBox.clear();
+        this.setDefaultMenuView();
+    }
+
+    setDefaultMenuView() {
+        this.searchBox.clear();
+        this.newSearch._reset();
+
+        this._clearActorsFromBox();
+
+        let appsScrollBoxAdj = this.applicationsScrollBox.get_vscroll_bar().get_adjustment();
+        appsScrollBoxAdj.set_value(0);
+
+        if (this.categoriesScrollBox) {
+            appsScrollBoxAdj = this.categoriesScrollBox.get_vscroll_bar().get_adjustment();
+            appsScrollBoxAdj.set_value(0);
+        }
+        if (this.shortcutsScrollBox) {
+            appsScrollBoxAdj = this.shortcutsScrollBox.get_vscroll_bar().get_adjustment();
+            appsScrollBoxAdj.set_value(0);
+        }
+        if (this.actionsScrollBox) {
+            appsScrollBoxAdj = this.actionsScrollBox.get_vscroll_bar().get_adjustment();
+            appsScrollBoxAdj.set_value(0);
+        }
+        if (this.vertSep != null)
+            this.vertSep.queue_repaint();
+    }
+
+    reload() {
+        let isReload = true;
+        this.destroy(isReload);
+        this.newSearch = new ArcSearch.SearchResults(this);
+        this.createLayout();
+        this.updateStyle();
+    }
+
+    updateStyle() {
+        this.searchBox.updateStyle();
+        this.newSearch.setStyle('');
+        this.searchBox._stEntry.remove_style_class_name('arc-search-entry');
+        this.searchBox._stEntry.add_style_class_name('default-search-entry');
+
+        if (this.actionsBox) {
+            this.actionsBox.get_children().forEach(actor => {
+                if (actor instanceof St.Button)
+                    actor.remove_style_class_name('arc-menu-action');
+
+            });
+        }
+    }
+
+    setActiveCategory(category, setActive = true) {
+        this.activeMenuItem = category;
+        if (setActive && this.searchMenu.isOpen)
+            this.activeMenuItem.actor.grab_key_focus();
+        else if (this.searchMenu.isOpen)
+            this.mainBox.grab_key_focus();
+    }
+
+    _clearActorsFromBox(box) {
+        if (!box) {
+            box = this.applicationsBox;
+            this.activeCategoryType = -1;
+        }
+        let parent = box.get_parent();
+        if (parent instanceof St.ScrollView) {
+            let scrollBoxAdj = parent.get_vscroll_bar().get_adjustment();
+            scrollBoxAdj.set_value(0);
+        }
+        let actors = box.get_children();
+        for (let i = 0; i < actors.length; i++) {
+            let actor = actors[i];
+            box.remove_actor(actor);
+        }
+    }
+
+    _onSearchBoxKeyPress(searchBox, event) {
+        let symbol = event.get_key_symbol();
+        if (!searchBox.isEmpty() && searchBox.hasKeyFocus()) {
+            if (symbol == Clutter.Up) {
+                this.newSearch.highlightDefault(false);
+                return Clutter.EVENT_PROPAGATE;
+            } else if (symbol == Clutter.Down) {
+                this.newSearch.highlightDefault(false);
+                return Clutter.EVENT_PROPAGATE;
+            }
+        }
+        return Clutter.EVENT_PROPAGATE;
+    }
+
+    _onSearchBoxKeyFocusIn(searchBox) {
+        if (!searchBox.isEmpty())
+            this.newSearch.highlightDefault(false);
+
+    }
+
+    _onSearchBoxChanged(searchBox, searchString) {
+        if (searchBox.isEmpty()) {
+            this.newSearch.setTerms(['']);
+            this.setDefaultMenuView();
+            this.newSearch.actor.hide();
+        } else {
+            this._clearActorsFromBox();
+            let appsScrollBoxAdj = this.applicationsScrollBox.get_vscroll_bar().get_adjustment();
+            appsScrollBoxAdj.set_value(0);
+            this.applicationsBox.add(this.newSearch.actor);
+
+            this.newSearch.actor.show();
+            this.newSearch.setTerms([searchString]);
+            this.newSearch.highlightDefault(true);
+
+            this.mainBox.grab_key_focus();
+        }
+    }
+
+    _onMainBoxKeyPress(actor, event) {
+        if (event.has_control_modifier()) {
+            if (this.searchBox)
+                this.searchBox.grabKeyFocus();
+            return Clutter.EVENT_PROPAGATE;
+        }
+
+        let symbol = event.get_key_symbol();
+        let key = event.get_key_unicode();
+
+        switch (symbol) {
+        case Clutter.KEY_BackSpace:
+            if (this.searchBox) {
+                if (!this.searchBox.hasKeyFocus() && !this.searchBox.isEmpty()) {
+                    this.searchBox.grabKeyFocus();
+                    let newText = this.searchBox.getText().slice(0, -1);
+                    this.searchBox.setText(newText);
+                }
+            }
+            return Clutter.EVENT_PROPAGATE;
+        case Clutter.KEY_Tab:
+        case Clutter.KEY_KP_Tab:
+            return Clutter.EVENT_PROPAGATE;
+        case Clutter.KEY_Up:
+        case Clutter.KEY_Down:
+        case Clutter.KEY_Left:
+        case Clutter.KEY_Right:
+            let direction;
+            if (symbol === Clutter.KEY_Down)
+                direction = St.DirectionType.DOWN;
+            if (symbol === Clutter.KEY_Right)
+                direction = St.DirectionType.RIGHT;
+            if (symbol === Clutter.KEY_Up)
+                direction = St.DirectionType.UP;
+            if (symbol === Clutter.KEY_Left)
+                direction = St.DirectionType.LEFT;
+
+            if (this.searchBox.hasKeyFocus() && this.newSearch._defaultResult &&
+                    this.newSearch.actor.get_parent()) {
+                this.newSearch.highlightDefault(!this.newSearch._highlightDefault);
+                this.newSearch._defaultResult.actor.grab_key_focus();
+                if (this.newSearch._highlightDefault)
+                    return Clutter.EVENT_STOP;
+                return actor.navigate_focus(global.stage.key_focus, direction, false);
+            } else if (global.stage.key_focus === this.mainBox ||
+                         global.stage.key_focus === this.searchBox.actor) {
+                this.activeMenuItem.actor.grab_key_focus();
+                return Clutter.EVENT_PROPAGATE;
+            }
+            return actor.navigate_focus(global.stage.key_focus, direction, false);
+        case Clutter.KEY_Return:
+        case Clutter.KEY_KP_Enter:
+            if (!this.searchBox.isEmpty()) {
+                if (this.searchBox.newSearch.getTopResult())
+                    this.searchBox.newSearch.getTopResult().activate(event);
+
+            }
+            return Clutter.EVENT_PROPAGATE;
+        case Clutter.KEY_Escape:
+            return Clutter.EVENT_PROPAGATE;
+        default:
+            if (key.length != 0) {
+                if (this.searchBox) {
+                    this.searchBox.grabKeyFocus();
+                    let newText = this.searchBox.getText() + key;
+                    this.searchBox.setText(newText);
+                }
+            }
+        }
+        return Clutter.EVENT_PROPAGATE;
+    }
+
+    destroy(isReload) {
+        if (this.searchBox) {
+            if (this._searchBoxChangedId > 0) {
+                this.searchBox.disconnect(this._searchBoxChangedId);
+                this._searchBoxChangedId = 0;
+            }
+            if (this._searchBoxKeyPressId > 0) {
+                this.searchBox.disconnect(this._searchBoxKeyPressId);
+                this._searchBoxKeyPressId = 0;
+            }
+            if (this._searchBoxKeyFocusInId > 0) {
+                this.searchBox.disconnect(this._searchBoxKeyFocusInId);
+                this._searchBoxKeyFocusInId = 0;
+            }
+        }
+
+        if (this.newSearch)
+            this.newSearch.destroy();
+
+
+        if (!isReload) {
+            if (this._mainBoxKeyPressId > 0) {
+                this.mainBox.disconnect(this._mainBoxKeyPressId);
+                this._mainBoxKeyPressId = 0;
+            }
+
+            this.isRunning = false;
+        }
+
+        this.mainBox.get_children().forEach(child => {
+            if (child && child !== undefined && child !== null)
+                child.destroy();
+        });
+    }
+
+    _createScrollBox(params) {
+        let scrollBox = new MW.ScrollView(params);
+        let panAction = new Clutter.PanAction({ interpolate: false });
+        panAction.connect('pan', action => {
+            this._blockActivateEvent = true;
+            this.onPan(action, scrollBox);
+        });
+        panAction.connect('gesture-cancel', action => this.onPanEnd(action, scrollBox));
+        panAction.connect('gesture-end', action => this.onPanEnd(action, scrollBox));
+        scrollBox.add_action(panAction);
+
+        scrollBox.set_policy(St.PolicyType.NEVER, St.PolicyType.AUTOMATIC);
+        scrollBox.clip_to_allocation = true;
+
+        return scrollBox;
+    }
+
+    _keyFocusIn(actor) {
+        if (this._focusChild == actor)
+            return;
+        this._focusChild = actor;
+        Utils.ensureActorVisibleInScrollView(actor);
+    }
+
+    onPan(action, scrollbox) {
+        let [dist_, dx_, dy] = action.get_motion_delta(0);
+        let adjustment = scrollbox.get_vscroll_bar().get_adjustment();
+        adjustment.value -=  dy;
+        return false;
+    }
+
+    onPanEnd(action, scrollbox) {
+        let velocity = -action.get_velocity(0)[2];
+        let adjustment = scrollbox.get_vscroll_bar().get_adjustment();
+        let endPanValue = adjustment.value + velocity * 2;
+        adjustment.value = endPanValue;
+    }
+};
diff --git a/extensions/search/constants.js b/extensions/search/constants.js
new file mode 100644
index 0000000..41843b6
--- /dev/null
+++ b/extensions/search/constants.js
@@ -0,0 +1,43 @@
+/*
+ * ArcMenu - A traditional application menu for GNOME 3
+ *
+ * ArcMenu Lead Developer and Maintainer
+ * Andrew Zaech https://gitlab.com/AndrewZaech
+ *
+ * ArcMenu Founder, Former Maintainer, and Former Graphic Designer
+ * LinxGem33 https://gitlab.com/LinxGem33 - (No Longer Active)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+const Me = imports.misc.extensionUtils.getCurrentExtension();
+const Gettext = imports.gettext.domain(Me.metadata['gettext-domain']);
+const _ = Gettext.gettext;
+
+var DIRECTION = {
+    UP: 0,
+    DOWN: 1,
+};
+
+var TooltipLocation = {
+    TOP_CENTERED: 0,
+    BOTTOM_CENTERED: 1,
+    BOTTOM: 2,
+};
+
+var GNU_SOFTWARE = '<span size="small">' +
+    'This program comes with absolutely no warranty.\n' +
+    'See the <a href="https://gnu.org/licenses/old-licenses/gpl-2.0.html">' +
+	'GNU General Public License, version 2 or later</a> for details.' +
+	'</span>';
diff --git a/extensions/search/controller.js b/extensions/search/controller.js
new file mode 100644
index 0000000..1576d44
--- /dev/null
+++ b/extensions/search/controller.js
@@ -0,0 +1,162 @@
+/*
+ * ArcMenu - A traditional application menu for GNOME 3
+ *
+ * ArcMenu Lead Developer and Maintainer
+ * Andrew Zaech https://gitlab.com/AndrewZaech
+ *
+ * ArcMenu Founder, Former Maintainer, and Former Graphic Designer
+ * LinxGem33 https://gitlab.com/LinxGem33 - (No Longer Active)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+const Me = imports.misc.extensionUtils.getCurrentExtension();
+
+const Constants = Me.imports.constants;
+const Gettext = imports.gettext.domain(Me.metadata['gettext-domain']);
+const Main = imports.ui.main;
+const MenuButton = Me.imports.menuButton;
+const _ = Gettext.gettext;
+
+var MenuSettingsController = class {
+    constructor(settings, settingsControllers, panel, panelIndex) {
+        this._settings = settings;
+        this.panel = panel;
+
+        Main.loadTheme();
+
+        this.currentMonitorIndex = 0;
+        this._activitiesButton = Main.panel.statusArea.activities;
+
+        this._menuButton = new MenuButton.MenuButton(settings, panel);
+
+        this._settingsControllers = settingsControllers;
+    }
+
+    _reload() {
+        this._menuButton.reload();
+    }
+
+    _setDefaultMenuView() {
+        this._menuButton.setDefaultMenuView();
+    }
+
+    toggleMenus() {
+        if (Main.overview.visible) {
+            Main.overview.hide();
+        } else if (global.dashToPanel) {
+            this.currentMonitor = Main.layoutManager.currentMonitor;
+            // close current menus that are open on monitors other than current monitor
+            if (this._settingsControllers.length > 1) {
+                for (let i = 0; i < this._settingsControllers.length; i++) {
+                    let actor = this._settingsControllers[i]._menuButton.actor;
+                    let monitorForActor = Main.layoutManager.findMonitorForActor(actor);
+                    if (this.currentMonitor == monitorForActor)
+                        this.currentMonitorIndex = i;
+
+                    else if (this._settingsControllers[i]._menuButton.searchMenu.isOpen)
+                        this._settingsControllers[i]._menuButton.toggleMenu();
+
+                }
+                // open the current monitors menu
+                this._settingsControllers[this.currentMonitorIndex]._menuButton.toggleMenu();
+            } else {
+                this._menuButton.toggleMenu();
+            }
+        } else {
+            this._menuButton.toggleMenu();
+        }
+    }
+
+    _updateStyle() {
+        this._menuButton.updateStyle();
+    }
+
+    _updateMenuHeight() {
+        this._menuButton.updateHeight();
+    }
+
+    // Get the current position of the menu button and its associated position order
+    _getMenuPositionTuple() {
+        return ['left', 1];
+    }
+
+    // Check if the activities button is present on the main panel
+    _isActivitiesButtonPresent() {
+        // Thanks to lestcape @github.com for the refinement of this method.
+        return this._activitiesButton &&
+            this._activitiesButton.container &&
+            this.panel._leftBox.contains(this._activitiesButton.container);
+    }
+
+    // Remove the activities button from the main panel
+    _removeActivitiesButtonFromMainPanel() {
+        if (this._isActivitiesButtonPresent())
+            this.panel._leftBox.remove_child(this._activitiesButton.container);
+
+    }
+
+    // Add or restore the activities button on the main panel
+    _addActivitiesButtonToMainPanel() {
+        if (this.panel == Main.panel && !this._isActivitiesButtonPresent()) {
+            // Retsore the activities button at the default position
+            let parent = this._activitiesButton.container.get_parent();
+            if (!parent)
+                this.panel._leftBox.insert_child_at_index(this._activitiesButton.container, 0);
+        }
+    }
+
+    // Add the menu button to the main panel
+    _addMenuButtonToMainPanel() {
+        let [menuPosition, order] = this._getMenuPositionTuple();
+        this.panel.addToStatusArea('Search', this._menuButton, order, menuPosition);
+    }
+
+    // Remove the menu button from the main panel
+    _removeMenuButtonFromMainPanel() {
+        this.panel.menuManager.removeMenu(this._menuButton.searchMenu);
+        this.panel.statusArea['Search'] = null;
+    }
+
+    // Enable the menu button
+    enableButton(index) {
+        this._removeActivitiesButtonFromMainPanel();
+        this._addMenuButtonToMainPanel();
+
+        this._menuButton.initiate();
+    }
+
+    // Disable the menu button
+    _disableButton() {
+        this._removeMenuButtonFromMainPanel();
+        this._addActivitiesButtonToMainPanel();
+        this._menuButton.destroy();
+    }
+
+    _isButtonEnabled() {
+        return this.panel.statusArea['Search'] !== null;
+    }
+
+    // Destroy this object
+    destroy() {
+        if (this.panel == undefined)
+            this._menuButton.destroy();
+        else if (this._isButtonEnabled())
+            this._disableButton();
+
+
+        this._settings = null;
+        this._activitiesButton = null;
+        this._menuButton = null;
+    }
+};
diff --git a/extensions/search/convenience.js b/extensions/search/convenience.js
new file mode 100644
index 0000000..b22ca77
--- /dev/null
+++ b/extensions/search/convenience.js
@@ -0,0 +1,123 @@
+/* -*- mode: js; js-basic-offset: 4; indent-tabs-mode: nil -*- */
+/*
+  Copyright (c) 2011-2012, Giovanni Campagna <scampa.giovanni@gmail.com>
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the GNOME nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY
+  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+const Gettext = imports.gettext;
+const Gio = imports.gi.Gio;
+
+const Config = imports.misc.config;
+const ExtensionUtils = imports.misc.extensionUtils;
+
+/**
+ * initTranslations:
+ * @domain: (optional): the gettext domain to use
+ *
+ * Initialize Gettext to load translations from extensionsdir/locale.
+ * If @domain is not provided, it will be taken from metadata['gettext-domain']
+ */
+function initTranslations(domain) {
+    let extension = ExtensionUtils.getCurrentExtension();
+
+    domain = domain || extension.metadata['gettext-domain'];
+
+    // check if this extension was built with "make zip-file", and thus
+    // has the locale files in a subfolder
+    // otherwise assume that extension has been installed in the
+    // same prefix as gnome-shell
+    let localeDir = extension.dir.get_child('locale');
+    if (localeDir.query_exists(null))
+        Gettext.bindtextdomain(domain, localeDir.get_path());
+    else
+        Gettext.bindtextdomain(domain, Config.LOCALEDIR);
+}
+
+/**
+ * getSettings:
+ * @schema: (optional): the GSettings schema id
+ *
+ * Builds and return a GSettings schema for @schema, using schema files
+ * in extensionsdir/schemas. If @schema is not provided, it is taken from
+ * metadata['settings-schema'].
+ */
+function getSettings(schema) {
+    let extension = ExtensionUtils.getCurrentExtension();
+
+    schema = schema || extension.metadata['settings-schema'];
+
+    const GioSSS = Gio.SettingsSchemaSource;
+
+    // check if this extension was built with "make zip-file", and thus
+    // has the schema files in a subfolder
+    // otherwise assume that extension has been installed in the
+    // same prefix as gnome-shell (and therefore schemas are available
+    // in the standard folders)
+    let schemaDir = extension.dir.get_child('schemas');
+    let schemaSource;
+    if (schemaDir.query_exists(null)) {
+        schemaSource = GioSSS.new_from_directory(schemaDir.get_path(),
+            GioSSS.get_default(),
+            false);
+    } else {
+        schemaSource = GioSSS.get_default();
+    }
+
+    let schemaObj = schemaSource.lookup(schema, true);
+    if (!schemaObj) {
+        throw new Error(`Schema ${schema} could not be found for extension ${
+            extension.metadata.uuid}. Please check your installation.`);
+    }
+
+    return new Gio.Settings({ settings_schema: schemaObj });
+}
+function getDTPSettings(schema, extension) {
+
+    schema = schema || extension.metadata['settings-schema'];
+
+    const GioSSS = Gio.SettingsSchemaSource;
+
+    // check if this extension was built with "make zip-file", and thus
+    // has the schema files in a subfolder
+    // otherwise assume that extension has been installed in the
+    // same prefix as gnome-shell (and therefore schemas are available
+    // in the standard folders)
+    let schemaDir = extension.dir.get_child('schemas');
+    let schemaSource;
+    if (schemaDir.query_exists(null)) {
+        schemaSource = GioSSS.new_from_directory(schemaDir.get_path(),
+            GioSSS.get_default(),
+            false);
+    } else {
+        schemaSource = GioSSS.get_default();
+    }
+
+    let schemaObj = schemaSource.lookup(schema, true);
+    if (!schemaObj) {
+        throw new Error(`Schema ${schema} could not be found for extension ${
+            extension.metadata.uuid}. Please check your installation.`);
+    }
+
+    return new Gio.Settings({ settings_schema: schemaObj });
+}
diff --git a/extensions/search/extension.js b/extensions/search/extension.js
new file mode 100644
index 0000000..445d1e3
--- /dev/null
+++ b/extensions/search/extension.js
@@ -0,0 +1,193 @@
+/*
+ * ArcMenu - A traditional application menu for GNOME 3
+ *
+ * ArcMenu Lead Developer and Maintainer
+ * Andrew Zaech https://gitlab.com/AndrewZaech
+ *
+ * ArcMenu Founder, Former Maintainer, and Former Graphic Designer
+ * LinxGem33 https://gitlab.com/LinxGem33 - (No Longer Active)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+const Me = imports.misc.extensionUtils.getCurrentExtension();
+
+const { GLib, Gio, St } = imports.gi;
+const Constants = Me.imports.constants;
+const Controller = Me.imports.controller;
+const Convenience = Me.imports.convenience;
+const Main = imports.ui.main;
+const Util = imports.misc.util;
+const Utils = Me.imports.utils;
+
+
+// Initialize panel button variables
+let settings;
+let settingsControllers;
+let extensionChangedId;
+let dockToggleID;
+let dockExtension;
+
+// Initialize menu language translations
+function init(metadata) {
+    Convenience.initTranslations(Me.metadata['gettext-domain']);
+}
+
+// Enable the extension
+function enable() {
+    if (imports.gi.Meta.is_wayland_compositor())
+        Me.metadata.isWayland = true;
+    else
+        Me.metadata.isWayland = false;
+
+    settings = Convenience.getSettings(Me.metadata['settings-schema']);
+    settings.connect('changed::multi-monitor', () => _onMultiMonitorChange());
+    settingsControllers = [];
+
+    if (global.dashToPanel)
+        _enableButtons();
+
+
+    // dash to panel might get enabled after Search
+    extensionChangedId = Main.extensionManager.connect('extension-state-changed', (data, extension) => {
+        if (extension.uuid === 'dash-to-panel@tos-shell-extensions') {
+            if (extension.state === 1) {
+                _connectDtpSignals();
+                _enableButtons();
+            } else if (extension.state === 2) {
+                _disconnectDtpSignals();
+                for (let i = settingsControllers.length - 1; i >= 0; --i) {
+                    let sc = settingsControllers[i];
+                    _disableButton(sc, 1);
+                }
+            }
+        }
+        /*
+        if ((extension.uuid === "dash-to-dock@micxgx.gmail.com" || extension.uuid === "ubuntu-dock@ubuntu.com")) {
+            _disconnectDtdSignals();
+            if(extension.state === 1){
+                for (let i = settingsControllers.length - 1; i >= 0; --i) {
+                    let sc = settingsControllers[i];
+                    _disableButton(sc, 1);
+                }
+                _enableButtons();
+                _connectDtdSignals();
+            }
+        }
+        */
+    });
+
+    // listen to dash to panel if they are compatible and already enabled
+    _connectDtpSignals();
+}
+
+// Disable the extension
+function disable() {
+    if (extensionChangedId > 0) {
+        Main.extensionManager.disconnect(extensionChangedId);
+        extensionChangedId = 0;
+    }
+
+    _disconnectDtpSignals();
+
+    for (let i = settingsControllers.length - 1; i >= 0; --i) {
+        let sc = settingsControllers[i];
+        _disableButton(sc, 1);
+    }
+    settingsControllers = null;
+
+    settings.run_dispose();
+    settings = null;
+}
+
+function _connectDtpSignals() {
+    if (global.dashToPanel)
+        global.dashToPanel._amPanelsCreatedId = global.dashToPanel.connect('panels-created', () => _enableButtons());
+
+}
+
+function _disconnectDtpSignals() {
+    if (global.dashToPanel && global.dashToPanel._amPanelsCreatedId) {
+        global.dashToPanel.disconnect(global.dashToPanel._amPanelsCreatedId);
+        delete global.dashToPanel._amPanelsCreatedId;
+    }
+}
+
+function _onMultiMonitorChange() {
+    for (let i = settingsControllers.length - 1; i >= 0; --i) {
+        let sc = settingsControllers[i];
+        _disableButton(sc, 1);
+    }
+    _enableButtons();
+}
+
+function _getDockExtensions() {
+    let dashToDock = Main.extensionManager.lookup('dash-to-dock@micxgx.gmail.com');
+    let ubuntuDash = Main.extensionManager.lookup('ubuntu-dock@ubuntu.com');
+    let dock;
+    if (dashToDock && dashToDock.stateObj && dashToDock.stateObj.dockManager)
+        dock = dashToDock;
+
+    if (ubuntuDash && ubuntuDash.stateObj && ubuntuDash.stateObj.dockManager)
+        dock = ubuntuDash;
+
+    return dock;
+}
+
+function _enableButtons() {
+    let multiMonitor = settings.get_boolean('multi-monitor');
+    dockExtension = _getDockExtensions();
+    if (!dockExtension) {
+        let panelArray = global.dashToPanel ? global.dashToPanel.panels.map(pw => pw) : [Main.panel];
+        let iterLength = multiMonitor ? panelArray.length : 1;
+        for (var index = 0; index < iterLength; index++) {
+            let panel = global.dashToPanel ? panelArray[index].panel : panelArray[index];
+            let panelParent = panelArray[index];
+
+            let isPrimaryStandAlone = global.dashToPanel ? 'isPrimary' in panelParent && panelParent.isPrimary && panelParent.isStandalone : false;
+
+            if (isPrimaryStandAlone)
+                panel = Main.panel;
+
+
+            if (panel.statusArea['Search'])
+                continue;
+            else if (settingsControllers[index])
+                _disableButton(settingsControllers[index], 1);
+
+            let settingsController = new Controller.MenuSettingsController(
+                settings, settingsControllers, panel, index);
+
+            if (global.dashToPanel)
+                panel._amDestroyId = panel.connect('destroy', () => extensionChangedId ? _disableButton(settingsController, 1) : null);
+
+
+            settingsController.enableButton();
+            settingsControllers.push(settingsController);
+        }
+    }
+}
+
+function _disableButton(controller, remove) {
+    if (controller.panel._amDestroyId) {
+        controller.panel.disconnect(controller.panel._amDestroyId);
+        delete controller.panel._amDestroyId;
+    }
+
+    controller.destroy();
+
+    if (remove)
+        settingsControllers.splice(settingsControllers.indexOf(controller), 1);
+
+}
diff --git a/extensions/search/menuButton.js b/extensions/search/menuButton.js
new file mode 100644
index 0000000..781850c
--- /dev/null
+++ b/extensions/search/menuButton.js
@@ -0,0 +1,368 @@
+/*
+ * ArcMenu - A traditional application menu for GNOME 3
+ *
+ * ArcMenu Lead Developer and Maintainer
+ * Andrew Zaech https://gitlab.com/AndrewZaech
+ *
+ * ArcMenu Founder, Former Maintainer, and Former Graphic Designer
+ * LinxGem33 https://gitlab.com/LinxGem33 - (No Longer Active)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+const Me = imports.misc.extensionUtils.getCurrentExtension();
+
+const { Clutter, GLib, GObject, Shell, St } = imports.gi;
+const appSys = Shell.AppSystem.get_default();
+const Constants = Me.imports.constants;
+const Convenience = Me.imports.convenience;
+const Gettext = imports.gettext.domain(Me.metadata['gettext-domain']);
+const Main = imports.ui.main;
+const MW = Me.imports.menuWidgets;
+const PanelMenu = imports.ui.panelMenu;
+const PopupMenu = imports.ui.popupMenu;
+const SearchMenuLayout = Me.imports.searchMenuLayout;
+const Util = imports.misc.util;
+const Utils = Me.imports.utils;
+const _ = Gettext.gettext;
+
+var DASH_TO_PANEL_UUID = 'dash-to-panel@tos-shell-extensions';
+var DASH_TO_DOCK_UUID = 'dash-to-dock@micxgx.gmail.com';
+var UBUNTU_DOCK_UUID = 'ubuntu-dock@ubuntu.com';
+
+var MenuButton = GObject.registerClass(class Arc_Menu_MenuButton extends PanelMenu.Button {
+    _init(settings, panel, dashIndex) {
+        super._init(0.5, null, true);
+        this._settings = settings;
+        this._panel = panel;
+        this.menu.destroy();
+        this.add_style_class_name('arc-menu-panel-menu');
+        this.tooltipShowing = false;
+        this.tooltipHidingID = null;
+        this.tooltipShowingID = null;
+
+        let menuManagerParent = this._panel;
+
+        // Create Main Menus - SearchMenu
+        this.searchMenu = new SearchMenu(this, 0.5, St.Side.TOP);
+        this.searchMenu.connect('open-state-changed', this._onOpenStateChanged.bind(this));
+
+        this.menuManager = new PopupMenu.PopupMenuManager(menuManagerParent);
+        this.menuManager._changeMenu = menu => {};
+        this.menuManager.addMenu(this.searchMenu);
+
+        // Context Menus for applications and other menu items
+        this.contextMenuManager = new PopupMenu.PopupMenuManager(this);
+        this.contextMenuManager._changeMenu = menu => {};
+        this.contextMenuManager._onMenuSourceEnter = menu => {
+            if (this.contextMenuManager.activeMenu && this.contextMenuManager.activeMenu != menu)
+                return Clutter.EVENT_STOP;
+
+            return Clutter.EVENT_PROPAGATE;
+        };
+
+        // Sub Menu Manager - Control all other popup menus
+        this.subMenuManager = new PopupMenu.PopupMenuManager(this);
+        this.subMenuManager._changeMenu = menu => {};
+        this.x_expand = false;
+        this.y_expand = false;
+    }
+
+    initiate() {
+        // Dash to Panel Integration
+        this.dashToPanel = Main.extensionManager.lookup(DASH_TO_PANEL_UUID);
+        this.extensionChangedId = Main.extensionManager.connect('extension-state-changed', (data, extension) => {
+            if (extension.uuid === DASH_TO_PANEL_UUID && extension.state === 1) {
+                this.dashToPanel = Main.extensionManager.lookup(DASH_TO_PANEL_UUID);
+                this.syncWithDashToPanel();
+            }
+            if (extension.uuid === DASH_TO_PANEL_UUID && extension.state === 2) {
+                this.dashToPanel = null;
+                if (this.dtpPostionChangedID > 0 && this.extensionSettingsItem) {
+                    this.extensionSettingsItem.disconnect(this.dtpPostionChangedID);
+                    this.dtpPostionChangedID = 0;
+                }
+            }
+        });
+        if (this.dashToPanel && this.dashToPanel.stateObj)
+            this.syncWithDashToPanel();
+
+
+        this._iconThemeChangedId = St.TextureCache.get_default().connect('icon-theme-changed', this.reload.bind(this));
+        this._monitorsChangedId = Main.layoutManager.connect('monitors-changed', () => {
+            this.updateHeight();
+        });
+
+        // Create Basic Layout
+        this.createLayoutID = GLib.timeout_add(0, 100, () => {
+            this.createMenuLayout();
+            this.createLayoutID = null;
+            return GLib.SOURCE_REMOVE;
+        });
+    }
+
+    syncWithDashToPanel() {
+        if (global.dashToPanel) {
+            global.dashToPanel.panels.forEach(p => {
+                if (p.panel === this._panel)
+                    this.dtpPanel = p;
+
+            });
+        }
+    }
+
+    createMenuLayout() {
+        this.section = new PopupMenu.PopupMenuSection();
+        this.searchMenu.addMenuItem(this.section);
+        this.mainBox = new St.BoxLayout({
+            vertical: false,
+            x_expand: true,
+            y_expand: true,
+            x_align: Clutter.ActorAlign.FILL,
+            y_align: Clutter.ActorAlign.FILL,
+        });
+        this.mainBox._delegate = this.mainBox;
+
+        let monitorIndex = Main.layoutManager.findIndexForActor(this.actor);
+        let scaleFactor = Main.layoutManager.monitors[monitorIndex].geometry_scale;
+        let monitorWorkArea = Main.layoutManager.getWorkAreaForMonitor(monitorIndex);
+        let height = Math.round(550 / scaleFactor);
+        if (height > monitorWorkArea.height)
+            height = monitorWorkArea.height * 8 / 10;
+
+
+        this.mainBox.style = `height: ${height}px`;
+        this.section.actor.add_actor(this.mainBox);
+        this.MenuLayout = new SearchMenuLayout.createMenu(this);
+        this.add_actor(this.MenuLayout.searchBox.actor);
+        this.updateStyle();
+    }
+
+    updateStyle() {
+        this.searchMenu.actor.style_class = 'popup-menu-boxpointer';
+        this.searchMenu.actor.add_style_class_name('popup-menu');
+
+        this.searchMenu.actor.style = '-arrow-base:0px; -arrow-rise:0px; -boxpointer-gap: 0px;';
+        this.searchMenu.box.style = 'margin:0px;';
+
+        if (this.MenuLayout)
+            this.MenuLayout.updateStyle();
+    }
+
+    updateSearch() {
+        if (this.MenuLayout)
+            this.MenuLayout.updateSearch();
+    }
+
+    setSensitive(sensitive) {
+        this.reactive = sensitive;
+        this.can_focus = sensitive;
+        this.track_hover = sensitive;
+    }
+
+    vfunc_event(event) {
+        if (event.type() === Clutter.EventType.BUTTON_PRESS) {
+            if (event.get_button() == 1)
+                this.toggleMenu();
+
+        } else if (event.type() === Clutter.EventType.TOUCH_BEGIN) {
+            this.toggleMenu();
+        }
+        return Clutter.EVENT_PROPAGATE;
+    }
+
+    toggleMenu() {
+        if (this.contextMenuManager.activeMenu)
+            this.contextMenuManager.activeMenu.toggle();
+        if (this.subMenuManager.activeMenu)
+            this.subMenuManager.activeMenu.toggle();
+
+        if (this.dtpPanel && !this.searchMenu.isOpen) {
+            if (this.dtpPanel.intellihide && this.dtpPanel.intellihide.enabled) {
+                this.dtpPanel.intellihide._revealPanel(true);
+            } else if (!this.dtpPanel.panelBox.visible) {
+                this.dtpPanel.panelBox.visible = true;
+                this.dtpNeedsHiding = true;
+            }
+        } else if (this._panel === Main.panel && !Main.layoutManager.panelBox.visible && !this.searchMenu.isOpen) {
+            Main.layoutManager.panelBox.visible = true;
+            this.mainPanelNeedsHiding = true;
+        }
+
+        //           this.searchMenu.toggle();
+
+        if (this.searchMenu.isOpen)
+            this.mainBox.grab_key_focus();
+
+    }
+
+    getActiveMenu() {
+        if (this.contextMenuManager.activeMenu)
+            return this.contextMenuManager.activeMenu;
+        else if (this.subMenuManager.activeMenu)
+            return this.subMenuManager.activeMenu;
+        else if (this.searchMenu.isOpen)
+            return this.searchMenu;
+        else
+            return null;
+    }
+
+    updateHeight() {
+        let monitorIndex = Main.layoutManager.findIndexForActor(this.actor);
+        let scaleFactor = Main.layoutManager.monitors[monitorIndex].geometry_scale;
+        let monitorWorkArea = Main.layoutManager.getWorkAreaForMonitor(monitorIndex);
+        let height = Math.round(550 / scaleFactor);
+
+        if (height > monitorWorkArea.height)
+            height = monitorWorkArea.height * 8 / 10;
+
+
+        if (this.MenuLayout)
+            this.mainBox.style = `height: ${height}px`;
+
+        this.reload();
+    }
+
+    _onDestroy() {
+        if (this._iconThemeChangedId) {
+            St.TextureCache.get_default().disconnect(this._iconThemeChangedId);
+            this._iconThemeChangedId = null;
+        }
+        if (this._monitorsChangedId) {
+            Main.layoutManager.disconnect(this._monitorsChangedId);
+            this._monitorsChangedId = null;
+        }
+        if (this.createLayoutID) {
+            GLib.source_remove(this.createLayoutID);
+            this.createLayoutID = null;
+        }
+        if (this.tooltipShowingID) {
+            GLib.source_remove(this.tooltipShowingID);
+            this.tooltipShowingID = null;
+        }
+        if (this.tooltipHidingID) {
+            GLib.source_remove(this.tooltipHidingID);
+            this.tooltipHidingID = null;
+        }
+        if (this.MenuLayout)
+            this.MenuLayout.destroy();
+
+        if (this.extensionChangedId) {
+            Main.extensionManager.disconnect(this.extensionChangedId);
+            this.extensionChangedId = null;
+        }
+        if (this.dtpPostionChangedID && this.extensionSettingsItem) {
+            this.extensionSettingsItem.disconnect(this.dtpPostionChangedID);
+            this.dtpPostionChangedID = null;
+        }
+        if (this.searchMenu)
+            this.searchMenu.destroy();
+
+        super._onDestroy();
+    }
+
+    reload() {
+        if (this.MenuLayout)
+            this.MenuLayout.needsReload = true;
+    }
+
+    resetSearch() {
+        if (this.MenuLayout)
+            this.MenuLayout.resetSearch();
+    }
+
+    setDefaultMenuView() {
+        if (this.MenuLayout)
+            this.MenuLayout.setDefaultMenuView();
+    }
+
+    _onOpenStateChanged(menu, open) {
+        if (open) {
+            this.add_style_pseudo_class('active');
+
+            if (Main.panel.menuManager && Main.panel.menuManager.activeMenu)
+                Main.panel.menuManager.activeMenu.toggle();
+        } else {
+            if (this.dtpPanel && this.dtpNeedsRelease) {
+                this.dtpNeedsRelease = false;
+                this.dtpPanel.intellihide ? this.dtpPanel.intellihide.release(2) : null;
+            }
+            if (this.dtpPanel && this.dtpNeedsHiding) {
+                this.dtpNeedsHiding = false;
+                this.dtpPanel.panelBox.visible = false;
+            }
+            if (this.mainPanelNeedsHiding) {
+                Main.layoutManager.panelBox.visible = false;
+                this.mainPanelNeedsHiding = false;
+            }
+            if (!this.searchMenu.isOpen)
+                this.remove_style_pseudo_class('active');
+
+        }
+    }
+});
+
+var SearchMenu = class Search_Menu_SearchMenu extends PopupMenu.PopupMenu {
+    constructor(sourceActor, arrowAlignment, arrowSide) {
+        super(sourceActor, arrowAlignment, arrowSide);
+        this._settings = sourceActor._settings;
+        this._menuButton = sourceActor;
+        Main.uiGroup.add_actor(this.actor);
+        this.actor.hide();
+        this._menuCloseID = this.connect('menu-closed', () => this._onCloseEvent());
+        this.connect('destroy', () => this._onDestroy());
+    }
+
+    open(animation) {
+        if (this._menuButton.dtpPanel && !this._menuButton.dtpNeedsRelease) {
+            this._menuButton.dtpNeedsRelease = true;
+            this._menuButton.dtpPanel.intellihide ? this._menuButton.dtpPanel.intellihide.revealAndHold(2) : null;
+        }
+        this._onOpenEvent();
+        super.open(animation);
+    }
+
+    close(animation) {
+        if (this._menuButton.contextMenuManager.activeMenu)
+            this._menuButton.contextMenuManager.activeMenu.toggle();
+        if (this._menuButton.subMenuManager.activeMenu)
+            this._menuButton.subMenuManager.activeMenu.toggle();
+        super.close(animation);
+    }
+
+    _onOpenEvent() {
+        this._menuButton.searchMenu.actor._muteInput = false;
+        if (this._menuButton.MenuLayout && this._menuButton.MenuLayout.needsReload) {
+            this._menuButton.MenuLayout.reload();
+            this._menuButton.MenuLayout.needsReload = false;
+            this._menuButton.setDefaultMenuView();
+        }
+    }
+
+    _onCloseEvent() {
+        if (this._menuButton.MenuLayout && this._menuButton.MenuLayout.isRunning) {
+            if (this._menuButton.MenuLayout.needsReload)
+                this._menuButton.MenuLayout.reload();
+            this._menuButton.MenuLayout.needsReload = false;
+            this._menuButton.setDefaultMenuView();
+        }
+    }
+
+    _onDestroy() {
+        if (this._menuCloseID) {
+            this.disconnect(this._menuCloseID);
+            this._menuCloseID = null;
+        }
+    }
+};
diff --git a/extensions/search/menuWidgets.js b/extensions/search/menuWidgets.js
new file mode 100644
index 0000000..9384546
--- /dev/null
+++ b/extensions/search/menuWidgets.js
@@ -0,0 +1,999 @@
+/*
+ * ArcMenu - A traditional application menu for GNOME 3
+ *
+ * ArcMenu Lead Developer and Maintainer
+ * Andrew Zaech https://gitlab.com/AndrewZaech
+ *
+ * ArcMenu Founder, Former Maintainer, and Former Graphic Designer
+ * LinxGem33 https://gitlab.com/LinxGem33 - (No Longer Active)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+// Import Libraries
+const Me = imports.misc.extensionUtils.getCurrentExtension();
+const { Atk, Clutter, Gio, GLib, GMenu, GObject, Gtk, Shell, St } = imports.gi;
+const AccountsService = imports.gi.AccountsService;
+const AppFavorites = imports.ui.appFavorites;
+const Constants = Me.imports.constants;
+const Dash = imports.ui.dash;
+const Gettext = imports.gettext.domain(Me.metadata['gettext-domain']);
+const Main = imports.ui.main;
+const PopupMenu = imports.ui.popupMenu;
+const Signals = imports.signals;
+const Util = imports.misc.util;
+const Utils =  Me.imports.utils;
+const _ = Gettext.gettext;
+
+const SWITCHEROO_BUS_NAME = 'net.hadess.SwitcherooControl';
+const SWITCHEROO_OBJECT_PATH = '/net/hadess/SwitcherooControl';
+
+const SwitcherooProxyInterface = '<node> \
+<interface name="net.hadess.SwitcherooControl"> \
+  <property name="HasDualGpu" type="b" access="read"/> \
+  <property name="NumGPUs" type="u" access="read"/> \
+  <property name="GPUs" type="aa{sv}" access="read"/> \
+</interface> \
+</node>';
+
+const SwitcherooProxy = Gio.DBusProxy.makeProxyWrapper(SwitcherooProxyInterface);
+
+// Menu Size variables
+const LARGE_ICON_SIZE = 34;
+const MEDIUM_ICON_SIZE = 25;
+const INDICATOR_ICON_SIZE = 18;
+const SMALL_ICON_SIZE = 16;
+const USER_AVATAR_SIZE = 28;
+
+var ApplicationContextMenu = class Arc_Menu_ApplicationContextMenu extends PopupMenu.PopupMenu {
+    constructor(actor, app, menuLayout) {
+        super(actor, 0.0, St.Side.TOP);
+        this._menuLayout = menuLayout;
+        this._settings = menuLayout._settings;
+        this._menuButton = menuLayout.menuButton;
+        this._app = app;
+        this._boxPointer.setSourceAlignment(.20);
+        this._boxPointer._border.queue_repaint();
+        this.blockSourceEvents = true;
+        this.discreteGpuAvailable = false;
+        Gio.DBus.system.watch_name(SWITCHEROO_BUS_NAME,
+            Gio.BusNameWatcherFlags.NONE,
+            this._switcherooProxyAppeared.bind(this),
+            () => {
+                this._switcherooProxy = null;
+                this._updateDiscreteGpuAvailable();
+            });
+        Main.uiGroup.add_actor(this.actor);
+        this._menuLayout.contextMenuManager.addMenu(this);
+    }
+
+    centerBoxPointerPosition() {
+        this._boxPointer.setSourceAlignment(.50);
+        this._arrowAlignment = .5;
+        this._boxPointer._border.queue_repaint();
+    }
+
+    rightBoxPointerPosition() {
+        this._arrowSide = St.Side.LEFT;
+        this._boxPointer._arrowSide = St.Side.LEFT;
+        this._boxPointer._userArrowSide = St.Side.LEFT;
+        this._boxPointer.setSourceAlignment(.50);
+        this._arrowAlignment = .5;
+        this._boxPointer._border.queue_repaint();
+    }
+
+    set isPinnedApp(isPinnedApp) {
+        this._isPinnedApp = isPinnedApp;
+    }
+
+    set path(path) {
+        this._path = path;
+    }
+
+    _updateDiscreteGpuAvailable() {
+        if (!this._switcherooProxy)
+            this.discreteGpuAvailable = false;
+        else
+            this.discreteGpuAvailable = this._switcherooProxy.HasDualGpu;
+    }
+
+    _switcherooProxyAppeared() {
+        this._switcherooProxy = new SwitcherooProxy(Gio.DBus.system, SWITCHEROO_BUS_NAME, SWITCHEROO_OBJECT_PATH,
+            (proxy, error) => {
+                if (error) {
+                    log(error.message);
+                    return;
+                }
+                this._updateDiscreteGpuAvailable();
+            });
+    }
+
+    closeMenus() {
+        this.close();
+        this._menuLayout.searchMenu.toggle();
+    }
+
+    open(animate) {
+        if (this._menuButton.tooltipShowingID) {
+            GLib.source_remove(this._menuButton.tooltipShowingID);
+            this._menuButton.tooltipShowingID = null;
+            this._menuButton.tooltipShowing = false;
+        }
+        if (this.sourceActor.tooltip) {
+            this.sourceActor.tooltip.hide();
+            this._menuButton.tooltipShowing = false;
+        }
+
+        super.open(animate);
+    }
+
+    close(animate) {
+        if (this.isOpen) {
+            this.sourceActor.sync_hover();
+            super.close(animate);
+        }
+    }
+
+    redisplay() {
+        this.removeAll();
+        this.actor.style_class = 'popup-menu-boxpointer';
+        this.actor.add_style_class_name('popup-menu');
+
+        if (this._app instanceof Shell.App) {
+            if (this._path != undefined) {
+                this._newWindowMenuItem = this._appendMenuItem(_('Open Folder Location'));
+                this._newWindowMenuItem.connect('activate', () => {
+                    Util.spawnCommandLine(`nautilus "${this._path}"`);
+                    this.emit('activate-window', null);
+                    this.closeMenus();
+                });
+            } else {
+                this.appInfo = this._app.get_app_info();
+                let actions = this.appInfo.list_actions();
+
+                let windows = this._app.get_windows().filter(
+                    w => !w.skip_taskbar
+                );
+
+                if (windows.length > 0) {
+                    let item = new PopupMenu.PopupMenuItem(_('Current Windows:'), { reactive: false, can_focus: false });
+                    item.actor.add_style_class_name('inactive');
+                    this.addMenuItem(item);
+                }
+
+                windows.forEach(window => {
+                    let title = window.title ? window.title
+                        : this._app.get_name();
+                    let item = this._appendMenuItem(title);
+                    item.connect('activate', () => {
+                        this.closeMenus();
+                        this.emit('activate-window', window);
+                        Main.activateWindow(window);
+                    });
+                });
+                if (!this._app.is_window_backed()) {
+                    this._appendSeparator();
+                    if (this._app.can_open_new_window() && !actions.includes('new-window')) {
+                        this._newWindowMenuItem = this._appendMenuItem(_('New Window'));
+                        this._newWindowMenuItem.connect('activate', () => {
+                            this.closeMenus();
+                            this._app.open_new_window(-1);
+                            this.emit('activate-window', null);
+                        });
+                    }
+                    if (this.discreteGpuAvailable &&
+                        this._app.state == Shell.AppState.STOPPED &&
+                        !actions.includes('activate-discrete-gpu')) {
+                        this._onDiscreteGpuMenuItem = this._appendMenuItem(_('Launch using Dedicated Graphics Card'));
+                        this._onDiscreteGpuMenuItem.connect('activate', () => {
+                            this.closeMenus();
+                            this._app.launch(0, -1, true);
+                            this.emit('activate-window', null);
+                        });
+                    }
+
+                    for (let i = 0; i < actions.length; i++) {
+                        let action = actions[i];
+                        let item;
+                        if (action === 'empty-trash-inactive') {
+                            item = new PopupMenu.PopupMenuItem(this.appInfo.get_action_name(action), { reactive: false, can_focus: false });
+                            item.actor.add_style_class_name('inactive');
+                            this._appendSeparator();
+                            this.addMenuItem(item);
+                        } else if (action === 'empty-trash') {
+                            this._appendSeparator();
+                            item = this._appendMenuItem(this.appInfo.get_action_name(action));
+                        } else {
+                            item = this._appendMenuItem(this.appInfo.get_action_name(action));
+                        }
+
+                        item.connect('activate', (emitter, event) => {
+                            this.closeMenus();
+                            this._app.launch_action(action, event.get_time(), -1);
+                            this.emit('activate-window', null);
+                        });
+                    }
+
+                    // If Trash Can, we don't want to add the rest of the entries below.
+                    if (this.appInfo.get_string('Id') === 'ArcMenu_Trash')
+                        return false;
+
+                    let desktopIcons = Main.extensionManager.lookup('desktop-icons@csoriano');
+                    let desktopIconsNG = Main.extensionManager.lookup('ding@rastersoft.com');
+                    if (desktopIcons && desktopIcons.stateObj || desktopIconsNG && desktopIconsNG.stateObj) {
+                        this._appendSeparator();
+                        let fileSource = this.appInfo.get_filename();
+                        let fileDestination = GLib.get_user_special_dir(imports.gi.GLib.UserDirectory.DIRECTORY_DESKTOP);
+                        let file = Gio.File.new_for_path(`${fileDestination}/${this._app.get_id()}`);
+                        let exists = file.query_exists(null);
+                        if (exists) {
+                            let item = this._appendMenuItem(_('Delete Desktop Shortcut'));
+                            item.connect('activate', () => {
+                                if (fileSource && fileDestination)
+                                    Util.spawnCommandLine(`rm ${fileDestination}/${this._app.get_id()}`);
+                                this.close();
+                            });
+                        } else {
+                            let item = this._appendMenuItem(_('Create Desktop Shortcut'));
+                            item.connect('activate', () => {
+                                if (fileSource && fileDestination)
+                                    Util.spawnCommandLine(`cp ${fileSource} ${fileDestination}`);
+                                this.close();
+                            });
+                        }
+                    }
+
+                    if (Shell.AppSystem.get_default().lookup_app('org.gnome.Software.desktop')) {
+                        this._appendSeparator();
+                        let item = this._appendMenuItem(_('Show Details'));
+                        item.connect('activate', () => {
+                            let id = this._app.get_id();
+                            let args = GLib.Variant.new('(ss)', [id, '']);
+                            Gio.DBus.get(Gio.BusType.SESSION, null, (o, res) => {
+                                let bus = Gio.DBus.get_finish(res);
+                                bus.call('org.gnome.Software',
+                                    '/org/gnome/Software',
+                                    'org.gtk.Actions', 'Activate',
+                                    GLib.Variant.new('(sava{sv})',
+                                        ['details', [args], null]),
+                                    null, 0, -1, null, null);
+                                this.closeMenus();
+                            });
+                        });
+                    }
+                }
+
+            }
+        }
+    }
+
+    _appendSeparator() {
+        let separator = new PopupMenu.PopupSeparatorMenuItem();
+        separator.actor.style_class = 'app-right-click-sep';
+        separator._separator.style_class = null;
+        this.addMenuItem(separator);
+    }
+
+    _appendMenuItem(labelText) {
+        let item = new PopupMenu.PopupMenuItem(labelText);
+        this.addMenuItem(item);
+        return item;
+    }
+
+    _onKeyPress(actor, event) {
+        // Disable toggling the menu by keyboard
+        // when it cannot be toggled by pointer
+        if (!actor.reactive)
+            return Clutter.EVENT_PROPAGATE;
+
+        let navKey;
+        switch (this._boxPointer.arrowSide) {
+        case St.Side.TOP:
+            navKey = Clutter.KEY_Down;
+            break;
+        case St.Side.BOTTOM:
+            navKey = Clutter.KEY_Up;
+            break;
+        case St.Side.LEFT:
+            navKey = Clutter.KEY_Right;
+            break;
+        case St.Side.RIGHT:
+            navKey = Clutter.KEY_Left;
+            break;
+        }
+
+        let state = event.get_state();
+
+        // if user has a modifier down (except capslock)
+        // then don't handle the key press here
+        state &= ~Clutter.ModifierType.LOCK_MASK;
+        state &= Clutter.ModifierType.MODIFIER_MASK;
+
+        if (state)
+            return Clutter.EVENT_PROPAGATE;
+
+        let symbol = event.get_key_symbol();
+        if (symbol == Clutter.KEY_space || symbol == Clutter.KEY_Return) {
+            this.toggle();
+            return Clutter.EVENT_STOP;
+        } else if (symbol == Clutter.KEY_Escape && this.isOpen) {
+            this.close();
+            return Clutter.EVENT_STOP;
+        } else if (symbol == navKey) {
+            if (this.isOpen) {
+                this.actor.navigate_focus(null, Gtk.DirectionType.TAB_FORWARD, false);
+                return Clutter.EVENT_STOP;
+            } else {
+                return Clutter.EVENT_PROPAGATE;
+            }
+        } else {
+            return Clutter.EVENT_PROPAGATE;
+        }
+    }
+};
+
+var ScrollView = GObject.registerClass(
+    class Arc_Menu_ScrollView extends St.ScrollView {
+        _init(params) {
+            super._init(params);
+            this.mouse_scroll = false;
+        }
+
+        vfunc_scroll_event(event) {
+            let newValue, callback, adjustment;
+            switch (event.direction) {
+            case Clutter.SCROLL_SMOOTH:
+                callback = () => {
+                    let delta_x, delta_y;
+                    [delta_x, delta_y] = event.get_scroll_delta();
+                    this.hscroll.adjustment.adjust_for_scroll_event(delta_x);
+                    this.vscroll.adjustment.adjust_for_scroll_event(delta_y);
+                };
+                break;
+            case Clutter.ScrollDirection.DOWN:
+            case Clutter.ScrollDirection.RIGHT:
+                adjustment = event.direction === Clutter.ScrollDirection.DOWN ? this.vscroll.adjustment : this.hscroll.adjustment;
+                callback = () => {
+                    newValue = adjustment.value + adjustment.page_size / 6;
+                    adjustment.set_value(newValue);
+                };
+                break;
+            case Clutter.ScrollDirection.UP:
+            case Clutter.ScrollDirection.LEFT:
+                adjustment = event.direction === Clutter.ScrollDirection.UP ? this.vscroll.adjustment : this.hscroll.adjustment;
+                callback = () => {
+                    newValue = adjustment.value - adjustment.page_size / 6;
+                    adjustment.set_value(newValue);
+                };
+                break;
+            default:
+                break;
+            }
+            if (callback)
+                Main.initializeDeferredWork(this, callback);
+            return Clutter.EVENT_PROPAGATE;
+        }
+
+        vfunc_style_changed() {
+            super.vfunc_style_changed();
+            let fade = this.get_effect('fade');
+            if (fade)
+                fade.set_shader_source(Utils.ScrollViewShader);
+        }
+    });
+
+var SearchMenuPopupBaseMenuItem = GObject.registerClass({
+    Properties: {
+        'active': GObject.ParamSpec.boolean('active', 'active', 'active',
+            GObject.ParamFlags.READWRITE,
+            false),
+        'sensitive': GObject.ParamSpec.boolean('sensitive', 'sensitive', 'sensitive',
+            GObject.ParamFlags.READWRITE,
+            true),
+    },
+    Signals: {
+        'activate': { param_types: [Clutter.Event.$gtype] },
+    },
+
+},   class Arc_Menu_PopupBaseMenuItem extends St.BoxLayout {
+    _init(menuLayout, params) {
+        params = imports.misc.params.parse(params, {
+            reactive: true,
+            activate: true,
+            hover: true,
+            style_class: null,
+            can_focus: true,
+        });
+        super._init({ style_class: 'popup-menu-item',
+            reactive: params.reactive,
+            track_hover: params.reactive,
+            can_focus: params.can_focus,
+            accessible_role: Atk.Role.MENU_ITEM });
+        this.hasContextMenu = false;
+        this._delegate = this;
+        this.needsDestroy = true;
+        this._menuLayout = menuLayout;
+        this.shouldShow = true;
+        this._parent = null;
+        this._active = false;
+        this._activatable = params.reactive && params.activate;
+        this._sensitive = true;
+
+        this._ornamentLabel = new St.Label({ style_class: 'popup-menu-ornament' });
+        this.add(this._ornamentLabel);
+
+        this.box = new St.BoxLayout();
+        this.add(this.box);
+
+        this.box.style = 'spacing: 6px; padding: 0px; margin: 0px;';
+        this.box.x_align = Clutter.ActorAlign.FILL;
+        this.box.x_expand = true;
+
+        if (!this._activatable)
+            this.add_style_class_name('popup-inactive-menu-item');
+
+        if (params.style_class)
+            this.add_style_class_name(params.style_class);
+
+        if (params.reactive && params.hover)
+            this.bind_property('hover', this, 'active', GObject.BindingFlags.SYNC_CREATE);
+
+        if (params.hover)
+            this.actor.connect('notify::hover', this._onHover.bind(this));
+        this.actor.connect('destroy', this._onDestroy.bind(this));
+    }
+
+    get actor() {
+        return this;
+    }
+
+    set active(active) {
+        let activeChanged = active != this.active;
+        if (activeChanged) {
+            this._active = active;
+            if (active) {
+                this.add_style_class_name('selected');
+                this._menuLayout.activeMenuItem = this;
+                if (this.can_focus)
+                    this.grab_key_focus();
+            } else {
+                this.remove_style_class_name('selected');
+                this.set_style_pseudo_class(null);
+            }
+            this.notify('active');
+        }
+    }
+
+    setShouldShow() {
+        // If a saved shortcut link is a desktop app, check if currently installed.
+        // Do NOT display if application not found.
+        if (this._command.endsWith('.desktop') && !Shell.AppSystem.get_default().lookup_app(this._command))
+            this.shouldShow = false;
+
+    }
+
+    _onHover() {
+        if (this.actor.hover && this._menuLayout.newSearch && this._menuLayout.newSearch._highlightDefault)
+            this._menuLayout.newSearch.highlightDefault(false);
+        if (this.tooltip == undefined && this.actor.hover && this.label) {
+            let description = this.description;
+            if (this._app)
+                description = this._app.get_description();
+            Utils.createTooltip(this._menuLayout, this, this.label, description);
+        }
+    }
+
+    vfunc_button_press_event() {
+        let event = Clutter.get_current_event();
+        this.pressed = false;
+        if (event.get_button() == 1) {
+            this._menuLayout._blockActivateEvent = false;
+            this.pressed = true;
+            if (this.hasContextMenu)
+                this.contextMenuTimeOut();
+        } else if (event.get_button() == 3) {
+            this.pressed = true;
+        }
+        this.add_style_pseudo_class('active');
+        return Clutter.EVENT_PROPAGATE;
+    }
+
+    vfunc_button_release_event() {
+        let event = Clutter.get_current_event();
+        if (event.get_button() == 1 && !this._menuLayout._blockActivateEvent && this.pressed) {
+            this.pressed = false;
+            this.activate(event);
+            this.remove_style_pseudo_class('active');
+        }
+        if (event.get_button() == 3 && this.pressed) {
+            this.pressed = false;
+            if (this.hasContextMenu)
+                this.popupContextMenu();
+            this.remove_style_pseudo_class('active');
+        }
+        return Clutter.EVENT_STOP;
+    }
+
+    vfunc_key_focus_in() {
+        super.vfunc_key_focus_in();
+        if (!this.actor.hover)
+            this._menuLayout._keyFocusIn(this.actor);
+        this.active = true;
+    }
+
+    vfunc_key_focus_out() {
+        if (this.contextMenu && this.contextMenu.isOpen)
+            return;
+
+        super.vfunc_key_focus_out();
+        this.active = false;
+    }
+
+    activate(event) {
+        this.emit('activate', event);
+    }
+
+    vfunc_key_press_event(keyEvent) {
+        if (!this._activatable)
+            return super.vfunc_key_press_event(keyEvent);
+
+        let state = keyEvent.modifier_state;
+
+        // if user has a modifier down (except capslock and numlock)
+        // then don't handle the key press here
+        state &= ~Clutter.ModifierType.LOCK_MASK;
+        state &= ~Clutter.ModifierType.MOD2_MASK;
+        state &= Clutter.ModifierType.MODIFIER_MASK;
+
+        if (state)
+            return Clutter.EVENT_PROPAGATE;
+
+        let symbol = keyEvent.keyval;
+        if (symbol == Clutter.KEY_space || symbol == Clutter.KEY_Return) {
+            this.activate(Clutter.get_current_event());
+            return Clutter.EVENT_STOP;
+        }
+        return Clutter.EVENT_PROPAGATE;
+    }
+
+    vfunc_touch_event(event) {
+        if (event.type == Clutter.EventType.TOUCH_END && !this._menuLayout._blockActivateEvent && this.pressed) {
+            this.remove_style_pseudo_class('active');
+            this.activate(Clutter.get_current_event());
+            this.pressed = false;
+            return Clutter.EVENT_STOP;
+        } else if (event.type == Clutter.EventType.TOUCH_BEGIN && !this._menuLayout.contextMenuManager.activeMenu) {
+            this.pressed = true;
+            this._menuLayout._blockActivateEvent = false;
+            if (this.hasContextMenu)
+                this.contextMenuTimeOut();
+            this.add_style_pseudo_class('active');
+        } else if (event.type == Clutter.EventType.TOUCH_BEGIN && this._menuLayout.contextMenuManager.activeMenu) {
+            this.pressed = false;
+            this._menuLayout._blockActivateEvent = false;
+            this._menuLayout.contextMenuManager.activeMenu.toggle();
+        }
+        return Clutter.EVENT_PROPAGATE;
+    }
+
+    contextMenuTimeOut() {
+        this._popupTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 600, () => {
+            this.pressed = false;
+            this._popupTimeoutId = null;
+            if (this.hasContextMenu && this._menuLayout.searchMenu.isOpen && !this._menuLayout._blockActivateEvent) {
+                this.popupContextMenu();
+                this._menuLayout.contextMenuManager.ignoreRelease();
+            }
+            return GLib.SOURCE_REMOVE;
+        });
+    }
+
+    _onDestroy() {
+        this.needsDestroy = false;
+        if (this.contextMenu) {
+            Main.uiGroup.remove_actor(this.contextMenu.actor);
+            this.contextMenu.destroy();
+        }
+    }
+});
+
+var Tooltip = class Arc_Menu_Tooltip {
+    constructor(menuLayout, sourceActor, title, description) {
+        this._menuButton = menuLayout.menuButton;
+        this._settings = this._menuButton._settings;
+        this.sourceActor = sourceActor;
+        if (this.sourceActor.tooltipLocation)
+            this.location = this.sourceActor.tooltipLocation;
+        else
+            this.location = Constants.TooltipLocation.BOTTOM;
+        let titleLabel, descriptionLabel;
+        this.actor = new St.BoxLayout({
+            vertical: true,
+            style_class: 'dash-label tooltip-menu-item',
+            opacity: 0,
+        });
+
+        if (title) {
+            titleLabel = new St.Label({
+                text: title,
+                style: description ? 'font-weight: bold;' : null,
+                y_align: Clutter.ActorAlign.CENTER,
+            });
+            this.actor.add_actor(titleLabel);
+        }
+
+        if (description) {
+            descriptionLabel = new St.Label({
+                text: description,
+                y_align: Clutter.ActorAlign.CENTER,
+            });
+            this.actor.add_actor(descriptionLabel);
+        }
+
+        global.stage.add_actor(this.actor);
+
+        this.actor.connect('destroy', () => {
+            if (this.destroyID) {
+                this.sourceActor.disconnect(this.destroyID);
+                this.destroyID = null;
+            }
+            if (this.activeID) {
+                this.sourceActor.disconnect(this.activeID);
+                this.activeID = null;
+            }
+
+            if (this.hoverID) {
+                this.sourceActor.disconnect(this.hoverID);
+                this.hoverID = null;
+            }
+            if (this.toggleID) {
+                this._settings.disconnect(this.toggleID);
+                this.toggleID = null;
+            }
+        });
+        this.activeID = this.sourceActor.connect('notify::active', () => this.setActive(this.sourceActor.active));
+        this.destroyID = this.sourceActor.connect('destroy', this.destroy.bind(this));
+        this.hoverID = this.sourceActor.connect('notify::hover', this._onHover.bind(this));
+        this._useTooltips = !this._settings.get_boolean('disable-tooltips');
+        this.toggleID = this._settings.connect('changed::disable-tooltips', this.disableTooltips.bind(this));
+    }
+
+    setActive(active) {
+        if (!active)
+            this.hide();
+    }
+
+    disableTooltips() {
+        this._useTooltips = !this._settings.get_boolean('disable-tooltips');
+    }
+
+    _onHover() {
+        if (this._useTooltips) {
+            if (this.sourceActor.hover) {
+                if (this._menuButton.tooltipShowing) {
+                    this.show();
+                    this._menuButton.activeTooltip = this.actor;
+                } else {
+                    this._menuButton.tooltipShowingID = GLib.timeout_add(0, 750, () => {
+                        this.show();
+                        this._menuButton.tooltipShowing = true;
+                        this._menuButton.activeTooltip = this.actor;
+                        this._menuButton.tooltipShowingID = null;
+                        return GLib.SOURCE_REMOVE;
+                    });
+                }
+                if (this._menuButton.tooltipHidingID) {
+                    GLib.source_remove(this._menuButton.tooltipHidingID);
+                    this._menuButton.tooltipHidingID = null;
+                }
+            } else {
+                this.hide();
+                if (this._menuButton.tooltipShowingID) {
+                    GLib.source_remove(this._menuButton.tooltipShowingID);
+                    this._menuButton.tooltipShowingID = null;
+                }
+                this._menuButton.tooltipHidingID = GLib.timeout_add(0, 750, () => {
+                    this._menuButton.tooltipShowing = false;
+                    this._menuButton.activeTooltip = null;
+                    this._menuButton.tooltipHidingID = null;
+                    return GLib.SOURCE_REMOVE;
+                });
+            }
+        }
+    }
+
+    show() {
+        if (this._useTooltips) {
+            this.actor.opacity = 0;
+            this.actor.show();
+
+            let [stageX, stageY] = this.sourceActor.get_transformed_position();
+
+            let itemWidth  = this.sourceActor.allocation.x2 - this.sourceActor.allocation.x1;
+            let itemHeight = this.sourceActor.allocation.y2 - this.sourceActor.allocation.y1;
+
+            let labelWidth = this.actor.get_width();
+            let labelHeight = this.actor.get_height();
+
+            let x, y;
+            let gap = 5;
+
+            switch (this.location) {
+            case Constants.TooltipLocation.BOTTOM_CENTERED:
+                y = stageY + itemHeight + gap;
+                x = stageX + Math.floor((itemWidth - labelWidth) / 2);
+                break;
+            case Constants.TooltipLocation.TOP_CENTERED:
+                y = stageY - labelHeight - gap;
+                x = stageX + Math.floor((itemWidth - labelWidth) / 2);
+                break;
+            case Constants.TooltipLocation.BOTTOM:
+                y = stageY + itemHeight + gap;
+                x = stageX + gap;
+                break;
+            }
+
+            // keep the label inside the screen
+            let monitor = Main.layoutManager.findMonitorForActor(this.sourceActor);
+            if (x - monitor.x < gap)
+                x += monitor.x - x + gap;
+            else if (x + labelWidth > monitor.x + monitor.width - gap)
+                x -= x + labelWidth - (monitor.x + monitor.width) + gap;
+            else if (y - monitor.y < gap)
+                y += monitor.y - y + gap;
+            else if (y + labelHeight > monitor.y + monitor.height - gap)
+                y -= y + labelHeight - (monitor.y + monitor.height) + gap;
+
+            this.actor.set_position(x, y);
+            this.actor.ease({
+                opacity: 255,
+                duration: Dash.DASH_ITEM_LABEL_SHOW_TIME,
+                mode: Clutter.AnimationMode.EASE_OUT_QUAD,
+            });
+        }
+    }
+
+    hide() {
+        if (this._useTooltips) {
+            this.actor.ease({
+                opacity: 0,
+                duration: Dash.DASH_ITEM_LABEL_HIDE_TIME,
+                mode: Clutter.AnimationMode.EASE_OUT_QUAD,
+                onComplete: () => this.actor.hide(),
+            });
+        }
+    }
+
+    destroy() {
+        if (this._menuButton.tooltipShowingID) {
+            GLib.source_remove(this._menuButton.tooltipShowingID);
+            this._menuButton.tooltipShowingID = null;
+        }
+        if (this._menuButton.tooltipHidingID) {
+            GLib.source_remove(this._menuButton.tooltipHidingID);
+            this._menuButton.tooltipHidingID = null;
+        }
+        if (this.toggleID > 0) {
+            this._settings.disconnect(this.toggleID);
+            this.toggleID = 0;
+        }
+        if (this.hoverID > 0) {
+            this.sourceActor.disconnect(this.hoverID);
+            this.hoverID = 0;
+        }
+
+        global.stage.remove_actor(this.actor);
+        this.actor.destroy();
+    }
+};
+
+var SearchResultItem = GObject.registerClass(class Arc_Menu_SearchResultItem extends SearchMenuPopupBaseMenuItem {
+    _init(menuLayout, app, path) {
+        super._init(menuLayout);
+        this._menuLayout = menuLayout;
+        this._app = app;
+        this.hasContextMenu = !!this._app;
+        this._path = path;
+    }
+
+    _createIcon(iconSize) {
+        return this._app.create_icon_texture(iconSize);
+    }
+
+    popupContextMenu() {
+        if (this._app && this.contextMenu == undefined) {
+            this.contextMenu = new ApplicationContextMenu(this.actor, this._app, this._menuLayout);
+            if (this._path)
+                this.contextMenu.path = this._path;
+        }
+        if (this.contextMenu != undefined) {
+            if (this.tooltip != undefined)
+                this.tooltip.hide();
+            if (!this.contextMenu.isOpen)
+                this.contextMenu.redisplay();
+            this.contextMenu.toggle();
+        }
+    }
+});
+
+var SearchBox = class Arc_Menu_SearchBox {
+    constructor(menuLayout) {
+        this.menuLayout = menuLayout;
+        this.newSearch = this.menuLayout.newSearch;
+        this.actor = new St.BoxLayout({
+            x_expand: true,
+            style_class: 'search-box search-box-padding',
+        });
+        this._stEntry = new St.Entry({
+            hint_text: _('검색어를 입력하세요.'),
+            track_hover: true,
+            can_focus: true,
+            x_expand: true,
+            x_align: Clutter.ActorAlign.FILL,
+            y_align: Clutter.ActorAlign.START,
+        });
+        this._stEntry.style = 'border-radius:20px; padding: 7px 9px; background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); margin: 6px 0px; font-weight: normal; text-shadow: 0 0 transparent;';
+        this._findIcon = new St.Icon({
+            style_class: 'search-entry-icon',
+            icon_name: 'edit-find-symbolic',
+            icon_size: 16,
+        });
+        this._clearIcon = new St.Icon({
+            style_class: 'search-entry-icon',
+            icon_name: 'edit-clear-symbolic',
+            icon_size: 16,
+        });
+        this._stEntry.set_primary_icon(this._findIcon);
+        this.actor.add(this._stEntry);
+
+        this._text = this._stEntry.get_clutter_text();
+        this._textChangedId = this._text.connect('text-changed', this._onTextChanged.bind(this));
+        this._keyPressId = this._text.connect('key-press-event', this._onKeyPress.bind(this));
+        this._keyFocusInId = this._text.connect('key-focus-in', this._onKeyFocusIn.bind(this));
+        this._text.connect('button-press-event', this._onButtonPress.bind(this));
+        this._searchIconClickedId = 0;
+        this._inputHistory = [];
+        this._maxInputHistory = 5;
+
+        this.actor.connect('destroy', this._onDestroy.bind(this));
+    }
+
+    _onButtonPress() {
+        if (!this.menuLayout.searchMenu.isOpen)
+            this.menuLayout.searchMenu.open();
+
+    }
+
+    updateStyle() {
+        let style = this._stEntry.style;
+        this._stEntry.style = style.replace('border-width: 0;', '');
+    }
+
+    _pushInput(searchString) {
+        if (this._inputHistory.length == this._maxInputHistory)
+            this._inputHistory.shift();
+
+        this._inputHistory.push(searchString);
+    }
+
+    _lastInput() {
+        if (this._inputHistory.length != 0)
+            return this._inputHistory[this._inputHistory.length - 1];
+
+        return '';
+    }
+
+    _previousInput() {
+        if (this._inputHistory.length > 1)
+            return this._inputHistory[this._inputHistory.length - 2];
+
+        return '';
+    }
+
+    getText() {
+        return this._stEntry.get_text();
+    }
+
+    setText(text) {
+        this._stEntry.set_text(text);
+    }
+
+    grabKeyFocus() {
+        this._stEntry.grab_key_focus();
+    }
+
+    hasKeyFocus() {
+        return this._stEntry.contains(global.stage.get_key_focus());
+    }
+
+    clear() {
+        this._stEntry.set_text('');
+        this.emit('cleared');
+    }
+
+    isEmpty() {
+        return this._stEntry.get_text() == '';
+    }
+
+    _isActivated() {
+        return this._stEntry.get_text() != '';
+    }
+
+    _setClearIcon() {
+        this._stEntry.set_secondary_icon(this._clearIcon);
+        if (this._searchIconClickedId == 0) {
+            this._searchIconClickedId = this._stEntry.connect('secondary-icon-clicked',
+                this.clear.bind(this));
+        }
+    }
+
+    _unsetClearIcon() {
+        if (this._searchIconClickedId > 0)
+            this._stEntry.disconnect(this._searchIconClickedId);
+
+        this._searchIconClickedId = 0;
+        this._stEntry.set_secondary_icon(null);
+    }
+
+    _onTextChanged(entryText) {
+        let searchString = this._stEntry.get_text();
+        this._pushInput(searchString);
+        if (this._isActivated()) {
+            this._setClearIcon();
+        } else {
+            this._unsetClearIcon();
+            if (searchString == '' && this._previousInput() != '')
+                this.emit('cleared');
+
+
+        }
+        this.emit('changed', searchString);
+    }
+
+    _onKeyPress(actor, event) {
+        let symbol = event.get_key_symbol();
+        if (symbol == Clutter.KEY_Return ||
+            symbol == Clutter.KEY_KP_Enter) {
+            if (!this.isEmpty()) {
+                if (this.newSearch.getTopResult())
+                    this.newSearch.getTopResult().activate(event);
+
+            }
+            return Clutter.EVENT_STOP;
+        }
+        this.emit('key-press-event', event);
+        return Clutter.EVENT_PROPAGATE;
+    }
+
+    _onKeyFocusIn(actor) {
+        this.emit('key-focus-in');
+        return Clutter.EVENT_PROPAGATE;
+    }
+
+    _onDestroy() {
+        if (this._textChangedId > 0) {
+            this._text.disconnect(this._textChangedId);
+            this._textChangedId = 0;
+        }
+        if (this._keyPressId > 0) {
+            this._text.disconnect(this._keyPressId);
+            this._keyPressId = 0;
+        }
+        if (this._keyFocusInId > 0) {
+            this._text.disconnect(this._keyFocusInId);
+            this._keyFocusInId = 0;
+        }
+    }
+};
+Signals.addSignalMethods(SearchBox.prototype);
diff --git a/extensions/search/meson.build b/extensions/search/meson.build
new file mode 100644
index 0000000..c639094
--- /dev/null
+++ b/extensions/search/meson.build
@@ -0,0 +1,23 @@
+extension_data += configure_file(
+  input: metadata_name + '.in',
+  output: metadata_name,
+  configuration: metadata_conf
+)
+
+extension_sources += files(
+    'menuWidgets.js',
+    'baseMenuLayout.js',
+    'menuButton.js',
+    'constants.js',
+    'controller.js',
+    'convenience.js',
+    'utils.js',
+    'search.js',
+    'searchMenuLayout.js'
+)
+
+extension_dir = join_paths(extensiondir, uuid)
+install_subdir('media', install_dir : extension_dir)
+
+schema_data_dir = 'schemas'
+subdir(schema_data_dir)
diff --git a/extensions/search/metadata.json.in b/extensions/search/metadata.json.in
new file mode 100644
index 0000000..299b349
--- /dev/null
+++ b/extensions/search/metadata.json.in
@@ -0,0 +1,11 @@
+{
+"extension-id": "@extension_id@",
+"uuid": "@uuid@",
+"settings-schema": "@gschemaname@",
+"gettext-domain": "search",
+"name": "Search",
+"description": "Add search button in panel and show search window",
+"original-authors": [  "tmax" ],
+"shell-version": [ "@shell_current@" ],
+"url": "@url@"
+}
diff --git a/extensions/search/schemas/meson.build b/extensions/search/schemas/meson.build
new file mode 100644
index 0000000..abe991d
--- /dev/null
+++ b/extensions/search/schemas/meson.build
@@ -0,0 +1,14 @@
+run_command('glib-compile-schemas', meson.current_source_dir())
+
+install_data([
+		'gschemas.compiled',
+    'org.gnome.shell.extensions.search.gschema.xml'
+	],
+	install_dir : join_paths(extension_dir, schema_data_dir)
+)
+
+install_data([
+    'org.gnome.shell.extensions.search.gschema.xml'
+	],
+	install_dir : schemadir
+)
diff --git a/extensions/search/schemas/org.gnome.shell.extensions.search.gschema.xml b/extensions/search/schemas/org.gnome.shell.extensions.search.gschema.xml
new file mode 100644
index 0000000..ef75431
--- /dev/null
+++ b/extensions/search/schemas/org.gnome.shell.extensions.search.gschema.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<schemalist gettext-domain="searchu">
+  <schema path="/org/gnome/shell/extensions/search/" id="org.gnome.shell.extensions.search">
+    <key type="b" name="disable-tooltips">
+      <default>false</default>
+      <summary>disable tooltips</summary>
+      <description>disable tooltips.</description>
+    </key>
+    <key type="b" name="multi-monitor">
+      <default>true</default>
+      <summary>Display on all monitors</summary>
+      <description>Display the menu on all monitors when using Dash to Panel.</description>
+    </key>
+  </schema>
+</schemalist>
diff --git a/extensions/search/search.js b/extensions/search/search.js
new file mode 100644
index 0000000..e013d72
--- /dev/null
+++ b/extensions/search/search.js
@@ -0,0 +1,801 @@
+/*
+ * ArcMenu - A traditional application menu for GNOME 3
+ *
+ * ArcMenu Lead Developer and Maintainer
+ * Andrew Zaech https://gitlab.com/AndrewZaech
+ *
+ * ArcMenu Founder, Former Maintainer, and Former Graphic Designer
+ * LinxGem33 https://gitlab.com/LinxGem33 - (No Longer Active)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+const Me = imports.misc.extensionUtils.getCurrentExtension();
+const { Clutter, Gio, GLib, GObject, Shell, St } = imports.gi;
+const AppDisplay = imports.ui.appDisplay;
+const appSys = Shell.AppSystem.get_default();
+const Constants = Me.imports.constants;
+const Gettext = imports.gettext.domain(Me.metadata['gettext-domain']);
+const MW = Me.imports.menuWidgets;
+const PopupMenu = imports.ui.popupMenu;
+const RemoteSearch = imports.ui.remoteSearch;
+const Signals = imports.signals;
+const SystemActions = imports.misc.systemActions;
+const Utils =  Me.imports.utils;
+const _ = Gettext.gettext;
+
+const SEARCH_PROVIDERS_SCHEMA = 'org.gnome.desktop.search-providers';
+
+var MAX_LIST_SEARCH_RESULTS_ROWS = 6;
+var MAX_APPS_SEARCH_RESULTS_ROWS = 6;
+
+var LARGE_ICON_SIZE = 36;
+var MEDIUM_ICON_SIZE = 25;
+var SMALL_ICON_SIZE = 16;
+
+var ListSearchResult = class Arc_Menu_ListSearchResult {
+    constructor(provider, metaInfo, resultsView) {
+        this._menuLayout = resultsView._menuLayout;
+        this._resultsView = resultsView;
+        this.metaInfo = metaInfo;
+        this.provider = provider;
+        this._settings = this._menuLayout._settings;
+        this._app = appSys.lookup_app(this.metaInfo['id']);
+
+        if (this.provider.id == 'org.gnome.Nautilus.desktop')
+            this.menuItem = new MW.SearchResultItem(this._menuLayout, appSys.lookup_app(this.provider.id), this.metaInfo['description']);
+        else if (this._app)
+            this.menuItem = new MW.SearchResultItem(this._menuLayout, this._app);
+        else
+            this.menuItem = new MW.SearchResultItem(this._menuLayout);
+
+        this.label = new St.Label({
+            text: this.metaInfo['name'],
+            y_expand: false,
+            y_align: Clutter.ActorAlign.CENTER,
+        });
+        let labelBox = new St.BoxLayout({
+            vertical: true,
+            y_align: Clutter.ActorAlign.CENTER,
+        });
+        labelBox.add(this.label);
+
+        let descriptionText = this._app ? this._app.get_description() : this.metaInfo['description'];
+        if (descriptionText)
+            descriptionText = descriptionText.split('\n')[0];
+
+        let descriptionLabel = new St.Label({
+            text: descriptionText,
+            y_expand: false,
+            x_align: Clutter.ActorAlign.START,
+            y_align: Clutter.ActorAlign.CENTER,
+        });
+
+        this.menuItem.actor.style = null;
+        this.label.style = null;
+
+        let icon = this.metaInfo['createIcon'](SMALL_ICON_SIZE);
+        if (icon)
+            this.menuItem.box.add_child(icon);
+
+        this.menuItem.box.add_child(labelBox);
+        if (this.metaInfo['description'] && this.provider.appInfo.get_name() == 'Calculator' && !labelBox.contains(descriptionLabel))
+            this.label.text = `${this.metaInfo['name']}   ${this.metaInfo['description']}`;
+
+        this.menuItem.connect('activate', this.activate.bind(this));
+        this.menuItem.label = this.label;
+        this.menuItem.description = descriptionText;
+    }
+
+    activate() {
+        this.emit('activate', this.metaInfo.id);
+    }
+
+    _highlightTerms() {
+        let markup = this._resultsView.highlightTerms(this.metaInfo['description'].split('\n')[0]);
+        this._descriptionLabel.clutter_text.set_markup(markup);
+    }
+}; Signals.addSignalMethods(ListSearchResult.prototype);
+
+var AppSearchResult = class Arc_Menu_AppSearchResult {
+    constructor(provider, metaInfo, resultsView) {
+        this._menuLayout = resultsView._menuLayout;
+        this.metaInfo = metaInfo;
+        this.provider = provider;
+        this._settings = this._menuLayout._settings;
+        this._resultsView = resultsView;
+        this._app = appSys.lookup_app(this.metaInfo['id']);
+        let iconSize;
+        this.label = new St.Label({
+            text: this._app ? this._app.get_name() : this.metaInfo['name'],
+            y_expand: true,
+            y_align: Clutter.ActorAlign.CENTER,
+            x_align: Clutter.ActorAlign.FILL,
+        });
+
+        if (this._app)
+            this.menuItem = new MW.SearchResultItem(this._menuLayout, this._app);
+        else
+            this.menuItem = new MW.SearchResultItem(this._menuLayout);
+
+        this.menuItem.actor.style = null;
+        this.label.style = null;
+
+        this.icon = this.metaInfo['createIcon'](SMALL_ICON_SIZE);
+        if (this.icon) {
+            this.icon.icon_size = SMALL_ICON_SIZE;
+            this.icon.y_align = Clutter.ActorAlign.CENTER;
+            this.icon.x_align = Clutter.ActorAlign.CENTER;
+            this.menuItem.box.add_child(this.icon);
+        }
+        this.menuItem.box.add_child(this.label);
+
+        if (this.menuItem instanceof MW.SearchResultItem)
+            this.menuItem.connect('activate', this.activate.bind(this));
+
+        this.menuItem.label = this.label;
+        this.menuItem.description = this._app ? this._app.get_description() : this.metaInfo['description'];
+    }
+
+    activate() {
+        this.emit('activate', this.metaInfo.id);
+    }
+
+}; Signals.addSignalMethods(AppSearchResult.prototype);
+
+var SearchResultsBase = class Arc_Menu_SearchResultsBase {
+    constructor(provider, resultsView) {
+        this.provider = provider;
+        this._resultsView = resultsView;
+        this._menuLayout = resultsView._menuLayout;
+        this._terms = [];
+
+        this.actor = new St.BoxLayout({
+            vertical: true,
+        });
+
+        this._resultDisplayBin = new St.Bin({
+            x_expand: true,
+            y_expand: true,
+        });
+
+        this.actor.add(this._resultDisplayBin);
+
+        this._resultDisplays = {};
+
+        this._clipboard = St.Clipboard.get_default();
+
+        this._cancellable = new Gio.Cancellable();
+        this.actor.connect('destroy', this._onDestroy.bind(this));
+    }
+
+    _onDestroy() {
+        this._terms = [];
+    }
+
+    _createResultDisplay(meta) {
+        if (this.provider.createResultObject)
+            return this.provider.createResultObject(meta, this._resultsView);
+
+        return null;
+    }
+
+    clear() {
+        this._cancellable.cancel();
+        for (let resultId in this._resultDisplays)
+            this._resultDisplays[resultId].menuItem.destroy();
+        this._resultDisplays = {};
+        this._clearResultDisplay();
+        this.actor.hide();
+    }
+
+    _keyFocusIn(actor) {
+        this.emit('key-focus-in', actor);
+    }
+
+    _activateResult(result, id) {
+        if (this.provider.activateResult) {
+            this.provider.activateResult(id, this._terms);
+            if (result.metaInfo.clipboardText)
+                this._clipboard.set_text(St.ClipboardType.CLIPBOARD, result.metaInfo.clipboardText);
+            this._menuLayout.searchMenu.toggle();
+        } else {
+            this._menuLayout.searchMenu.toggle();
+            if (id.endsWith('.desktop')) {
+                let app = appSys.lookup_app(id);
+                app.open_new_window(-1);
+            } else {
+                SystemActions.getDefault().activateAction(id);
+            }
+        }
+    }
+
+    _setMoreCount(count) {
+    }
+
+    _ensureResultActors(results, callback) {
+        let metasNeeded = results.filter(
+            resultId => this._resultDisplays[resultId] === undefined
+        );
+
+        if (metasNeeded.length === 0) {
+            callback(true);
+        } else {
+            this._cancellable.cancel();
+            this._cancellable.reset();
+
+            this.provider.getResultMetas(metasNeeded, metas => {
+                if (this._cancellable.is_cancelled()) {
+                    if (metas.length > 0)
+                        log(`Search provider ${this.provider.id} returned results after the request was canceled`);
+                    callback(false);
+                    return;
+                }
+                if (metas.length != metasNeeded.length) {
+                    log(`Wrong number of result metas returned by search provider ${this.provider.id
+                    }: expected ${metasNeeded.length} but got ${metas.length}`);
+                    callback(false);
+                    return;
+                }
+                if (metas.some(meta => !meta.name || !meta.id)) {
+                    log(`Invalid result meta returned from search provider ${this.provider.id}`);
+                    callback(false);
+                    return;
+                }
+
+                metasNeeded.forEach((resultId, i) => {
+                    let meta = metas[i];
+                    let display = this._createResultDisplay(meta);
+                    display.connect('activate', this._activateResult.bind(this));
+                    display.menuItem.connect('key-focus-in', this._keyFocusIn.bind(this));
+                    this._resultDisplays[resultId] = display;
+                });
+                callback(true);
+            }, this._cancellable);
+        }
+    }
+
+    updateSearch(providerResults, terms, callback) {
+        this._terms = terms;
+        if (providerResults.length == 0) {
+            this._clearResultDisplay();
+            this.actor.hide();
+            callback();
+        } else {
+            let maxResults = this._getMaxDisplayedResults();
+            let results = this.provider.filterResults(providerResults, maxResults);
+            let moreCount = Math.max(providerResults.length - results.length, 0);
+
+            this._ensureResultActors(results, successful => {
+                if (!successful) {
+                    this._clearResultDisplay();
+                    callback();
+                    return;
+                }
+
+                // To avoid CSS transitions causing flickering when
+                // the first search result stays the same, we hide the
+                // content while filling in the results.
+                this.actor.hide();
+                this._clearResultDisplay();
+                results.forEach(resultId => {
+                    this._addItem(this._resultDisplays[resultId]);
+                });
+
+                this._setMoreCount(this.provider.canLaunchSearch ? moreCount : 0);
+                this.actor.show();
+                callback();
+            });
+        }
+    }
+};
+
+var ListSearchResults = class Arc_Menu_ListSearchResults extends SearchResultsBase {
+    constructor(provider, resultsView) {
+        super(provider, resultsView);
+        this._menuLayout = resultsView._menuLayout;
+        this._settings = this._menuLayout._settings;
+
+        this._container = new St.BoxLayout({
+            vertical: true,
+            x_align: Clutter.ActorAlign.FILL,
+            y_align: Clutter.ActorAlign.FILL,
+            x_expand: true,
+            y_expand: true,
+            style_class: null,
+        });
+
+        this.providerInfo = new SearchProviderInfo(provider, this._menuLayout);
+        this.providerInfo.connect('key-focus-in', this._keyFocusIn.bind(this));
+        this.providerInfo.connect('activate', () => {
+            this.providerInfo.animateLaunch();
+            provider.launchSearch(this._terms);
+            this._menuLayout.searchMenu.toggle();
+        });
+
+        this._container.add(this.providerInfo.actor);
+
+        this._content = new St.BoxLayout({
+            vertical: true,
+            x_expand: true,
+            y_expand: true,
+            x_align: Clutter.ActorAlign.FILL,
+        });
+        this._container.add(this._content);
+        this._resultDisplayBin.set_child(this._container);
+    }
+
+    _setMoreCount(count) {
+        this.providerInfo.setMoreCount(count);
+    }
+
+    _getMaxDisplayedResults() {
+        return MAX_LIST_SEARCH_RESULTS_ROWS;
+    }
+
+    _clearResultDisplay() {
+        this._content.remove_all_children();
+    }
+
+    _createResultDisplay(meta) {
+        return super._createResultDisplay(meta, this._resultsView) ||
+               new ListSearchResult(this.provider, meta, this._resultsView);
+    }
+
+    _addItem(display) {
+        this._content.add_actor(display.menuItem.actor);
+    }
+
+    getFirstResult() {
+        if (this._content.get_n_children() > 0)
+            return this._content.get_child_at_index(0)._delegate;
+        else
+            return null;
+    }
+
+    destroy() {
+        this._resultDisplayBin.destroy();
+        this._resultDisplayBin = null;
+    }
+};
+Signals.addSignalMethods(ListSearchResults.prototype);
+var AppSearchResults = class Arc_Menu_AppSearchResults extends SearchResultsBase {
+    constructor(provider, resultsView) {
+        super(provider, resultsView);
+        this._parentContainer = resultsView.actor;
+        this._menuLayout = resultsView._menuLayout;
+        this._grid = new St.BoxLayout({
+            vertical: true,
+        });
+
+        this._resultDisplayBin.set_child(this._grid);
+    }
+
+    _getMaxDisplayedResults() {
+        return MAX_APPS_SEARCH_RESULTS_ROWS;
+    }
+
+    _clearResultDisplay() {
+        this._grid.remove_all_children();
+    }
+
+    _createResultDisplay(meta) {
+        return new AppSearchResult(this.provider, meta, this._resultsView);
+    }
+
+    _addItem(display) {
+        this._grid.add_actor(display.menuItem.actor);
+    }
+
+    getFirstResult() {
+        if (this._grid.get_n_children() > 0)
+            return this._grid.get_child_at_index(0)._delegate;
+        else
+            return null;
+    }
+
+    destroy() {
+        this._resultDisplayBin.destroy();
+        this._resultDisplayBin = null;
+    }
+};
+Signals.addSignalMethods(AppSearchResults.prototype);
+
+var SearchResults = class Arc_Menu_SearchResults {
+    constructor(menuLayout) {
+        this._menuLayout = menuLayout;
+
+        this.actor = new St.BoxLayout({
+            vertical: true,
+            y_expand: true,
+            x_expand: true,
+            x_align: Clutter.ActorAlign.FILL,
+
+        });
+        this.actor._delegate = this.actor;
+
+        this._content = new St.BoxLayout({
+            vertical: true,
+            x_align: Clutter.ActorAlign.FILL,
+        });
+
+        this.actor.add(this._content);
+
+        this._statusText = new St.Label();
+        this._statusBin = new St.Bin({
+            x_align: Clutter.ActorAlign.CENTER,
+            y_align: Clutter.ActorAlign.CENTER,
+            x_expand: true,
+            y_expand: true,
+        });
+        this._statusText.style_class = '';
+
+        this.actor.add(this._statusBin);
+        this._statusBin.add_actor(this._statusText);
+
+        this._highlightDefault = false;
+        this._defaultResult = null;
+        this._startingSearch = false;
+
+        this._terms = [];
+        this._results = {};
+
+        this._providers = [];
+
+        this._highlightRegex = null;
+
+        this._searchSettings = new Gio.Settings({ schema_id: SEARCH_PROVIDERS_SCHEMA });
+        this.disabledID = this._searchSettings.connect('changed::disabled', this._reloadRemoteProviders.bind(this));
+        this.enabledID =  this._searchSettings.connect('changed::enabled', this._reloadRemoteProviders.bind(this));
+        this.disablExternalID = this._searchSettings.connect('changed::disable-external', this._reloadRemoteProviders.bind(this));
+        this.sortOrderID = this._searchSettings.connect('changed::sort-order', this._reloadRemoteProviders.bind(this));
+
+        this._searchTimeoutId = 0;
+        this._cancellable = new Gio.Cancellable();
+
+        this._registerProvider(new AppDisplay.AppSearchProvider());
+
+        this.installChangedID = appSys.connect('installed-changed', this._reloadRemoteProviders.bind(this));
+
+        this._reloadRemoteProviders();
+    }
+
+    setMaxDisplayedResults(rows) {
+        MAX_APPS_SEARCH_RESULTS_ROWS = rows;
+    }
+
+    setStyle(style) {
+        if (this._statusText)
+            this._statusText.style_class = style;
+
+
+    }
+
+    destroy() {
+        if (this._searchTimeoutId > 0) {
+            GLib.source_remove(this._searchTimeoutId);
+            this._searchTimeoutId = 0;
+        }
+        if (this.disabledID > 0) {
+            this._searchSettings.disconnect(this.disabledID);
+            this.disabledID = 0;
+        }
+        if (this.enabledID > 0) {
+            this._searchSettings.disconnect(this.enabledID);
+            this.enabledID = 0;
+        }
+        if (this.disablExternalID > 0) {
+            this._searchSettings.disconnect(this.disablExternalID);
+            this.disablExternalID = 0;
+        }
+        if (this.sortOrderID > 0) {
+            this._searchSettings.disconnect(this.sortOrderID);
+            this.sortOrderID = 0;
+        }
+        if (this.installChangedID > 0) {
+            appSys.disconnect(this.installChangedID);
+            this.installChangedID = 0;
+        }
+        this._providers.forEach(provider => {
+            provider.display.clear();
+            provider.display.destroy();
+        });
+        this.actor.destroy();
+    }
+
+    _reloadRemoteProviders() {
+        let remoteProviders = this._providers.filter(p => p.isRemoteProvider);
+        remoteProviders.forEach(provider => {
+            this._unregisterProvider(provider);
+        });
+
+        RemoteSearch.loadRemoteSearchProviders(this._searchSettings, providers => {
+            providers.forEach(this._registerProvider.bind(this));
+        });
+    }
+
+    _registerProvider(provider) {
+        provider.searchInProgress = false;
+        this._providers.push(provider);
+        this._ensureProviderDisplay(provider);
+    }
+
+    _unregisterProvider(provider) {
+        let index = this._providers.indexOf(provider);
+        this._providers.splice(index, 1);
+
+        if (provider.display)
+            provider.display.actor.destroy();
+
+    }
+
+    _gotResults(results, provider) {
+        this._results[provider.id] = results;
+        this._updateResults(provider, results);
+    }
+
+    _clearSearchTimeout() {
+        if (this._searchTimeoutId > 0) {
+            GLib.source_remove(this._searchTimeoutId);
+            this._searchTimeoutId = 0;
+        }
+    }
+
+    _reset() {
+        this._terms = [];
+        this._results = {};
+        this._clearDisplay();
+        this._clearSearchTimeout();
+        this._defaultResult = null;
+        this._startingSearch = false;
+
+        this._updateSearchProgress();
+    }
+
+    _doSearch() {
+        this._startingSearch = false;
+
+        let previousResults = this._results;
+        this._results = {};
+
+        this._providers.forEach(provider => {
+            provider.searchInProgress = true;
+
+            let previousProviderResults = previousResults[provider.id];
+            if (this._isSubSearch && previousProviderResults) {
+                provider.getSubsearchResultSet(previousProviderResults,
+                    this._terms,
+                    results => {
+                        this._gotResults(results, provider);
+                    },
+                    this._cancellable);
+            } else {
+                provider.getInitialResultSet(this._terms,
+                    results => {
+                        this._gotResults(results, provider);
+                    },
+                    this._cancellable);
+            }
+        });
+
+        this._updateSearchProgress();
+
+        this._clearSearchTimeout();
+    }
+
+    _onSearchTimeout() {
+        this._searchTimeoutId = 0;
+        this._doSearch();
+        return GLib.SOURCE_REMOVE;
+    }
+
+    setTerms(terms) {
+        // Check for the case of making a duplicate previous search before
+        // setting state of the current search or cancelling the search.
+        // This will prevent incorrect state being as a result of a duplicate
+        // search while the previous search is still active.
+        let searchString = terms.join(' ');
+        let previousSearchString = this._terms.join(' ');
+        if (searchString == previousSearchString)
+            return;
+
+        this._startingSearch = true;
+
+        this._cancellable.cancel();
+        this._cancellable.reset();
+
+        if (terms.length == 0) {
+            this._reset();
+            return;
+        }
+
+        let isSubSearch = false;
+        if (this._terms.length > 0)
+            isSubSearch = searchString.indexOf(previousSearchString) == 0;
+
+        this._terms = terms;
+        this._isSubSearch = isSubSearch;
+        this._updateSearchProgress();
+
+        if (this._searchTimeoutId == 0)
+            this._searchTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 150, this._onSearchTimeout.bind(this));
+
+        let escapedTerms = this._terms.map(term => Shell.util_regex_escape(term));
+        this._highlightRegex = new RegExp(`(${escapedTerms.join('|')})`, 'gi');
+
+        this.emit('terms-changed');
+    }
+
+
+    _ensureProviderDisplay(provider) {
+        if (provider.display)
+            return;
+
+        let providerDisplay;
+        if (provider.appInfo)
+            providerDisplay = new ListSearchResults(provider, this);
+        else
+            providerDisplay = new AppSearchResults(provider, this);
+        providerDisplay.actor.hide();
+        this._content.add(providerDisplay.actor);
+        provider.display = providerDisplay;
+    }
+
+    _clearDisplay() {
+        this._providers.forEach(provider => {
+            provider.display.clear();
+        });
+    }
+
+    _maybeSetInitialSelection() {
+        let newDefaultResult = null;
+
+        let providers = this._providers;
+        for (let i = 0; i < providers.length; i++) {
+            let provider = providers[i];
+            let display = provider.display;
+
+            if (!display.actor.visible)
+                continue;
+
+            let firstResult = display.getFirstResult();
+            if (firstResult) {
+                newDefaultResult = firstResult;
+                this._menuLayout.activeMenuItem = newDefaultResult;
+                break; // select this one!
+            }
+        }
+
+        if (newDefaultResult != this._defaultResult) {
+            this._setSelected(this._defaultResult, false);
+            this._setSelected(newDefaultResult, this._highlightDefault);
+
+            this._defaultResult = newDefaultResult;
+        }
+    }
+
+    get searchInProgress() {
+        if (this._startingSearch)
+            return true;
+
+        return this._providers.some(p => p.searchInProgress);
+    }
+
+    _updateSearchProgress() {
+        let haveResults = this._providers.some(provider => {
+            let display = provider.display;
+            return display.getFirstResult() != null;
+        });
+
+        this._statusBin.visible = !haveResults;
+
+        if (!haveResults) {
+            if (this.searchInProgress)
+                this._statusText.set_text(_('Searching...'));
+            else
+                this._statusText.set_text(_('No results.'));
+
+        }
+    }
+
+    _updateResults(provider, results) {
+        let terms = this._terms;
+        let display = provider.display;
+        display.updateSearch(results, terms, () => {
+            provider.searchInProgress = false;
+
+            this._maybeSetInitialSelection();
+            this._updateSearchProgress();
+        });
+    }
+
+    highlightDefault(highlight) {
+        this._highlightDefault = highlight;
+        this._setSelected(this._defaultResult, highlight);
+    }
+
+    getTopResult() {
+        return this._defaultResult;
+    }
+
+    _setSelected(result, selected) {
+        if (!result || result === undefined || result === null)
+            return;
+        if (selected) {
+            result.add_style_class_name('selected');
+            result.add_style_pseudo_class('selected');
+        } else {
+            result.remove_style_class_name('selected');
+            result.remove_style_pseudo_class('selected');
+        }
+    }
+
+    highlightTerms(description) {
+        if (!description)
+            return '';
+
+        if (!this._highlightRegex)
+            return description;
+
+        return description.replace(this._highlightRegex, '<b>$1</b>');
+    }
+};
+Signals.addSignalMethods(SearchResults.prototype);
+
+var SearchProviderInfo = GObject.registerClass(class Search_Menu_SearchProviderInfo extends MW.SearchMenuPopupBaseMenuItem {
+    _init(provider, menuLayout) {
+        super._init(menuLayout);
+        this.provider = provider;
+        this._menuLayout = menuLayout;
+        this._settings = this._menuLayout._settings;
+        this.description = this.provider.appInfo.get_description();
+        if (this.description)
+            this.description = this.description.split('\n')[0];
+
+        this.label = new St.Label({
+            text: provider.appInfo.get_name(),
+            x_align: Clutter.ActorAlign.START,
+            y_align: Clutter.ActorAlign.CENTER,
+            style: 'text-align: left;',
+        });
+
+        this.label.style = 'font-weight: bold;';
+        this.actor.x_fill = true;
+        this.actor.y_fill = false;
+        this.actor.x_align = Clutter.ActorAlign.FILL;
+        this.actor.y_align = Clutter.ActorAlign.START;
+        this.actor.x_expand = true;
+        this._moreText = '';
+        this.actor.style = null;
+        this.box.add_child(this.label);
+    }
+
+    _onHover() {
+        if (this.actor.hover && this._menuLayout.newSearch._highlightDefault)
+            this._menuLayout.newSearch.highlightDefault(false);
+        super._onHover();
+    }
+
+    animateLaunch() {
+        let app = appSys.lookup_app(this.provider.appInfo.get_id());
+    }
+
+    setMoreCount(count) {
+        this._moreText = ngettext('%d more', '%d more', count).format(count);
+
+        if (count > 0)
+            this.label.text = `${this.provider.appInfo.get_name()}  (${this._moreText})`;
+
+    }
+});
diff --git a/extensions/search/searchMenuLayout.js b/extensions/search/searchMenuLayout.js
new file mode 100644
index 0000000..d1fb4a7
--- /dev/null
+++ b/extensions/search/searchMenuLayout.js
@@ -0,0 +1,80 @@
+/*
+ * ArcMenu - A traditional application menu for GNOME 3
+ *
+ * ArcMenu Lead Developer and Maintainer
+ * Andrew Zaech https://gitlab.com/AndrewZaech
+ *
+ * ArcMenu Founder, Former Maintainer, and Former Graphic Designer
+ * LinxGem33 https://gitlab.com/LinxGem33 - (No Longer Active)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+const Me = imports.misc.extensionUtils.getCurrentExtension();
+
+const { Clutter, GLib, Gio, Gtk, Shell, St } = imports.gi;
+const BaseMenuLayout = Me.imports.baseMenuLayout;
+const Constants = Me.imports.constants;
+const Gettext = imports.gettext.domain(Me.metadata['gettext-domain']);
+const MW = Me.imports.menuWidgets;
+const PopupMenu = imports.ui.popupMenu;
+const Utils =  Me.imports.utils;
+const _ = Gettext.gettext;
+
+var createMenu = class extends BaseMenuLayout.BaseLayout {
+    constructor(mainButton) {
+        super(mainButton);
+        this.searchMenu = mainButton.searchMenu;
+    }
+
+    createLayout() {
+        // Search Box
+        this.searchBox = new MW.SearchBox(this);
+        this._searchBoxChangedId = this.searchBox.connect('changed', this._onSearchBoxChanged.bind(this));
+        this._searchBoxKeyPressId = this.searchBox.connect('key-press-event', this._onSearchBoxKeyPress.bind(this));
+        this._searchBoxKeyFocusInId = this.searchBox.connect('key-focus-in', this._onSearchBoxKeyFocusIn.bind(this));
+        this.searchBox.actor.style = 'margin: 0px; padding: 0px; width: 300px; height: 40px;';
+
+        // Search Result Box
+        this.applicationsBox = new St.BoxLayout({
+            vertical: true,
+        });
+        this.applicationsScrollBox = this._createScrollBox({
+            y_align: Clutter.ActorAlign.START,
+            overlay_scrollbars: true,
+            style_class: 'small-vfade',
+        });
+        this.applicationsScrollBox.style = 'width: 380px;';
+        this.applicationsScrollBox.add_actor(this.applicationsBox);
+        this.mainBox.add(this.applicationsScrollBox);
+
+        this.setDefaultMenuView();
+        this.createDefaultLabel();
+    }
+
+    createDefaultLabel() {
+        let labelString = '검색어를 입력하세요';
+        let defaultLabel = new PopupMenu.PopupMenuItem(labelString);
+        defaultLabel.label.style = 'font-weight: bold; font-size: 16px;';
+        this.applicationsBox.add_actor(defaultLabel.actor);
+    }
+
+    setDefaultMenuView() {
+        super.setDefaultMenuView();
+    }
+
+    _reload() {
+        super.reload();
+    }
+};
diff --git a/extensions/search/stylesheet.css b/extensions/search/stylesheet.css
new file mode 100644
index 0000000..f0399f7
--- /dev/null
+++ b/extensions/search/stylesheet.css
@@ -0,0 +1,298 @@
+#arc-search{
+width: 290px;
+}
+
+.arc-menu-status-text{
+color:rgba(211, 218, 227, 1);
+font-size:9pt;
+}
+
+.search-statustext{
+font-size:11pt;
+}
+
+.left-scroll-area{
+width:290px;
+}
+
+.left-scroll-area-small{
+width:205px;
+}
+
+.arc-empty-dash-drop-target{
+width: 290px;
+height: 2px;
+background-color:rgb(63,62,64);
+padding: 0 0;
+margin:0;
+}
+
+.left-box{
+width:290px;
+}
+
+.vert-sep{
+width:11px;
+}
+
+.default-search-entry{
+max-width: 17.667em;
+}
+
+.arc-search-entry{
+max-width: 17.667em;
+font-size:9pt;
+border-color:rgb(63,62,64);
+border-width: 1px;
+color:rgba(211, 218, 227, 1);
+background-color:rgba(28, 28, 28, 0.98);
+}
+
+.arc-search-entry:focus{
+border-color:rgba(238, 238, 236, 0.1);
+border-width: 1px;
+box-shadow: inset 0 0 0 1px rgba(250,250,249,0.1);
+}
+
+.arc-search-entry StLabel.hint-text{
+color: rgba(211,218,227,0.7);
+}
+
+.arc-menu-panel-menu:active{
+}
+
+#arc-menu-plasma-button{
+border-top-width: 2px;;
+border-color: transparent;
+}
+
+#arc-menu-plasma-button:active-item, .arc-menu-plasma-button:active{
+background-color: rgba(245, 245, 245, .05);
+border-top-width: 2px;
+border-color: rgb(61, 174, 235);
+}
+
+StScrollView .small-vfade{
+-st-vfade-offset: 44px;
+}
+
+.arc-menu-eject-button{
+-st-icon-style: symbolic;
+background-color: transparent;
+min-width: 16px;
+min-height: 0px;
+border-radius: 6px;
+padding: 0px 13px;
+}
+
+.arc-menu-eject-button:hover{
+background-color: rgba(186, 196,201, 0.1);
+}
+
+.arc-menu-button{
+-st-icon-style: symbolic;
+min-height: 0px;
+min-width: 16px;
+border-radius: 26px;
+padding: 13px;
+}
+
+.arc-menu-action{
+margin: 1px;
+background-color: transparent;
+box-shadow: none;
+color:rgba(211, 218, 227, 1);
+border-width: 1px;
+border-color: transparent;
+}
+
+.arc-menu-action:hover, .arc-menu-action:focus{
+color:rgba(255,255,255,1);
+background-color:rgba(238, 238, 236, 0.1);
+border-width: 1px;
+box-shadow: 0 1px 1px 0 rgba(15,15,15,0.98);
+border-color:rgba(15,15,15,0.98);
+}
+
+.arc-menu-action:active{
+box-shadow: none;
+color:rgba(255,255,255,1);
+background-color:rgba(202,202,196,0.1);
+border-width: 1px;
+border-color:rgba(2,2,2,0.98);
+}
+
+.arc-menu-menu-item-indicator{
+color: rgb(41, 165, 249);
+}
+
+.arc-menu-menu-item-text-indicator{
+background-color: rgba(196, 196, 196, 0.3);
+}
+
+.tooltip-menu-item{
+padding: 2px 5px;
+max-width:550px;
+min-height: 0px;
+}
+
+.arc-menu{
+-boxpointer-gap: 0px;
+min-width: 15em;
+color: #D3DAE3;
+border-image: none;
+box-shadow: none;
+font-size:9pt;
+}
+
+.arc-menu .popup-sub-menu{
+padding-bottom: 1px;
+background-color: rgba(38,38,38,0.98);
+}
+
+.arc-menu .popup-menu-content{
+padding: 1em 0em;
+}
+
+.arc-menu .popup-menu-item{
+spacing: 12px;
+border: 0;
+color:rgba(211, 218, 227, 1);
+}
+
+.arc-menu .popup-menu-item:ltr{
+padding: .4em 1.75em .4em 0em;
+}
+
+.arc-menu .popup-menu-item:rtl
+{
+padding: .4em 0em .4em 1.75em;
+}
+
+.arc-menu .popup-menu-item:checked{
+background-color:rgba(38,38,38,0.98);
+box-shadow: 0;
+font-weight: bold;
+
+border-color: rgba(66,66,66,0.98);
+border-top-width:1px;
+}
+
+.arc-menu .popup-menu-item.selected, .arc-menu .popup-menu-item:active{
+background-color:rgba(238, 238, 236, 0.1);
+color: rgba(255,255,255,1);
+}
+
+.arc-menu .popup-menu-item:disabled{
+color: rgba(238, 238, 236, 0.5);
+}
+
+.arc-menu-boxpointer{
+-arrow-border-radius:0px;
+-arrow-background-color:rgba(28, 28, 28, 0.98);
+-arrow-border-color:rgb(63,62,64);
+-arrow-border-width:0px;
+-arrow-base:0px;
+-arrow-rise:0px;
+}
+
+.arc-menu .popup-menu-content{
+margin: 0;
+background-color: transparent;
+border-radius: 0px;
+box-shadow: 0;
+}
+
+.arc-menu-sep{
+height: 1px;
+margin: 5px 20px;
+background-color: transparent;
+border-bottom-style: solid;
+border-color:rgb(63,62,64);
+border-bottom-width: 1px;
+}
+
+.menu-user-avatar{
+background-size: contain;
+border: none;
+border-radius: 999px;
+}
+
+.arc-right-click{
+max-width:350px;
+min-width: 15em;
+color: #D3DAE3;
+border-image: none;
+font-size:9pt;
+margin:0px;
+padding:0px;box-shadow: none;
+spacing:0px;
+}
+
+.arc-right-click .popup-sub-menu{
+padding-bottom: 1px;
+background-color: #3a393b;
+box-shadow: inset 0 -1px 0px #323233;
+}
+
+.arc-right-click .popup-menu-content{
+padding: 3px 0px;
+}
+
+.arc-right-click .popup-menu-item{
+spacing: 12px;
+border: 0;
+color:rgba(211, 218, 227, 1);
+}
+
+.arc-right-click .popup-menu-item:ltr{
+padding: .4em 1.75em .4em 0em;
+}
+
+.arc-right-click .popup-menu-item:rtl{
+padding: .4em 0em .4em 1.75em;
+}
+
+.arc-right-click .popup-menu-item:checked{
+background-color: #3a393b;
+box-shadow: inset 0 1px 0px #323233;
+font-weight: bold;
+}
+
+.arc-right-click .popup-menu-item.selected, .arc-right-click .popup-menu-item:active{
+background-color:rgba(250,250,249,0.1);
+color: rgba(255,255,255,1);
+}
+
+.arc-right-click .popup-menu-item:disabled{
+color: rgba(238, 238, 236, 0.5);
+}
+
+.arc-right-click .popup-menu-item:insensitive{
+color:rgba(164,179,197,1);
+}
+
+.arc-right-click-boxpointer{
+-arrow-border-radius:0px;
+-arrow-background-color:rgba(40,40,40,0.98);
+-arrow-border-color:rgba(53,53,53,0.98);
+-arrow-border-width:1px;
+-arrow-base:0px;
+-arrow-rise:0px;
+}
+
+.arc-right-click .popup-menu-content{
+margin: 0;
+background-color: transparent;
+border-radius: 0px;
+box-shadow: 0;
+}
+
+.app-right-click-sep {
+height: 1px;
+margin: 2px 35px 3px 35px;
+background-color: transparent;
+border-bottom-style: solid;
+border-color:rgb(63,62,64);
+border-bottom-width: 1px;
+}
diff --git a/extensions/search/utils.js b/extensions/search/utils.js
new file mode 100644
index 0000000..6581e4d
--- /dev/null
+++ b/extensions/search/utils.js
@@ -0,0 +1,169 @@
+/*
+ * ArcMenu - A traditional application menu for GNOME 3
+ *
+ * ArcMenu Lead Developer and Maintainer
+ * Andrew Zaech https://gitlab.com/AndrewZaech
+ *
+ * ArcMenu Founder, Former Maintainer, and Former Graphic Designer
+ * LinxGem33 https://gitlab.com/LinxGem33 - (No Longer Active)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+const Me = imports.misc.extensionUtils.getCurrentExtension();
+
+var ScrollViewShader = `uniform sampler2D tex;
+uniform float height;
+uniform float width;
+uniform float vfade_offset;
+uniform float hfade_offset;
+uniform bool  fade_edges_top;
+uniform bool  fade_edges_right;
+uniform bool  fade_edges_bottom;
+uniform bool  fade_edges_left;
+
+uniform vec2 fade_area_topleft;
+uniform vec2 fade_area_bottomright;
+
+void main ()
+{
+    cogl_color_out = cogl_color_in * texture2D (tex, vec2 (cogl_tex_coord_in[0].xy));
+
+    float y = height * cogl_tex_coord_in[0].y;
+    float x = width * cogl_tex_coord_in[0].x;
+
+    if (x > fade_area_topleft[0] && x < fade_area_bottomright[0] &&
+        y > fade_area_topleft[1] && y < fade_area_bottomright[1]) {
+        float ratio = 1.0;
+        float fade_bottom_start = fade_area_bottomright[1] - vfade_offset;
+        float fade_right_start = fade_area_bottomright[0] - hfade_offset;
+        bool fade_top = y < vfade_offset && fade_edges_top;
+        bool fade_bottom = y > fade_bottom_start && fade_edges_bottom;
+        bool fade_left = x < hfade_offset && fade_edges_left;
+        bool fade_right = x > fade_right_start && fade_edges_right;
+
+        float vfade_scale = height / vfade_offset;
+        if (fade_top) {
+            ratio *= y / vfade_offset;
+        }
+
+        if (fade_bottom) {
+            ratio *= (fade_area_bottomright[1] - y) / (fade_area_bottomright[1] - fade_bottom_start);
+        }
+
+        float hfade_scale = width / hfade_offset;
+        if (fade_left) {
+            ratio *= x / hfade_offset;
+        }
+
+        if (fade_right) {
+            ratio *= (fade_area_bottomright[0] - x) / (fade_area_bottomright[0] - fade_right_start);
+        }
+
+        cogl_color_out *= ratio;
+    }
+}`;
+
+function ensureActorVisibleInScrollView(actor) {
+    let box = actor.get_allocation_box();
+    let y1 = box.y1, y2 = box.y2;
+
+    let parent = actor.get_parent();
+    while (!(parent instanceof imports.gi.St.ScrollView)) {
+        if (!parent)
+            return;
+
+        box = parent.get_allocation_box();
+        y1 += box.y1;
+        y2 += box.y1;
+        parent = parent.get_parent();
+    }
+
+    let adjustment = parent.vscroll.adjustment;
+    let [value, lower_, upper, stepIncrement_, pageIncrement_, pageSize] = adjustment.get_values();
+
+    let offset = 0;
+    let vfade = parent.get_effect('fade');
+    if (vfade)
+        offset = vfade.vfade_offset;
+
+    if (y1 < value + offset)
+        value = Math.max(0, y1 - offset);
+    else if (y2 > value + pageSize - offset)
+        value = Math.min(upper, y2 + offset - pageSize);
+    else
+        return;
+
+    adjustment.set_value(value);
+}
+
+function getArraysEqual(a, b) {
+    if (a instanceof Array && b instanceof Array) {
+        if (a.length !== b.length)
+            return false;
+        for (let i = 0; i < a.length; i++) {
+            if (!getArraysEqual(a[i], b[i]))
+                return false;
+        }
+        return true;
+    } else {
+        return a === b;
+    }
+}
+
+function createTooltip(button, widget, titleLabel, description) {
+    let lbl = titleLabel.clutter_text;
+    lbl.get_allocation_box();
+    let isEllipsized = lbl.get_layout().is_ellipsized();
+    if (isEllipsized || description) {
+        let titleText, descriptionText;
+        if (isEllipsized && description) {
+            titleText = titleLabel.text.replace(/\n/g, ' ');
+            descriptionText = description;
+        } else if (isEllipsized && !description) {
+            titleText = titleLabel.text.replace(/\n/g, ' ');
+        } else if (!isEllipsized && description) {
+            descriptionText = description;
+        }
+        widget.tooltip = new Me.imports.menuWidgets.Tooltip(button, widget.actor, titleText, descriptionText);
+        widget.tooltip._onHover();
+    }
+}
+
+function getDashToPanelPosition(settings, index) {
+    var positions = null;
+    var side;
+
+    try {
+        positions = JSON.parse(settings.get_string('panel-positions'));
+    } catch (e) {
+        log(`Error parsing Dash to Panel positions: ${e.message}`);
+    }
+
+    if (!positions)
+        side = settings.get_string('panel-position');
+    else
+        side = positions[index];
+
+
+    if (side === 'TOP')
+        return imports.gi.St.Side.TOP;
+    else if (side === 'RIGHT')
+        return imports.gi.St.Side.RIGHT;
+    else if (side === 'BOTTOM')
+        return imports.gi.St.Side.BOTTOM;
+    else if (side === 'LEFT')
+        return imports.gi.St.Side.LEFT;
+    else
+        return imports.gi.St.Side.TOP;
+}
diff --git a/meson.build b/meson.build
index 12cae1d..03802a9 100644
--- a/meson.build
+++ b/meson.build
@@ -47,7 +47,8 @@ tos_extensions = [
   'notification-center',
   #  'appindicator',
   'desktop-icons-ng',
-  'alternate-tab'
+  'alternate-tab',
+  'search'
 ]
 
 
