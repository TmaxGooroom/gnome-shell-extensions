From: jiyun_ha <jiyun_ha@tmax.co.kr>
Date: Thu, 13 May 2021 15:25:31 +0900
Subject: [feat] dash-to-panel : apply eslint to source Code

 - applied eslint format to appIcons.js

[IMS] N/A
---
 extensions/dash-to-panel/appIcons.js | 374 +++++++++++++++++------------------
 1 file changed, 183 insertions(+), 191 deletions(-)

diff --git a/extensions/dash-to-panel/appIcons.js b/extensions/dash-to-panel/appIcons.js
index c2c50f3..83cb42d 100644
--- a/extensions/dash-to-panel/appIcons.js
+++ b/extensions/dash-to-panel/appIcons.js
@@ -23,30 +23,24 @@
 
 
 const Clutter = imports.gi.Clutter;
-const Gio = imports.gi.Gio;
 const GLib = imports.gi.GLib;
-const Gtk = imports.gi.Gtk;
+const GObject = imports.gi.GObject;
+const Gio = imports.gi.Gio;
 const Signals = imports.signals;
-const Lang = imports.lang;
 const Meta = imports.gi.Meta;
 const Shell = imports.gi.Shell;
 const St = imports.gi.St;
-const Mainloop = imports.mainloop;
 
 const Config = imports.misc.config;
 const AppDisplay = imports.ui.appDisplay;
-const AppFavorites = imports.ui.appFavorites;
 const Dash = imports.ui.dash;
 const DND = imports.ui.dnd;
-const IconGrid = imports.ui.iconGrid;
 const Main = imports.ui.main;
 const PopupMenu = imports.ui.popupMenu;
 const Util = imports.misc.util;
-const Workspace = imports.ui.workspace;
 
 const Me = imports.misc.extensionUtils.getCurrentExtension();
 const Utils = Me.imports.utils;
-const Panel = Me.imports.panel;
 const Taskbar = Me.imports.taskbar;
 const Progress = Me.imports.progress;
 const _ = imports.gettext.domain(Utils.TRANSLATION_DOMAIN).gettext;
@@ -121,10 +115,10 @@ var taskbarAppIcon = Utils.defineClass({
 
         // Fix touchscreen issues before the listener is added by the parent constructor.
         this._onTouchEvent = function (actor, event) {
-            if (event.type() == Clutter.EventType.TOUCH_BEGIN) {
+            if (event.type() === Clutter.EventType.TOUCH_BEGIN) {
                 // Open the popup menu on long press.
                 this._setPopupTimeout();
-            } else if (this._menuTimeoutId != 0 && (event.type() == Clutter.EventType.TOUCH_END || event.type() == Clutter.EventType.TOUCH_CANCEL)) {
+            } else if (this._menuTimeoutId !== 0 && (event.type() === Clutter.EventType.TOUCH_END || event.type() === Clutter.EventType.TOUCH_CANCEL)) {
                 // Activate/launch the application.
                 this.activate(1);
                 this._removeMenuTimeout();
@@ -134,9 +128,9 @@ var taskbarAppIcon = Utils.defineClass({
             return Clutter.EVENT_STOP;
         };
         // Hack for missing TOUCH_END event.
-        this._onLeaveEvent = function (actor, event) {
+        this._onLeaveEvent = function () {
             this.actor.fake_release();
-            if (this._menuTimeoutId != 0)
+            if (this._menuTimeoutId !== 0)
                 this.activate(1); // Activate/launch the application if TOUCH_END didn't fire.
             this._removeMenuTimeout();
         };
@@ -197,10 +191,10 @@ var taskbarAppIcon = Utils.defineClass({
         this._showDots();
 
         this._focusWindowChangedId = global.display.connect('notify::focus-window',
-            Lang.bind(this, this._onFocusAppChanged));
+            this._onFocusAppChanged.bind(this));
 
         this._windowEnteredMonitorId = this._windowLeftMonitorId = 0;
-        this._stateChangedId = this.app.connect('windows-changed', Lang.bind(this, this.onWindowsChanged));
+        this._stateChangedId = this.app.connect('windows-changed', this.onWindowsChanged.bind(this));
 
         if (!this.window) {
             if (Me.settings.get_boolean('isolate-monitors')) {
@@ -212,49 +206,49 @@ var taskbarAppIcon = Utils.defineClass({
             this._minimizedWindowChangeId = 0;
         } else {
             this._titleWindowChangeId = this.window.connect('notify::title',
-                Lang.bind(this, this._updateWindowTitle));
+                this._updateWindowTitle.bind(this));
 
             this._minimizedWindowChangeId = this.window.connect('notify::minimized',
-                Lang.bind(this, this._updateWindowTitleStyle));
+                this._updateWindowTitleStyle.bind(this));
         }
 
         this._scrollEventId = this.actor.connect('scroll-event', this._onMouseScroll.bind(this));
 
         this._overviewWindowDragEndId = Main.overview.connect('window-drag-end',
-            Lang.bind(this, this._onOverviewWindowDragEnd));
+            this._onOverviewWindowDragEnd.bind(this));
 
         this._switchWorkspaceId = global.window_manager.connect('switch-workspace',
-            Lang.bind(this, this._onSwitchWorkspace));
+            this._onSwitchWorkspace.bind(this));
 
         this._hoverChangeId = this.actor.connect('notify::hover', () => this._onAppIconHoverChanged());
 
         this._dtpSettingsSignalIds = [
-            Me.settings.connect('changed::dot-position', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-size', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-style-focused', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-style-unfocused', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-color-dominant', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-color-override', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-color-1', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-color-2', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-color-3', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-color-4', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-color-unfocused-different', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-color-unfocused-1', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-color-unfocused-2', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-color-unfocused-3', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::dot-color-unfocused-4', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::focus-highlight', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::focus-highlight-dominant', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::focus-highlight-color', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::focus-highlight-opacity', Lang.bind(this, this._settingsChangeRefresh)),
-            Me.settings.connect('changed::group-apps-label-font-size', Lang.bind(this, this._updateWindowTitleStyle)),
-            Me.settings.connect('changed::group-apps-label-font-weight', Lang.bind(this, this._updateWindowTitleStyle)),
-            Me.settings.connect('changed::group-apps-label-font-color', Lang.bind(this, this._updateWindowTitleStyle)),
-            Me.settings.connect('changed::group-apps-label-font-color-minimized', Lang.bind(this, this._updateWindowTitleStyle)),
-            Me.settings.connect('changed::group-apps-label-max-width', Lang.bind(this, this._updateWindowTitleStyle)),
-            Me.settings.connect('changed::group-apps-use-fixed-width', Lang.bind(this, this._updateWindowTitleStyle)),
-            Me.settings.connect('changed::group-apps-underline-unfocused', Lang.bind(this, this._settingsChangeRefresh)),
+            Me.settings.connect('changed::dot-position', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-size', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-style-focused', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-style-unfocused', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-color-dominant', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-color-override', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-color-1', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-color-2', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-color-3', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-color-4', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-color-unfocused-different', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-color-unfocused-1', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-color-unfocused-2', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-color-unfocused-3', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::dot-color-unfocused-4', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::focus-highlight', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::focus-highlight-dominant', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::focus-highlight-color', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::focus-highlight-opacity', this._settingsChangeRefresh.bind(this)),
+            Me.settings.connect('changed::group-apps-label-font-size', this._updateWindowTitleStyle.bind(this)),
+            Me.settings.connect('changed::group-apps-label-font-weight', this._updateWindowTitleStyle.bind(this)),
+            Me.settings.connect('changed::group-apps-label-font-color', this._updateWindowTitleStyle.bind(this)),
+            Me.settings.connect('changed::group-apps-label-font-color-minimized', this._updateWindowTitleStyle.bind(this)),
+            Me.settings.connect('changed::group-apps-label-max-width', this._updateWindowTitleStyle.bind(this)),
+            Me.settings.connect('changed::group-apps-use-fixed-width', this._updateWindowTitleStyle.bind(this)),
+            Me.settings.connect('changed::group-apps-underline-unfocused', this._settingsChangeRefresh.bind(this)),
         ];
 
         this.forcedOverview = false;
@@ -363,7 +357,7 @@ var taskbarAppIcon = Utils.defineClass({
         // and position are random values, which might exceeds the integer range
         // resulting in an error when assigned to the a rect. This is a more like
         // a workaround to prevent flooding the system with errors.
-        if (this.actor.get_stage() == null)
+        if (this.actor.get_stage() === null)
             return;
 
         let rect = new Meta.Rectangle();
@@ -417,12 +411,12 @@ var taskbarAppIcon = Utils.defineClass({
                 this.actor.disconnect(mappedId);
             });
         } else {
-            this._focusedDots = new St.DrawingArea(),
+            this._focusedDots = new St.DrawingArea();
             this._unfocusedDots = new St.DrawingArea();
-            this._focusedDots._tweeningToSize = null,
+            this._focusedDots._tweeningToSize = null;
             this._unfocusedDots._tweeningToSize = null;
 
-            this._focusedDots.connect('repaint', Lang.bind(this, function () {
+            this._focusedDots.connect('repaint', () => {
                 if (this._dashItemContainer.animatingOut) {
                     // don't draw and trigger more animations if the icon is in the middle of
                     // being added to the panel
@@ -430,9 +424,9 @@ var taskbarAppIcon = Utils.defineClass({
                 }
                 this._drawRunningIndicator(this._focusedDots, Me.settings.get_string('dot-style-focused'), true);
                 this._displayProperIndicator();
-            }));
+            });
 
-            this._unfocusedDots.connect('repaint', Lang.bind(this, function () {
+            this._unfocusedDots.connect('repaint', () => {
                 if (this._dashItemContainer.animatingOut) {
                     // don't draw and trigger more animations if the icon is in the middle of
                     // being added to the panel
@@ -440,7 +434,7 @@ var taskbarAppIcon = Utils.defineClass({
                 }
                 this._drawRunningIndicator(this._unfocusedDots, Me.settings.get_string('dot-style-unfocused'), false);
                 this._displayProperIndicator();
-            }));
+            });
 
             this._dotsContainer.add_child(this._unfocusedDots);
 
@@ -457,7 +451,7 @@ var taskbarAppIcon = Utils.defineClass({
 
     _resetDots() {
         let position = Me.settings.get_string('dot-position');
-        let isHorizontalDots = position == DOT_POSITION.TOP || position == DOT_POSITION.BOTTOM;
+        let isHorizontalDots = position === DOT_POSITION.TOP || position === DOT_POSITION.BOTTOM;
 
         [this._focusedDots, this._unfocusedDots].forEach(d => {
             d._tweeningToSize = null;
@@ -506,7 +500,7 @@ var taskbarAppIcon = Utils.defineClass({
     },
 
     _updateWindowTitle() {
-        if (this._windowTitle.text != this.window.title) {
+        if (this._windowTitle.text !== this.window.title) {
             this._windowTitle.text = (this.window.title ? this.window.title : this.app.get_name()).replace(/\r?\n|\r/g, '').trim();
 
             if (this._focusedDots)
@@ -529,20 +523,20 @@ var taskbarAppIcon = Utils.defineClass({
             if (!this.window) {
                 let containerWidth = this._dtpIconContainer.get_width() / Utils.getScaleFactor();
                 let backgroundSize = `${containerWidth}px ${
-                    containerWidth - (pos == DOT_POSITION.BOTTOM ? highlightMargin : 0)}px;`;
+                    containerWidth - (pos == DOT_POSITION.BOTTOM ? highlightMargin : 0)}px;`; // eslint-disable-line eqeqeq
 
-                if (focusedDotStyle == DOT_STYLE.CILIORA || focusedDotStyle == DOT_STYLE.SEGMENTED)
+                if (focusedDotStyle === DOT_STYLE.CILIORA || focusedDotStyle === DOT_STYLE.SEGMENTED)
                     highlightMargin += 1;
 
-                if (this._nWindows > 1 && focusedDotStyle == DOT_STYLE.METRO) {
+                if (this._nWindows > 1 && focusedDotStyle === DOT_STYLE.METRO) {
                     let bgSvg = '/img/highlight_stacked_bg';
 
-                    if (pos == DOT_POSITION.LEFT || pos == DOT_POSITION.RIGHT)
+                    if (pos === DOT_POSITION.LEFT || pos === DOT_POSITION.RIGHT)
                         bgSvg += this.dtpPanel.checkIfVertical() ? '_2' : '_3';
 
 
                     inlineStyle += `background-image: url('${Me.path}${bgSvg}.svg');` +
-                                   `background-position: 0 ${pos == DOT_POSITION.TOP ? highlightMargin : 0}px;` +
+                                   `background-position: 0 ${pos == DOT_POSITION.TOP ? highlightMargin : 0}px;` + // eslint-disable-line eqeqeq
                                    `background-size: ${backgroundSize}`;
                 }
             }
@@ -551,7 +545,7 @@ var taskbarAppIcon = Utils.defineClass({
             inlineStyle += `background-color: ${cssHexTocssRgba(highlightColor, Me.settings.get_int('focus-highlight-opacity') * 0.01)}`;
         }
 
-        if (this._dotsContainer.get_style() != inlineStyle && this._dotsContainer.mapped) {
+        if (this._dotsContainer.get_style() !== inlineStyle && this._dotsContainer.mapped) {
             if (!this._isGroupApps) {
                 // when the apps are ungrouped, set the style synchronously so the icons don't jump around on taskbar redraw
                 this._dotsContainer.set_style(inlineStyle);
@@ -563,7 +557,7 @@ var taskbarAppIcon = Utils.defineClass({
     },
 
     _checkIfFocusedApp() {
-        return tracker.focus_app == this.app;
+        return tracker.focus_app === this.app;
     },
 
     _checkIfMonitorHasFocus() {
@@ -591,16 +585,16 @@ var taskbarAppIcon = Utils.defineClass({
 
         if (!this._menu) {
             this._menu = new taskbarSecondaryMenu(this, this.dtpPanel);
-            this._menu.connect('activate-window', Lang.bind(this, function (menu, window) {
+            this._menu.connect('activate-window', (menu, window) => {
                 this.activateWindow(window, Me.settings);
-            }));
-            this._menu.connect('open-state-changed', Lang.bind(this, function (menu, isPoppedUp) {
+            });
+            this._menu.connect('open-state-changed', (menu_, isPoppedUp) => {
                 if (!isPoppedUp)
                     this._onMenuPoppedDown();
-            }));
-            let id = Main.overview.connect('hiding', Lang.bind(this, function () {
+            });
+            let id = Main.overview.connect('hiding', () => {
                 this._menu.close();
-            }));
+            });
             this._menu.actor.connect('destroy', () => {
                 Main.overview.disconnect(id);
             });
@@ -621,15 +615,15 @@ var taskbarAppIcon = Utils.defineClass({
         return false;
     },
 
-    _onFocusAppChanged(windowTracker) {
+    _onFocusAppChanged() {
         this._displayProperIndicator(true);
     },
 
-    _onOverviewWindowDragEnd(windowTracker) {
+    _onOverviewWindowDragEnd() {
         this._timeoutsHandler.add([T4, 0, () => this._displayProperIndicator()]);
     },
 
-    _onSwitchWorkspace(windowTracker) {
+    _onSwitchWorkspace() {
         if (this._isGroupApps)
             this._timeoutsHandler.add([T5, 0, () => this._displayProperIndicator(true)]);
         else
@@ -640,13 +634,13 @@ var taskbarAppIcon = Utils.defineClass({
     _displayProperIndicator(force) {
         let isFocused = this._isFocusedWindow();
         let position = Me.settings.get_string('dot-position');
-        let isHorizontalDots = position == DOT_POSITION.TOP || position == DOT_POSITION.BOTTOM;
+        let isHorizontalDots = position === DOT_POSITION.TOP || position === DOT_POSITION.BOTTOM;
 
         this._setIconStyle(isFocused);
 
         if (!this._isGroupApps) {
             if (this.window && (Me.settings.get_boolean('group-apps-underline-unfocused') || isFocused)) {
-                let align = Clutter.ActorAlign[position == DOT_POSITION.TOP || position == DOT_POSITION.LEFT ? 'START' : 'END'];
+                let align = Clutter.ActorAlign[position === DOT_POSITION.TOP || position === DOT_POSITION.LEFT ? 'START' : 'END'];
 
                 this._focusedDots.set_size(0, 0);
                 this._focusedDots[isHorizontalDots ? 'height' : 'width'] = this._getRunningIndicatorSize();
@@ -703,8 +697,8 @@ var taskbarAppIcon = Utils.defineClass({
             // AND (going from a wide style to a narrow style indicator or vice-versa
             // OR going from an open app to a closed app or vice versa)
             if (Me.settings.get_boolean('animate-app-switch') &&
-               (focusedIsWide != unfocusedIsWide ||
-                (this._focusedDots[sizeProp] != newUnfocusedDotsSize || this._unfocusedDots[sizeProp] != newFocusedDotsSize))) {
+               (focusedIsWide !== unfocusedIsWide ||
+                (this._focusedDots[sizeProp] !== newUnfocusedDotsSize || this._unfocusedDots[sizeProp] !== newFocusedDotsSize))) {
                 this._animateDotDisplay(this._focusedDots, newFocusedDotsSize, this._unfocusedDots, newUnfocusedDotsOpacity, force, sizeProp);
                 this._animateDotDisplay(this._unfocusedDots, newUnfocusedDotsSize, this._focusedDots, newFocusedDotsOpacity, force, sizeProp);
             } else {
@@ -717,18 +711,18 @@ var taskbarAppIcon = Utils.defineClass({
     },
 
     _animateDotDisplay(dots, newSize, otherDots, newOtherOpacity, force, sizeProp) {
-        if (dots[sizeProp] != newSize && dots._tweeningToSize !== newSize || force) {
+        if (dots[sizeProp] !== newSize && dots._tweeningToSize !== newSize || force) {
             let tweenOpts = {
                 time: Taskbar.DASH_ANIMATION_TIME,
                 transition: 'easeInOutCubic',
-                onComplete: Lang.bind(this, () => {
+                onComplete: () => {
                     if (newOtherOpacity > 0)
                         otherDots.opacity = newOtherOpacity;
                     dots._tweeningToSize = null;
-                }),
+                },
             };
 
-            if (newOtherOpacity == 0)
+            if (newOtherOpacity === 0)
                 otherDots.opacity = newOtherOpacity;
 
             tweenOpts[sizeProp] = newSize;
@@ -742,7 +736,7 @@ var taskbarAppIcon = Utils.defineClass({
         let focusedWindow = global.display.focus_window;
 
         while (focusedWindow) {
-            if (focusedWindow == this.window)
+            if (focusedWindow === this.window)
                 return true;
 
 
@@ -753,10 +747,10 @@ var taskbarAppIcon = Utils.defineClass({
     },
 
     _isWideDotStyle(dotStyle) {
-        return dotStyle == DOT_STYLE.SEGMENTED ||
-            dotStyle == DOT_STYLE.CILIORA ||
-            dotStyle == DOT_STYLE.METRO ||
-            dotStyle == DOT_STYLE.SOLID;
+        return dotStyle === DOT_STYLE.SEGMENTED ||
+            dotStyle === DOT_STYLE.CILIORA ||
+            dotStyle === DOT_STYLE.METRO ||
+            dotStyle === DOT_STYLE.SOLID;
     },
 
     _isThemeProvidingIndicator() {
@@ -788,12 +782,12 @@ var taskbarAppIcon = Utils.defineClass({
         // being used. We then define what buttonAction should be for this
         // event.
         let buttonAction = 0;
-        if (button && button == 2) {
+        if (button && button === 2) {
             if (modifiers & Clutter.ModifierType.SHIFT_MASK)
                 buttonAction = Me.settings.get_string('shift-middle-click-action');
             else
                 buttonAction = Me.settings.get_string('middle-click-action');
-        } else if (button && button == 1) {
+        } else if (button && button === 1) {
             if (modifiers & Clutter.ModifierType.SHIFT_MASK)
                 buttonAction = Me.settings.get_string('shift-click-action');
             else
@@ -806,7 +800,7 @@ var taskbarAppIcon = Utils.defineClass({
 
         // We check if the app is running, and that the # of windows is > 0 in
         // case we use workspace isolation,
-        let appIsRunning = this.app.state == Shell.AppState.RUNNING && appCount > 0;
+        let appIsRunning = this.app.state === Shell.AppState.RUNNING && appCount > 0;
 
         // We customize the action only when the application is already running
         if (appIsRunning && !this.isLauncher) {
@@ -815,8 +809,8 @@ var taskbarAppIcon = Utils.defineClass({
                 switch (buttonAction) {
                 case 'RAISE': case 'CYCLE': case 'CYCLE-MIN': case 'MINIMIZE': case 'TOGGLE-SHOWPREVIEW':
                     if (!Main.overview._shown &&
-                            (buttonAction == 'MINIMIZE' || buttonAction == 'TOGGLE-SHOWPREVIEW' || buttonAction == 'CYCLE-MIN') &&
-                            (this._isFocusedWindow() || buttonAction == 'MINIMIZE' && (button == 2 || modifiers & Clutter.ModifierType.SHIFT_MASK)))
+                            (buttonAction === 'MINIMIZE' || buttonAction === 'TOGGLE-SHOWPREVIEW' || buttonAction === 'CYCLE-MIN') &&
+                            (this._isFocusedWindow() || buttonAction === 'MINIMIZE' && (button === 2 || modifiers & Clutter.ModifierType.SHIFT_MASK)))
                         this.window.minimize();
                     else
                         Main.activateWindow(this.window);
@@ -852,11 +846,11 @@ var taskbarAppIcon = Utils.defineClass({
                     if (!Main.overview._shown || modifiers) {
                         // If we have button=2 or a modifier, allow minimization even if
                         // the app is not focused
-                        if (appHasFocus || button == 2 || modifiers & Clutter.ModifierType.SHIFT_MASK) {
+                        if (appHasFocus || button === 2 || modifiers & Clutter.ModifierType.SHIFT_MASK) {
                             // minimize all windows on double click and always in the case of primary click without
                             // additional modifiers
-                            let all_windows = button == 1 && !modifiers || event.get_click_count() > 1;
-                            minimizeWindow(this.app, all_windows, monitor);
+                            let allWindows = button === 1 && !modifiers || event.get_click_count() > 1;
+                            minimizeWindow(this.app, allWindows, monitor);
                         } else {
                             activateAllWindows(this.app, monitor);
                         }
@@ -878,7 +872,7 @@ var taskbarAppIcon = Utils.defineClass({
                     break;
                 case 'CYCLE-MIN':
                     if (!Main.overview._shown) {
-                        if (appHasFocus || recentlyClickedApp == this.app && recentlyClickedAppWindows[recentlyClickedAppIndex % recentlyClickedAppWindows.length] == 'MINIMIZE')
+                        if (appHasFocus || recentlyClickedApp === this.app && recentlyClickedAppWindows[recentlyClickedAppIndex % recentlyClickedAppWindows.length] === 'MINIMIZE')
                             cycleThroughWindows(this.app, false, true, monitor);
                         else
                             activateFirstWindow(this.app, monitor);
@@ -889,7 +883,7 @@ var taskbarAppIcon = Utils.defineClass({
                     break;
                 case 'TOGGLE-SHOWPREVIEW':
                     if (!Main.overview._shown) {
-                        if (appCount == 1) {
+                        if (appCount === 1) {
                             if (appHasFocus)
                                 minimizeWindow(this.app, false, monitor);
                             else
@@ -898,7 +892,7 @@ var taskbarAppIcon = Utils.defineClass({
                             if (event.get_click_count() > 1) {
                                 // minimize all windows if double clicked
                                 minimizeWindow(this.app, true, monitor);
-                            } else if (previewedAppIcon != this) {
+                            } else if (previewedAppIcon !== this) {
                                 this._previewMenu.open(this);
                             }
 
@@ -956,7 +950,7 @@ var taskbarAppIcon = Utils.defineClass({
 
             for (let i = 1; i <= MAX_INDICATORS; i++) {
                 let className = `running${i}`;
-                if (i != this._nWindows)
+                if (i !== this._nWindows)
                     this.actor.remove_style_class_name(className);
                 else
                     this.actor.add_style_class_name(className);
@@ -988,7 +982,7 @@ var taskbarAppIcon = Utils.defineClass({
                 color = themeNode.get_background_color();
 
                 // theme didn't provide one, use a default
-                if (color.alpha == 0)
+                if (color.alpha === 0)
                     color = fallbackColor;
             }
         } else if (Me.settings.get_boolean('dot-color-override')) {
@@ -1005,7 +999,7 @@ var taskbarAppIcon = Utils.defineClass({
             color = themeNode.get_background_color();
 
             // theme didn't provide one, use a default
-            if (color.alpha == 0)
+            if (color.alpha === 0)
                 color = fallbackColor;
         }
 
@@ -1030,7 +1024,7 @@ var taskbarAppIcon = Utils.defineClass({
 
 
         let position = Me.settings.get_string('dot-position');
-        let isHorizontalDots = position == DOT_POSITION.TOP || position == DOT_POSITION.BOTTOM;
+        let isHorizontalDots = position === DOT_POSITION.TOP || position === DOT_POSITION.BOTTOM;
         let bodyColor = this._getRunningIndicatorColor(isFocused);
         let [areaWidth, areaHeight] = area.get_surface_size();
         let cr = area.get_context();
@@ -1041,23 +1035,23 @@ var taskbarAppIcon = Utils.defineClass({
         let startY = 0;
 
         if (isHorizontalDots) {
-            if (position == DOT_POSITION.BOTTOM)
+            if (position === DOT_POSITION.BOTTOM)
                 startY = areaHeight - size;
 
         } else {
             areaSize = areaHeight;
 
-            if (position == DOT_POSITION.RIGHT)
+            if (position === DOT_POSITION.RIGHT)
                 startX = areaWidth - size;
 
         }
 
-        if (type == DOT_STYLE.SOLID || type == DOT_STYLE.METRO) {
-            if (type == DOT_STYLE.SOLID || n <= 1) {
+        if (type === DOT_STYLE.SOLID || type === DOT_STYLE.METRO) {
+            if (type === DOT_STYLE.SOLID || n <= 1) {
                 cr.translate(startX, startY);
                 Clutter.cairo_set_source_color(cr, bodyColor);
                 cr.newSubPath();
-                cr.rectangle.apply(cr, [0, 0].concat(isHorizontalDots ? [areaSize, size] : [size, areaSize]));
+                cr.rectangle(...[0, 0].concat(isHorizontalDots ? [areaSize, size] : [size, areaSize]));
                 cr.fill();
             } else {
                 let blackenedLength = 1 / 48 * areaSize; // need to scale with the SVG for the stacked highlight
@@ -1071,15 +1065,15 @@ var taskbarAppIcon = Utils.defineClass({
 
                 Clutter.cairo_set_source_color(cr, bodyColor);
                 cr.newSubPath();
-                cr.rectangle.apply(cr, [0, 0].concat(isHorizontalDots ? [solidLength, size] : [size, solidLength]));
+                cr.rectangle(...[0, 0].concat(isHorizontalDots ? [solidLength, size] : [size, solidLength]));
                 cr.fill();
                 Clutter.cairo_set_source_color(cr, blackenedColor);
                 cr.newSubPath();
-                cr.rectangle.apply(cr, isHorizontalDots ? [solidLength, 0, 1, size] : [0, solidLength, size, 1]);
+                cr.rectangle(...isHorizontalDots ? [solidLength, 0, 1, size] : [0, solidLength, size, 1]);
                 cr.fill();
                 Clutter.cairo_set_source_color(cr, darkenedColor);
                 cr.newSubPath();
-                cr.rectangle.apply(cr, isHorizontalDots ? [solidDarkLength, 0, darkenedLength, size] : [0, solidDarkLength, size, darkenedLength]);
+                cr.rectangle(...isHorizontalDots ? [solidDarkLength, 0, darkenedLength, size] : [0, solidDarkLength, size, darkenedLength]);
                 cr.fill();
             }
         } else {
@@ -1092,9 +1086,9 @@ var taskbarAppIcon = Utils.defineClass({
             let draw;
             let drawDash = (i, dashLength) => {
                 dist = i * dashLength + i * spacing;
-                cr.rectangle.apply(cr, isHorizontalDots ? [dist, 0, dashLength, size] : [0, dist, size, dashLength]);
+                cr.rectangle(...isHorizontalDots ? [dist, 0, dashLength, size] : [0, dist, size, dashLength]);
             };
-
+            let radius;
             switch (type) {
             case DOT_STYLE.CILIORA:
                 spacing = size;
@@ -1102,40 +1096,40 @@ var taskbarAppIcon = Utils.defineClass({
                 translate = () => cr.translate(startX, startY);
                 preDraw = () => {
                     cr.newSubPath();
-                    cr.rectangle.apply(cr, [0, 0].concat(isHorizontalDots ? [length, size] : [size, length]));
+                    cr.rectangle(...[0, 0].concat(isHorizontalDots ? [length, size] : [size, length]));
                 };
                 draw = i => {
                     dist = length + i * spacing + (i - 1) * size;
-                    cr.rectangle.apply(cr, (isHorizontalDots ? [dist, 0] : [0, dist]).concat([size, size]));
+                    cr.rectangle(...(isHorizontalDots ? [dist, 0] : [0, dist]).concat([size, size]));
                 };
                 break;
             case DOT_STYLE.DOTS:
-                let radius = size / 2;
+                radius = size / 2;
 
                 translate = () => {
                     indicatorSize = Math.floor((areaSize - n * size - (n - 1) * spacing) / 2);
-                    cr.translate.apply(cr, isHorizontalDots ? [indicatorSize, startY] : [startX, indicatorSize]);
+                    cr.translate(...isHorizontalDots ? [indicatorSize, startY] : [startX, indicatorSize]);
                 };
                 draw = i => {
                     dist = (2 * i + 1) * radius + i * spacing;
-                    cr.arc.apply(cr, (isHorizontalDots ? [dist, radius] : [radius, dist]).concat([radius, 0, 2 * Math.PI]));
+                    cr.arc(...(isHorizontalDots ? [dist, radius] : [radius, dist]).concat([radius, 0, 2 * Math.PI]));
                 };
                 break;
             case DOT_STYLE.SQUARES:
                 translate = () => {
                     indicatorSize = Math.floor((areaSize - n * size - (n - 1) * spacing) / 2);
-                    cr.translate.apply(cr, isHorizontalDots ? [indicatorSize, startY] : [startX, indicatorSize]);
+                    cr.translate(...isHorizontalDots ? [indicatorSize, startY] : [startX, indicatorSize]);
                 };
                 draw = i => {
                     dist = i * size + i * spacing;
-                    cr.rectangle.apply(cr, (isHorizontalDots ? [dist, 0] : [0, dist]).concat([size, size]));
+                    cr.rectangle(...(isHorizontalDots ? [dist, 0] : [0, dist]).concat([size, size]));
                 };
                 break;
             case DOT_STYLE.DASHES:
                 length = Math.floor(areaSize / 4) - spacing;
                 translate = () => {
                     indicatorSize = Math.floor((areaSize - n * length - (n - 1) * spacing) / 2);
-                    cr.translate.apply(cr, isHorizontalDots ? [indicatorSize, startY] : [startX, indicatorSize]);
+                    cr.translate(...isHorizontalDots ? [indicatorSize, startY] : [startX, indicatorSize]);
                 };
                 draw = i => drawDash(i, length);
                 break;
@@ -1183,15 +1177,15 @@ var taskbarAppIcon = Utils.defineClass({
         // pixels, so make sure to consider the scale.
         // Set the font size to something smaller than the whole icon so it is
         // still visible. The border radius is large to make the shape circular
-        let [minWidth, natWidth] = this._dtpIconContainer.get_preferred_width(-1);
-        let font_size =  Math.round(Math.max(12, 0.3 * natWidth) / Utils.getScaleFactor());
-        let size = Math.round(font_size * 1.3);
+        let [minWidth_, natWidth] = this._dtpIconContainer.get_preferred_width(-1);
+        let fontSize =  Math.round(Math.max(12, 0.3 * natWidth) / Utils.getScaleFactor());
+        let size = Math.round(fontSize * 1.3);
         let label = bin.child;
-        let style = `font-size: ${font_size}px;` +
+        let style = `font-size: ${fontSize}px;` +
                     `border-radius: ${this.icon.iconSize}px;` +
                     `height: ${size}px;`;
 
-        if (fixedSize || label.get_text().length == 1)
+        if (fixedSize || label.get_text().length === 1)
             style += `width: ${size}px;`;
         else
             style += 'padding: 0 2px;';
@@ -1213,8 +1207,8 @@ var taskbarAppIcon = Utils.defineClass({
             this._numberOverlayBin.hide();
     },
 
-    handleDragOver(source, actor, x, y, time) {
-        if (source == Main.xdndHandler)
+    handleDragOver(source) {
+        if (source === Main.xdndHandler)
             this._previewMenu.close(true);
 
 
@@ -1237,10 +1231,10 @@ taskbarAppIcon.prototype.scaleAndFade = taskbarAppIcon.prototype.undoScaleAndFad
 function minimizeWindow(app, param, monitor) {
     // Param true make all app windows minimize
     let windows = getInterestingWindows(app, monitor);
-    let current_workspace = Utils.DisplayWrapper.getWorkspaceManager().get_active_workspace();
+    let currentWorkspace = Utils.DisplayWrapper.getWorkspaceManager().get_active_workspace();
     for (let i = 0; i < windows.length; i++) {
         let w = windows[i];
-        if (w.get_workspace() == current_workspace && w.showing_on_its_workspace()) {
+        if (w.get_workspace() === currentWorkspace && w.showing_on_its_workspace()) {
             w.minimize();
             // Just minimize one window. By specification it should be the
             // focused window on the current workspace.
@@ -1267,7 +1261,7 @@ function activateAllWindows(app, monitor) {
         return;
 
     for (let i = windows.length - 1; i >= 0; i--) {
-        if (windows[i].get_workspace().index() == activeWorkspace)
+        if (windows[i].get_workspace().index() === activeWorkspace)
             Main.activateWindow(windows[i]);
 
     }
@@ -1284,24 +1278,27 @@ function cycleThroughWindows(app, reversed, shouldMinimize, monitor) {
     // since the order changes upon window interaction
     let MEMORY_TIME = 3000;
 
-    let app_windows = getInterestingWindows(app, monitor);
+    let appWindows = getInterestingWindows(app, monitor);
 
     if (shouldMinimize)
-        app_windows.push('MINIMIZE');
+        appWindows.push('MINIMIZE');
 
     if (recentlyClickedAppLoopId > 0)
-        Mainloop.source_remove(recentlyClickedAppLoopId);
+        GLib.source_remove(recentlyClickedAppLoopId);
+
+    let s = GLib.timeout_source_new(MEMORY_TIME);
+    GObject.source_set_closure(s, resetRecentlyClickedApp);
+    recentlyClickedAppLoopId = s.attach(null);
 
-    recentlyClickedAppLoopId = Mainloop.timeout_add(MEMORY_TIME, resetRecentlyClickedApp);
 
     // If there isn't already a list of windows for the current app,
     // or the stored list is outdated, use the current windows list.
     if (!recentlyClickedApp ||
-        recentlyClickedApp.get_id() != app.get_id() ||
-        recentlyClickedAppWindows.length != app_windows.length ||
-        recentlyClickedAppMonitorIndex != monitor.index) {
+        recentlyClickedApp.get_id() !== app.get_id() ||
+        recentlyClickedAppWindows.length !== appWindows.length ||
+        recentlyClickedAppMonitorIndex !== monitor.index) {
         recentlyClickedApp = app;
-        recentlyClickedAppWindows = app_windows;
+        recentlyClickedAppWindows = appWindows;
         recentlyClickedAppIndex = 0;
         recentlyClickedAppMonitorIndex = monitor.index;
     }
@@ -1323,7 +1320,7 @@ function cycleThroughWindows(app, reversed, shouldMinimize, monitor) {
 
 function resetRecentlyClickedApp() {
     if (recentlyClickedAppLoopId > 0)
-        Mainloop.source_remove(recentlyClickedAppLoopId);
+        GLib.source_remove(recentlyClickedAppLoopId);
 
     recentlyClickedAppLoopId = 0;
     recentlyClickedApp = null;
@@ -1351,13 +1348,13 @@ function getInterestingWindows(app, monitor, isolateMonitors) {
     // that are not in the current workspace or on the same monitor as the appicon
     if (Me.settings.get_boolean('isolate-workspaces')) {
         windows = windows.filter(w => {
-            return w.get_workspace().index() == Utils.DisplayWrapper.getWorkspaceManager().get_active_workspace_index();
+            return w.get_workspace().index() === Utils.DisplayWrapper.getWorkspaceManager().get_active_workspace_index();
         });
     }
 
     if (monitor && Me.settings.get_boolean('multi-monitors') && (isolateMonitors || Me.settings.get_boolean('isolate-monitors'))) {
         windows = windows.filter(w => {
-            return w.get_monitor() == monitor.index;
+            return w.get_monitor() === monitor.index;
         });
     }
 
@@ -1427,34 +1424,32 @@ var taskbarSecondaryMenu = Utils.defineClass({
                 x_align: Clutter.ActorAlign.END });
             menuitem.actor.insert_child_above(_icon, menuitem.actor.get_first_child());
 
-            if (menuitem.actor.label_actor.text == _('Show Details')) {
+            if (menuitem.actor.label_actor.text === _('Show Details')) {
                 _icon.gicon = Gio.Icon.new_for_string('system-search-symbolic');
-            } else if (menuitem.actor.label_actor.text == _('Add to Favorites')) {
+            } else if (menuitem.actor.label_actor.text === _('Add to Favorites')) {
                 _icon.gicon = Gio.Icon.new_for_string('view-pin-symbolic');
-            } else if (menuitem.actor.label_actor.text == _('Remove from Favorites')) {
+            } else if (menuitem.actor.label_actor.text === _('Remove from Favorites')) {
                 _icon.gicon = Gio.Icon.new_for_string('view-pin-symbolic');
             } else {
                 // When the shell-window-tracker get app from window use .desktop file
                 // if the window created from a binary without .desktop file,
                 // the app info is null because the shell-window-tracker creates a dummy app
-                let app_info = this._source.app.app_info;
-                if (app_info)
+                let appInfo = this._source.app.app_info;
+                if (appInfo)
                     _icon.gicon = this._source.app.app_info.get_icon();
-
             }
         }
 
-        let add_icon_func = f.bind(this);
+        let addIconFunc = f.bind(this);
 
         for (let menuitem of this._getMenuItems())
-            add_icon_func(menuitem);
-
+            addIconFunc(menuitem);
 
         // Remove "Show Details" menu item
         if (!Me.settings.get_boolean('secondarymenu-contains-showdetails')) {
             let existingMenuItems = this._getMenuItems();
             for (let idx in existingMenuItems) {
-                if (existingMenuItems[idx].actor.label_actor.text == _('Show Details')) {
+                if (existingMenuItems[idx].actor.label_actor.text === _('Show Details')) {
                     this.box.remove_child(existingMenuItems[idx].actor);
                     if (existingMenuItems[idx - 1] instanceof PopupMenu.PopupSeparatorMenuItem)
                         this.box.remove_child(existingMenuItems[idx - 1].actor);
@@ -1469,11 +1464,11 @@ var taskbarSecondaryMenu = Utils.defineClass({
             if (appMenu) {
                 let remoteMenu = new imports.ui.remoteMenu.RemoteMenu(this._source.actor, this._source.app.menu, this._source.app.action_group);
                 let appMenuItems = remoteMenu._getMenuItems();
-                let seperator_idx = 0;
+                let seperatorIdx = 0;
                 for (var i = appMenuItems.length - 1 || 0; i >= 0; --i) {
                     let menuItem = appMenuItems[i];
                     let labelText = menuItem.actor.label_actor.text;
-                    if (labelText == _('New Window') || labelText == _('Quit'))
+                    if (labelText === _('New Window') || labelText === _('Quit'))
                         continue;
 
                     if (menuItem instanceof PopupMenu.PopupSeparatorMenuItem)
@@ -1482,7 +1477,7 @@ var taskbarSecondaryMenu = Utils.defineClass({
                     // this ends up getting called multiple times, and bombing due to the signal id's being invalid
                     // on a 2nd pass. disconnect the base handler and attach our own that wraps the id's in if statements
                     menuItem.disconnect(menuItem._popupMenuDestroyId);
-                    menuItem._popupMenuDestroyId = menuItem.connect('destroy', Lang.bind(this, function (menuItem) {
+                    menuItem._popupMenuDestroyId = menuItem.connect('destroy', () => {
                         if (menuItem._popupMenuDestroyId) {
                             menuItem.disconnect(menuItem._popupMenuDestroyId);
                             menuItem._popupMenuDestroyId = 0;
@@ -1500,9 +1495,9 @@ var taskbarSecondaryMenu = Utils.defineClass({
                             menuItem._sensitiveChangeId = 0;
                         }
                         this.disconnect(menuItem._parentSensitiveChangeId);
-                        if (menuItem == this._activeMenuItem)
+                        if (menuItem === this._activeMenuItem)
                             this._activeMenuItem = null;
-                    }));
+                    });
 
                     menuItem.actor.get_parent().remove_child(menuItem.actor);
                     if (menuItem instanceof PopupMenu.PopupSubMenuMenuItem) {
@@ -1519,36 +1514,36 @@ var taskbarSecondaryMenu = Utils.defineClass({
 
                         // replace to new icon
                         // FIXME : too complicated..?
-                        let old_icon = menuItem.actor.get_children()[1];
+                        let oldIcon = menuItem.actor.get_children()[1];
                         let _icon = new St.Icon({ style_class: 'popup-menu-icon',
                             x_align: Clutter.ActorAlign.END });
-                        menuItem.actor.insert_child_below(_icon, old_icon);
+                        menuItem.actor.insert_child_below(_icon, oldIcon);
 
-                        let icon_size = _icon.get_theme_node().get_length('icon-size');
+                        let iconSize = _icon.get_theme_node().get_length('icon-size');
 
-                        _icon.gicon = old_icon.gicon;
-                        _icon.set_size(icon_size, icon_size);
+                        _icon.gicon = oldIcon.gicon;
+                        _icon.set_size(iconSize, iconSize);
                         _icon.show();
-                        menuItem.actor.remove_child(old_icon);
+                        menuItem.actor.remove_child(oldIcon);
 
                         // move ornament position to right of text label
                         let ornament = new St.Label();
-                        let old_ornament = menuItem._ornament;
+                        let oldOrnament = menuItem._ornament;
 
                         menuItem.actor.add(ornament);
 
                         menuItem.setOrnament(PopupMenu.Ornament.NONE);
 
                         menuItem._ornamentLabel = ornament;
-                        menuItem.setOrnament(old_ornament);
+                        menuItem.setOrnament(oldOrnament);
                     }
 
-                    seperator_idx++;
+                    seperatorIdx++;
 
                 }
-                if (seperator_idx > 0) {
+                if (seperatorIdx > 0) {
                     let separator = new PopupMenu.PopupSeparatorMenuItem();
-                    this.addMenuItem(separator, seperator_idx);
+                    this.addMenuItem(separator, seperatorIdx);
                 }
             }
         }
@@ -1560,21 +1555,18 @@ var taskbarSecondaryMenu = Utils.defineClass({
         if (count > 0) {
             this._appendSeparator();
             let quitFromTaskbarMenuText = '';
-            if (count == 1)
+            if (count === 1)
                 quitFromTaskbarMenuText = _('Quit');
             else
                 quitFromTaskbarMenuText = _('Quit %d windows').format(count);
 
-            function close_window_func(menuitem, event) {
-                let app = this._source.app;
+            let closeWindowFunc = () => {
                 let windows = window ? [window] : app.get_windows();
-                for (i = 0; i < windows.length; i++)
-                    this._closeWindowInstance(windows[i]);
-
-            }
-            let close_window_func_binded = close_window_func.bind(this);
+                for (let j = 0; j < windows.length; j++)
+                    this._closeWindowInstance(windows[j]);
+            };
 
-            this.addAction(quitFromTaskbarMenuText, close_window_func_binded, 'window-close-symbolic');
+            this.addAction(quitFromTaskbarMenuText, closeWindowFunc.bind(this), 'window-close-symbolic');
         }
     },
 });
@@ -1584,7 +1576,7 @@ adjustMenuRedisplay(taskbarSecondaryMenu.prototype);
 /**
  * This function is used for extendDashItemContainer
  */
-function ItemShowLabel()  {
+function ItemShowLabel()  {  // eslint-disable-line no-unused-vars
     if (!this._labelText)
         return;
 
@@ -1681,15 +1673,15 @@ var ShowAppsIconWrapper = Utils.defineClass({
         this._onKeyboardPopupMenu = AppDisplay.AppIcon.prototype._onKeyboardPopupMenu;
 
         // No action on clicked (showing of the appsview is controlled elsewhere)
-        this._onClicked = Lang.bind(this, function (actor, button) {
+        this._onClicked = () => {
             this._removeMenuTimeout();
-        });
+        };
 
-        this.actor.connect('leave-event', Lang.bind(this, this._onLeaveEvent));
-        this.actor.connect('button-press-event', Lang.bind(this, this._onButtonPress));
-        this.actor.connect('touch-event', Lang.bind(this, this._onTouchEvent));
-        this.actor.connect('clicked', Lang.bind(this, this._onClicked));
-        this.actor.connect('popup-menu', Lang.bind(this, this._onKeyboardPopupMenu));
+        this.actor.connect('leave-event', this._onLeaveEvent.bind(this));
+        this.actor.connect('button-press-event', this._onButtonPress.bind(this));
+        this.actor.connect('touch-event', this._onTouchEvent.bind(this));
+        this.actor.connect('clicked', this._onClicked.bind(this));
+        this.actor.connect('popup-menu', this._onKeyboardPopupMenu.bind(this));
 
         this._menu = null;
         this._menuManager = new PopupMenu.PopupMenuManager(this.actor);
@@ -1726,9 +1718,9 @@ var ShowAppsIconWrapper = Utils.defineClass({
 
     _onButtonPress(_actor, event) {
         let button = event.get_button();
-        if (button == 1) {
+        if (button === 1) {
             this._setPopupTimeout();
-        } else if (button == 3) {
+        } else if (button === 3) {
             this.popupMenu();
             return Clutter.EVENT_STOP;
         }
@@ -1741,7 +1733,7 @@ var ShowAppsIconWrapper = Utils.defineClass({
     },
 
     _onTouchEvent(actor, event) {
-        if (event.type() == Clutter.EventType.TOUCH_BEGIN)
+        if (event.type() === Clutter.EventType.TOUCH_BEGIN)
             this._setPopupTimeout();
 
         return Clutter.EVENT_PROPAGATE;
@@ -1764,13 +1756,13 @@ var ShowAppsIconWrapper = Utils.defineClass({
     createMenu() {
         if (!this._menu) {
             this._menu = new MyShowAppsIconMenu(this.actor, this.realShowAppsIcon._dtpPanel);
-            this._menu.connect('open-state-changed', Lang.bind(this, function (menu, isPoppedUp) {
+            this._menu.connect('open-state-changed', (menu, isPoppedUp) => {
                 if (!isPoppedUp)
                     this._onMenuPoppedDown();
-            }));
-            let id = Main.overview.connect('hiding', Lang.bind(this, function () {
+            });
+            let id = Main.overview.connect('hiding', () => {
                 this._menu.close();
-            }));
+            });
             this._menu.actor.connect('destroy', () => {
                 Main.overview.disconnect(id);
             });
@@ -1834,7 +1826,7 @@ var MyShowAppsIconMenu = Utils.defineClass({
         }
 
         function _appendList(obj, commandList, titleList) {
-            if (commandList.length != titleList.length)
+            if (commandList.length !== titleList.length)
                 return;
 
 
@@ -1846,7 +1838,7 @@ var MyShowAppsIconMenu = Utils.defineClass({
             }
         }
 
-        if (this.sourceActor != Main.layoutManager.dummyCursor) {
+        if (this.sourceActor !== Main.layoutManager.dummyCursor) {
             _appendItem(this, {
                 title: 'Power options',
                 cmd: ['gnome-control-center', 'power'],
@@ -1933,7 +1925,7 @@ var MyShowAppsIconMenu = Utils.defineClass({
         if (this._source._dtpPanel) {
             this._appendSeparator();
             let item = this._appendMenuItem(this._source._dtpPanel._restoreWindowList ? _('Restore Windows') : _('Show Desktop'));
-            item.connect('activate', Lang.bind(this._source._dtpPanel, this._source._dtpPanel._onShowDesktopButtonPress));
+            item.connect('activate', this._source._dtpPanel._onShowDesktopButtonPress.bind(this._source._dtpPanel));
         }
     },
 });
@@ -1945,7 +1937,7 @@ function adjustMenuRedisplay(menuProto) {
     };
 }
 
-var getIconContainerStyle = function (isVertical) {
+function getIconContainerStyle(isVertical) {
     let style = 'padding: ';
 
     if (Me.settings.get_boolean('group-apps'))
@@ -1955,4 +1947,4 @@ var getIconContainerStyle = function (isVertical) {
 
 
     return style;
-};
+}
